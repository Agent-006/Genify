
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Agency
 * 
 */
export type Agency = $Result.DefaultSelection<Prisma.$AgencyPayload>
/**
 * Model Permissions
 * 
 */
export type Permissions = $Result.DefaultSelection<Prisma.$PermissionsPayload>
/**
 * Model SubAccount
 * 
 */
export type SubAccount = $Result.DefaultSelection<Prisma.$SubAccountPayload>
/**
 * Model Tags
 * 
 */
export type Tags = $Result.DefaultSelection<Prisma.$TagsPayload>
/**
 * Model Pipeline
 * 
 */
export type Pipeline = $Result.DefaultSelection<Prisma.$PipelinePayload>
/**
 * Model Lane
 * 
 */
export type Lane = $Result.DefaultSelection<Prisma.$LanePayload>
/**
 * Model Tickets
 * 
 */
export type Tickets = $Result.DefaultSelection<Prisma.$TicketsPayload>
/**
 * Model Trigger
 * 
 */
export type Trigger = $Result.DefaultSelection<Prisma.$TriggerPayload>
/**
 * Model Automation
 * 
 */
export type Automation = $Result.DefaultSelection<Prisma.$AutomationPayload>
/**
 * Model AutomationInstance
 * 
 */
export type AutomationInstance = $Result.DefaultSelection<Prisma.$AutomationInstancePayload>
/**
 * Model Action
 * 
 */
export type Action = $Result.DefaultSelection<Prisma.$ActionPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model Funnels
 * 
 */
export type Funnels = $Result.DefaultSelection<Prisma.$FunnelsPayload>
/**
 * Model FunnelPages
 * 
 */
export type FunnelPages = $Result.DefaultSelection<Prisma.$FunnelPagesPayload>
/**
 * Model ClassName
 * 
 */
export type ClassName = $Result.DefaultSelection<Prisma.$ClassNamePayload>
/**
 * Model AgencySidebarOption
 * 
 */
export type AgencySidebarOption = $Result.DefaultSelection<Prisma.$AgencySidebarOptionPayload>
/**
 * Model SubAccountSidebarOption
 * 
 */
export type SubAccountSidebarOption = $Result.DefaultSelection<Prisma.$SubAccountSidebarOptionPayload>
/**
 * Model Invitation
 * 
 */
export type Invitation = $Result.DefaultSelection<Prisma.$InvitationPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model AddOns
 * 
 */
export type AddOns = $Result.DefaultSelection<Prisma.$AddOnsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  AGENCY_OWNER: 'AGENCY_OWNER',
  AGENCY_ADMIN: 'AGENCY_ADMIN',
  SUBACCOUNT_USER: 'SUBACCOUNT_USER',
  SUBACCOUNT_GUEST: 'SUBACCOUNT_GUEST'
};

export type Role = (typeof Role)[keyof typeof Role]


export const TriggerTypes: {
  CONTACT_FORM: 'CONTACT_FORM'
};

export type TriggerTypes = (typeof TriggerTypes)[keyof typeof TriggerTypes]


export const ActionType: {
  CREATE_CONTACT: 'CREATE_CONTACT'
};

export type ActionType = (typeof ActionType)[keyof typeof ActionType]


export const Icon: {
  info: 'info'
};

export type Icon = (typeof Icon)[keyof typeof Icon]


export const InvitationStatus: {
  ACCEPTED: 'ACCEPTED',
  REVOKED: 'REVOKED',
  PENDING: 'PENDING'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const Plan: {
  price_10MhuWld5Bk5htqogRZXP2e: 'price_10MhuWld5Bk5htqogRZXP2e',
  price_10MhuWld5Bk5htqogRZXPmj: 'price_10MhuWld5Bk5htqogRZXPmj'
};

export type Plan = (typeof Plan)[keyof typeof Plan]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type TriggerTypes = $Enums.TriggerTypes

export const TriggerTypes: typeof $Enums.TriggerTypes

export type ActionType = $Enums.ActionType

export const ActionType: typeof $Enums.ActionType

export type Icon = $Enums.Icon

export const Icon: typeof $Enums.Icon

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type Plan = $Enums.Plan

export const Plan: typeof $Enums.Plan

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agency`: Exposes CRUD operations for the **Agency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agencies
    * const agencies = await prisma.agency.findMany()
    * ```
    */
  get agency(): Prisma.AgencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permissions`: Exposes CRUD operations for the **Permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permissions.findMany()
    * ```
    */
  get permissions(): Prisma.PermissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subAccount`: Exposes CRUD operations for the **SubAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubAccounts
    * const subAccounts = await prisma.subAccount.findMany()
    * ```
    */
  get subAccount(): Prisma.SubAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tags`: Exposes CRUD operations for the **Tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tags.findMany()
    * ```
    */
  get tags(): Prisma.TagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pipeline`: Exposes CRUD operations for the **Pipeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pipelines
    * const pipelines = await prisma.pipeline.findMany()
    * ```
    */
  get pipeline(): Prisma.PipelineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lane`: Exposes CRUD operations for the **Lane** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lanes
    * const lanes = await prisma.lane.findMany()
    * ```
    */
  get lane(): Prisma.LaneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tickets`: Exposes CRUD operations for the **Tickets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.tickets.findMany()
    * ```
    */
  get tickets(): Prisma.TicketsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trigger`: Exposes CRUD operations for the **Trigger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Triggers
    * const triggers = await prisma.trigger.findMany()
    * ```
    */
  get trigger(): Prisma.TriggerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.automation`: Exposes CRUD operations for the **Automation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Automations
    * const automations = await prisma.automation.findMany()
    * ```
    */
  get automation(): Prisma.AutomationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.automationInstance`: Exposes CRUD operations for the **AutomationInstance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationInstances
    * const automationInstances = await prisma.automationInstance.findMany()
    * ```
    */
  get automationInstance(): Prisma.AutomationInstanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.action`: Exposes CRUD operations for the **Action** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actions
    * const actions = await prisma.action.findMany()
    * ```
    */
  get action(): Prisma.ActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.funnels`: Exposes CRUD operations for the **Funnels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Funnels
    * const funnels = await prisma.funnels.findMany()
    * ```
    */
  get funnels(): Prisma.FunnelsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.funnelPages`: Exposes CRUD operations for the **FunnelPages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FunnelPages
    * const funnelPages = await prisma.funnelPages.findMany()
    * ```
    */
  get funnelPages(): Prisma.FunnelPagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.className`: Exposes CRUD operations for the **ClassName** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassNames
    * const classNames = await prisma.className.findMany()
    * ```
    */
  get className(): Prisma.ClassNameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agencySidebarOption`: Exposes CRUD operations for the **AgencySidebarOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencySidebarOptions
    * const agencySidebarOptions = await prisma.agencySidebarOption.findMany()
    * ```
    */
  get agencySidebarOption(): Prisma.AgencySidebarOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subAccountSidebarOption`: Exposes CRUD operations for the **SubAccountSidebarOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubAccountSidebarOptions
    * const subAccountSidebarOptions = await prisma.subAccountSidebarOption.findMany()
    * ```
    */
  get subAccountSidebarOption(): Prisma.SubAccountSidebarOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.InvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addOns`: Exposes CRUD operations for the **AddOns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddOns
    * const addOns = await prisma.addOns.findMany()
    * ```
    */
  get addOns(): Prisma.AddOnsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Agency: 'Agency',
    Permissions: 'Permissions',
    SubAccount: 'SubAccount',
    Tags: 'Tags',
    Pipeline: 'Pipeline',
    Lane: 'Lane',
    Tickets: 'Tickets',
    Trigger: 'Trigger',
    Automation: 'Automation',
    AutomationInstance: 'AutomationInstance',
    Action: 'Action',
    Contact: 'Contact',
    Media: 'Media',
    Funnels: 'Funnels',
    FunnelPages: 'FunnelPages',
    ClassName: 'ClassName',
    AgencySidebarOption: 'AgencySidebarOption',
    SubAccountSidebarOption: 'SubAccountSidebarOption',
    Invitation: 'Invitation',
    Notification: 'Notification',
    Subscription: 'Subscription',
    AddOns: 'AddOns'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "agency" | "permissions" | "subAccount" | "tags" | "pipeline" | "lane" | "tickets" | "trigger" | "automation" | "automationInstance" | "action" | "contact" | "media" | "funnels" | "funnelPages" | "className" | "agencySidebarOption" | "subAccountSidebarOption" | "invitation" | "notification" | "subscription" | "addOns"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Agency: {
        payload: Prisma.$AgencyPayload<ExtArgs>
        fields: Prisma.AgencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findFirst: {
            args: Prisma.AgencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findMany: {
            args: Prisma.AgencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          create: {
            args: Prisma.AgencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          createMany: {
            args: Prisma.AgencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AgencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          update: {
            args: Prisma.AgencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          deleteMany: {
            args: Prisma.AgencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          aggregate: {
            args: Prisma.AgencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgency>
          }
          groupBy: {
            args: Prisma.AgencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyCountAggregateOutputType> | number
          }
        }
      }
      Permissions: {
        payload: Prisma.$PermissionsPayload<ExtArgs>
        fields: Prisma.PermissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          findFirst: {
            args: Prisma.PermissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          findMany: {
            args: Prisma.PermissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>[]
          }
          create: {
            args: Prisma.PermissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          createMany: {
            args: Prisma.PermissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PermissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          update: {
            args: Prisma.PermissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          deleteMany: {
            args: Prisma.PermissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          aggregate: {
            args: Prisma.PermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissions>
          }
          groupBy: {
            args: Prisma.PermissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionsCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionsCountAggregateOutputType> | number
          }
        }
      }
      SubAccount: {
        payload: Prisma.$SubAccountPayload<ExtArgs>
        fields: Prisma.SubAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          findFirst: {
            args: Prisma.SubAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          findMany: {
            args: Prisma.SubAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>[]
          }
          create: {
            args: Prisma.SubAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          createMany: {
            args: Prisma.SubAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          update: {
            args: Prisma.SubAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          deleteMany: {
            args: Prisma.SubAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          aggregate: {
            args: Prisma.SubAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubAccount>
          }
          groupBy: {
            args: Prisma.SubAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubAccountCountArgs<ExtArgs>
            result: $Utils.Optional<SubAccountCountAggregateOutputType> | number
          }
        }
      }
      Tags: {
        payload: Prisma.$TagsPayload<ExtArgs>
        fields: Prisma.TagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findFirst: {
            args: Prisma.TagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findMany: {
            args: Prisma.TagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>[]
          }
          create: {
            args: Prisma.TagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          createMany: {
            args: Prisma.TagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          update: {
            args: Prisma.TagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          deleteMany: {
            args: Prisma.TagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          aggregate: {
            args: Prisma.TagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTags>
          }
          groupBy: {
            args: Prisma.TagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagsCountArgs<ExtArgs>
            result: $Utils.Optional<TagsCountAggregateOutputType> | number
          }
        }
      }
      Pipeline: {
        payload: Prisma.$PipelinePayload<ExtArgs>
        fields: Prisma.PipelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PipelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PipelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          findFirst: {
            args: Prisma.PipelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PipelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          findMany: {
            args: Prisma.PipelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>[]
          }
          create: {
            args: Prisma.PipelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          createMany: {
            args: Prisma.PipelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PipelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          update: {
            args: Prisma.PipelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          deleteMany: {
            args: Prisma.PipelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PipelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PipelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          aggregate: {
            args: Prisma.PipelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePipeline>
          }
          groupBy: {
            args: Prisma.PipelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PipelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PipelineCountArgs<ExtArgs>
            result: $Utils.Optional<PipelineCountAggregateOutputType> | number
          }
        }
      }
      Lane: {
        payload: Prisma.$LanePayload<ExtArgs>
        fields: Prisma.LaneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          findFirst: {
            args: Prisma.LaneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          findMany: {
            args: Prisma.LaneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>[]
          }
          create: {
            args: Prisma.LaneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          createMany: {
            args: Prisma.LaneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LaneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          update: {
            args: Prisma.LaneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          deleteMany: {
            args: Prisma.LaneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LaneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LaneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          aggregate: {
            args: Prisma.LaneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLane>
          }
          groupBy: {
            args: Prisma.LaneGroupByArgs<ExtArgs>
            result: $Utils.Optional<LaneGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaneCountArgs<ExtArgs>
            result: $Utils.Optional<LaneCountAggregateOutputType> | number
          }
        }
      }
      Tickets: {
        payload: Prisma.$TicketsPayload<ExtArgs>
        fields: Prisma.TicketsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          findFirst: {
            args: Prisma.TicketsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          findMany: {
            args: Prisma.TicketsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>[]
          }
          create: {
            args: Prisma.TicketsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          createMany: {
            args: Prisma.TicketsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          update: {
            args: Prisma.TicketsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          deleteMany: {
            args: Prisma.TicketsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          aggregate: {
            args: Prisma.TicketsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTickets>
          }
          groupBy: {
            args: Prisma.TicketsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketsCountArgs<ExtArgs>
            result: $Utils.Optional<TicketsCountAggregateOutputType> | number
          }
        }
      }
      Trigger: {
        payload: Prisma.$TriggerPayload<ExtArgs>
        fields: Prisma.TriggerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TriggerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TriggerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          findFirst: {
            args: Prisma.TriggerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TriggerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          findMany: {
            args: Prisma.TriggerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>[]
          }
          create: {
            args: Prisma.TriggerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          createMany: {
            args: Prisma.TriggerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TriggerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          update: {
            args: Prisma.TriggerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          deleteMany: {
            args: Prisma.TriggerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TriggerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TriggerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggerPayload>
          }
          aggregate: {
            args: Prisma.TriggerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrigger>
          }
          groupBy: {
            args: Prisma.TriggerGroupByArgs<ExtArgs>
            result: $Utils.Optional<TriggerGroupByOutputType>[]
          }
          count: {
            args: Prisma.TriggerCountArgs<ExtArgs>
            result: $Utils.Optional<TriggerCountAggregateOutputType> | number
          }
        }
      }
      Automation: {
        payload: Prisma.$AutomationPayload<ExtArgs>
        fields: Prisma.AutomationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          findFirst: {
            args: Prisma.AutomationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          findMany: {
            args: Prisma.AutomationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>[]
          }
          create: {
            args: Prisma.AutomationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          createMany: {
            args: Prisma.AutomationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AutomationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          update: {
            args: Prisma.AutomationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          deleteMany: {
            args: Prisma.AutomationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutomationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationPayload>
          }
          aggregate: {
            args: Prisma.AutomationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomation>
          }
          groupBy: {
            args: Prisma.AutomationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationCountAggregateOutputType> | number
          }
        }
      }
      AutomationInstance: {
        payload: Prisma.$AutomationInstancePayload<ExtArgs>
        fields: Prisma.AutomationInstanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationInstanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationInstanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          findFirst: {
            args: Prisma.AutomationInstanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationInstanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          findMany: {
            args: Prisma.AutomationInstanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>[]
          }
          create: {
            args: Prisma.AutomationInstanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          createMany: {
            args: Prisma.AutomationInstanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AutomationInstanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          update: {
            args: Prisma.AutomationInstanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          deleteMany: {
            args: Prisma.AutomationInstanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationInstanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutomationInstanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          aggregate: {
            args: Prisma.AutomationInstanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationInstance>
          }
          groupBy: {
            args: Prisma.AutomationInstanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationInstanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationInstanceCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationInstanceCountAggregateOutputType> | number
          }
        }
      }
      Action: {
        payload: Prisma.$ActionPayload<ExtArgs>
        fields: Prisma.ActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findFirst: {
            args: Prisma.ActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findMany: {
            args: Prisma.ActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          create: {
            args: Prisma.ActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          createMany: {
            args: Prisma.ActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          update: {
            args: Prisma.ActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          deleteMany: {
            args: Prisma.ActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          aggregate: {
            args: Prisma.ActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAction>
          }
          groupBy: {
            args: Prisma.ActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionCountArgs<ExtArgs>
            result: $Utils.Optional<ActionCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      Funnels: {
        payload: Prisma.$FunnelsPayload<ExtArgs>
        fields: Prisma.FunnelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FunnelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FunnelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>
          }
          findFirst: {
            args: Prisma.FunnelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FunnelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>
          }
          findMany: {
            args: Prisma.FunnelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>[]
          }
          create: {
            args: Prisma.FunnelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>
          }
          createMany: {
            args: Prisma.FunnelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FunnelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>
          }
          update: {
            args: Prisma.FunnelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>
          }
          deleteMany: {
            args: Prisma.FunnelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FunnelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FunnelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>
          }
          aggregate: {
            args: Prisma.FunnelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFunnels>
          }
          groupBy: {
            args: Prisma.FunnelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FunnelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FunnelsCountArgs<ExtArgs>
            result: $Utils.Optional<FunnelsCountAggregateOutputType> | number
          }
        }
      }
      FunnelPages: {
        payload: Prisma.$FunnelPagesPayload<ExtArgs>
        fields: Prisma.FunnelPagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FunnelPagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FunnelPagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagesPayload>
          }
          findFirst: {
            args: Prisma.FunnelPagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FunnelPagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagesPayload>
          }
          findMany: {
            args: Prisma.FunnelPagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagesPayload>[]
          }
          create: {
            args: Prisma.FunnelPagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagesPayload>
          }
          createMany: {
            args: Prisma.FunnelPagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FunnelPagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagesPayload>
          }
          update: {
            args: Prisma.FunnelPagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagesPayload>
          }
          deleteMany: {
            args: Prisma.FunnelPagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FunnelPagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FunnelPagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPagesPayload>
          }
          aggregate: {
            args: Prisma.FunnelPagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFunnelPages>
          }
          groupBy: {
            args: Prisma.FunnelPagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FunnelPagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.FunnelPagesCountArgs<ExtArgs>
            result: $Utils.Optional<FunnelPagesCountAggregateOutputType> | number
          }
        }
      }
      ClassName: {
        payload: Prisma.$ClassNamePayload<ExtArgs>
        fields: Prisma.ClassNameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassNameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassNameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          findFirst: {
            args: Prisma.ClassNameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassNameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          findMany: {
            args: Prisma.ClassNameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>[]
          }
          create: {
            args: Prisma.ClassNameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          createMany: {
            args: Prisma.ClassNameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassNameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          update: {
            args: Prisma.ClassNameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          deleteMany: {
            args: Prisma.ClassNameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassNameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassNameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          aggregate: {
            args: Prisma.ClassNameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassName>
          }
          groupBy: {
            args: Prisma.ClassNameGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassNameGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassNameCountArgs<ExtArgs>
            result: $Utils.Optional<ClassNameCountAggregateOutputType> | number
          }
        }
      }
      AgencySidebarOption: {
        payload: Prisma.$AgencySidebarOptionPayload<ExtArgs>
        fields: Prisma.AgencySidebarOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencySidebarOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencySidebarOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          findFirst: {
            args: Prisma.AgencySidebarOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencySidebarOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          findMany: {
            args: Prisma.AgencySidebarOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>[]
          }
          create: {
            args: Prisma.AgencySidebarOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          createMany: {
            args: Prisma.AgencySidebarOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AgencySidebarOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          update: {
            args: Prisma.AgencySidebarOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          deleteMany: {
            args: Prisma.AgencySidebarOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencySidebarOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgencySidebarOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          aggregate: {
            args: Prisma.AgencySidebarOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgencySidebarOption>
          }
          groupBy: {
            args: Prisma.AgencySidebarOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencySidebarOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencySidebarOptionCountArgs<ExtArgs>
            result: $Utils.Optional<AgencySidebarOptionCountAggregateOutputType> | number
          }
        }
      }
      SubAccountSidebarOption: {
        payload: Prisma.$SubAccountSidebarOptionPayload<ExtArgs>
        fields: Prisma.SubAccountSidebarOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubAccountSidebarOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubAccountSidebarOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          findFirst: {
            args: Prisma.SubAccountSidebarOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubAccountSidebarOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          findMany: {
            args: Prisma.SubAccountSidebarOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>[]
          }
          create: {
            args: Prisma.SubAccountSidebarOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          createMany: {
            args: Prisma.SubAccountSidebarOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubAccountSidebarOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          update: {
            args: Prisma.SubAccountSidebarOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          deleteMany: {
            args: Prisma.SubAccountSidebarOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubAccountSidebarOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubAccountSidebarOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          aggregate: {
            args: Prisma.SubAccountSidebarOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubAccountSidebarOption>
          }
          groupBy: {
            args: Prisma.SubAccountSidebarOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubAccountSidebarOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubAccountSidebarOptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubAccountSidebarOptionCountAggregateOutputType> | number
          }
        }
      }
      Invitation: {
        payload: Prisma.$InvitationPayload<ExtArgs>
        fields: Prisma.InvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      AddOns: {
        payload: Prisma.$AddOnsPayload<ExtArgs>
        fields: Prisma.AddOnsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddOnsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddOnsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          findFirst: {
            args: Prisma.AddOnsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddOnsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          findMany: {
            args: Prisma.AddOnsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>[]
          }
          create: {
            args: Prisma.AddOnsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          createMany: {
            args: Prisma.AddOnsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AddOnsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          update: {
            args: Prisma.AddOnsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          deleteMany: {
            args: Prisma.AddOnsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddOnsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddOnsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          aggregate: {
            args: Prisma.AddOnsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddOns>
          }
          groupBy: {
            args: Prisma.AddOnsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddOnsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddOnsCountArgs<ExtArgs>
            result: $Utils.Optional<AddOnsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    agency?: AgencyOmit
    permissions?: PermissionsOmit
    subAccount?: SubAccountOmit
    tags?: TagsOmit
    pipeline?: PipelineOmit
    lane?: LaneOmit
    tickets?: TicketsOmit
    trigger?: TriggerOmit
    automation?: AutomationOmit
    automationInstance?: AutomationInstanceOmit
    action?: ActionOmit
    contact?: ContactOmit
    media?: MediaOmit
    funnels?: FunnelsOmit
    funnelPages?: FunnelPagesOmit
    className?: ClassNameOmit
    agencySidebarOption?: AgencySidebarOptionOmit
    subAccountSidebarOption?: SubAccountSidebarOptionOmit
    invitation?: InvitationOmit
    notification?: NotificationOmit
    subscription?: SubscriptionOmit
    addOns?: AddOnsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Permissions: number
    Tickets: number
    Notification: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Permissions?: boolean | UserCountOutputTypeCountPermissionsArgs
    Tickets?: boolean | UserCountOutputTypeCountTicketsArgs
    Notification?: boolean | UserCountOutputTypeCountNotificationArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type AgencyCountOutputType
   */

  export type AgencyCountOutputType = {
    users: number
    SubAccount: number
    SidebarOption: number
    Invitation: number
    Notification: number
    AddOns: number
  }

  export type AgencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | AgencyCountOutputTypeCountUsersArgs
    SubAccount?: boolean | AgencyCountOutputTypeCountSubAccountArgs
    SidebarOption?: boolean | AgencyCountOutputTypeCountSidebarOptionArgs
    Invitation?: boolean | AgencyCountOutputTypeCountInvitationArgs
    Notification?: boolean | AgencyCountOutputTypeCountNotificationArgs
    AddOns?: boolean | AgencyCountOutputTypeCountAddOnsArgs
  }

  // Custom InputTypes
  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyCountOutputType
     */
    select?: AgencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountSubAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountSidebarOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencySidebarOptionWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountAddOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddOnsWhereInput
  }


  /**
   * Count Type SubAccountCountOutputType
   */

  export type SubAccountCountOutputType = {
    SidebarOption: number
    Permissions: number
    Funnels: number
    Media: number
    Contact: number
    Trigger: number
    Automation: number
    Pipeline: number
    Tags: number
    Notification: number
  }

  export type SubAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SidebarOption?: boolean | SubAccountCountOutputTypeCountSidebarOptionArgs
    Permissions?: boolean | SubAccountCountOutputTypeCountPermissionsArgs
    Funnels?: boolean | SubAccountCountOutputTypeCountFunnelsArgs
    Media?: boolean | SubAccountCountOutputTypeCountMediaArgs
    Contact?: boolean | SubAccountCountOutputTypeCountContactArgs
    Trigger?: boolean | SubAccountCountOutputTypeCountTriggerArgs
    Automation?: boolean | SubAccountCountOutputTypeCountAutomationArgs
    Pipeline?: boolean | SubAccountCountOutputTypeCountPipelineArgs
    Tags?: boolean | SubAccountCountOutputTypeCountTagsArgs
    Notification?: boolean | SubAccountCountOutputTypeCountNotificationArgs
  }

  // Custom InputTypes
  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountCountOutputType
     */
    select?: SubAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountSidebarOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountSidebarOptionWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionsWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountFunnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunnelsWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountTriggerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriggerWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountAutomationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountPipelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsWhereInput
  }

  /**
   * SubAccountCountOutputType without action
   */
  export type SubAccountCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type PipelineCountOutputType
   */

  export type PipelineCountOutputType = {
    Lane: number
  }

  export type PipelineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lane?: boolean | PipelineCountOutputTypeCountLaneArgs
  }

  // Custom InputTypes
  /**
   * PipelineCountOutputType without action
   */
  export type PipelineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineCountOutputType
     */
    select?: PipelineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PipelineCountOutputType without action
   */
  export type PipelineCountOutputTypeCountLaneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaneWhereInput
  }


  /**
   * Count Type LaneCountOutputType
   */

  export type LaneCountOutputType = {
    Tickets: number
  }

  export type LaneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tickets?: boolean | LaneCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * LaneCountOutputType without action
   */
  export type LaneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaneCountOutputType
     */
    select?: LaneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LaneCountOutputType without action
   */
  export type LaneCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketsWhereInput
  }


  /**
   * Count Type TicketsCountOutputType
   */

  export type TicketsCountOutputType = {
    Tags: number
  }

  export type TicketsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tags?: boolean | TicketsCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * TicketsCountOutputType without action
   */
  export type TicketsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketsCountOutputType
     */
    select?: TicketsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketsCountOutputType without action
   */
  export type TicketsCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsWhereInput
  }


  /**
   * Count Type TriggerCountOutputType
   */

  export type TriggerCountOutputType = {
    Automation: number
  }

  export type TriggerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Automation?: boolean | TriggerCountOutputTypeCountAutomationArgs
  }

  // Custom InputTypes
  /**
   * TriggerCountOutputType without action
   */
  export type TriggerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggerCountOutputType
     */
    select?: TriggerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TriggerCountOutputType without action
   */
  export type TriggerCountOutputTypeCountAutomationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationWhereInput
  }


  /**
   * Count Type AutomationCountOutputType
   */

  export type AutomationCountOutputType = {
    Action: number
    AutomationInstance: number
  }

  export type AutomationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Action?: boolean | AutomationCountOutputTypeCountActionArgs
    AutomationInstance?: boolean | AutomationCountOutputTypeCountAutomationInstanceArgs
  }

  // Custom InputTypes
  /**
   * AutomationCountOutputType without action
   */
  export type AutomationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationCountOutputType
     */
    select?: AutomationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AutomationCountOutputType without action
   */
  export type AutomationCountOutputTypeCountActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionWhereInput
  }

  /**
   * AutomationCountOutputType without action
   */
  export type AutomationCountOutputTypeCountAutomationInstanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationInstanceWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    Tickets: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tickets?: boolean | ContactCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketsWhereInput
  }


  /**
   * Count Type FunnelsCountOutputType
   */

  export type FunnelsCountOutputType = {
    FunnelPages: number
    ClassName: number
  }

  export type FunnelsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FunnelPages?: boolean | FunnelsCountOutputTypeCountFunnelPagesArgs
    ClassName?: boolean | FunnelsCountOutputTypeCountClassNameArgs
  }

  // Custom InputTypes
  /**
   * FunnelsCountOutputType without action
   */
  export type FunnelsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelsCountOutputType
     */
    select?: FunnelsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FunnelsCountOutputType without action
   */
  export type FunnelsCountOutputTypeCountFunnelPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunnelPagesWhereInput
  }

  /**
   * FunnelsCountOutputType without action
   */
  export type FunnelsCountOutputTypeCountClassNameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassNameWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    avatarUrl: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    role: $Enums.Role | null
    agencyId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    avatarUrl: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    role: $Enums.Role | null
    agencyId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    avatarUrl: number
    email: number
    createdAt: number
    updatedAt: number
    role: number
    agencyId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    avatarUrl?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    agencyId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    avatarUrl?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    agencyId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    avatarUrl?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    agencyId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    avatarUrl: string
    email: string
    createdAt: Date
    updatedAt: Date
    role: $Enums.Role
    agencyId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    avatarUrl?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    agencyId?: boolean
    Agency?: boolean | User$AgencyArgs<ExtArgs>
    Permissions?: boolean | User$PermissionsArgs<ExtArgs>
    Tickets?: boolean | User$TicketsArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    avatarUrl?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    agencyId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "avatarUrl" | "email" | "createdAt" | "updatedAt" | "role" | "agencyId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | User$AgencyArgs<ExtArgs>
    Permissions?: boolean | User$PermissionsArgs<ExtArgs>
    Tickets?: boolean | User$TicketsArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Agency: Prisma.$AgencyPayload<ExtArgs> | null
      Permissions: Prisma.$PermissionsPayload<ExtArgs>[]
      Tickets: Prisma.$TicketsPayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      avatarUrl: string
      email: string
      createdAt: Date
      updatedAt: Date
      role: $Enums.Role
      agencyId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Agency<T extends User$AgencyArgs<ExtArgs> = {}>(args?: Subset<T, User$AgencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Permissions<T extends User$PermissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$PermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Tickets<T extends User$TicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$TicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notification<T extends User$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'Role'>
    readonly agencyId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.Agency
   */
  export type User$AgencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * User.Permissions
   */
  export type User$PermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    where?: PermissionsWhereInput
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    cursor?: PermissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * User.Tickets
   */
  export type User$TicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    where?: TicketsWhereInput
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    cursor?: TicketsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * User.Notification
   */
  export type User$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Agency
   */

  export type AggregateAgency = {
    _count: AgencyCountAggregateOutputType | null
    _avg: AgencyAvgAggregateOutputType | null
    _sum: AgencySumAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  export type AgencyAvgAggregateOutputType = {
    goal: number | null
  }

  export type AgencySumAggregateOutputType = {
    goal: number | null
  }

  export type AgencyMinAggregateOutputType = {
    id: string | null
    connectAccountId: string | null
    customerId: string | null
    name: string | null
    agencyLogo: string | null
    companyEmail: string | null
    companyPhone: string | null
    whiteLabel: boolean | null
    address: string | null
    city: string | null
    zipCode: string | null
    state: string | null
    country: string | null
    goal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyMaxAggregateOutputType = {
    id: string | null
    connectAccountId: string | null
    customerId: string | null
    name: string | null
    agencyLogo: string | null
    companyEmail: string | null
    companyPhone: string | null
    whiteLabel: boolean | null
    address: string | null
    city: string | null
    zipCode: string | null
    state: string | null
    country: string | null
    goal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyCountAggregateOutputType = {
    id: number
    connectAccountId: number
    customerId: number
    name: number
    agencyLogo: number
    companyEmail: number
    companyPhone: number
    whiteLabel: number
    address: number
    city: number
    zipCode: number
    state: number
    country: number
    goal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyAvgAggregateInputType = {
    goal?: true
  }

  export type AgencySumAggregateInputType = {
    goal?: true
  }

  export type AgencyMinAggregateInputType = {
    id?: true
    connectAccountId?: true
    customerId?: true
    name?: true
    agencyLogo?: true
    companyEmail?: true
    companyPhone?: true
    whiteLabel?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    goal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyMaxAggregateInputType = {
    id?: true
    connectAccountId?: true
    customerId?: true
    name?: true
    agencyLogo?: true
    companyEmail?: true
    companyPhone?: true
    whiteLabel?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    goal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyCountAggregateInputType = {
    id?: true
    connectAccountId?: true
    customerId?: true
    name?: true
    agencyLogo?: true
    companyEmail?: true
    companyPhone?: true
    whiteLabel?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    goal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agency to aggregate.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agencies
    **/
    _count?: true | AgencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyMaxAggregateInputType
  }

  export type GetAgencyAggregateType<T extends AgencyAggregateArgs> = {
        [P in keyof T & keyof AggregateAgency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgency[P]>
      : GetScalarType<T[P], AggregateAgency[P]>
  }




  export type AgencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyWhereInput
    orderBy?: AgencyOrderByWithAggregationInput | AgencyOrderByWithAggregationInput[]
    by: AgencyScalarFieldEnum[] | AgencyScalarFieldEnum
    having?: AgencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyCountAggregateInputType | true
    _avg?: AgencyAvgAggregateInputType
    _sum?: AgencySumAggregateInputType
    _min?: AgencyMinAggregateInputType
    _max?: AgencyMaxAggregateInputType
  }

  export type AgencyGroupByOutputType = {
    id: string
    connectAccountId: string | null
    customerId: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt: Date
    updatedAt: Date
    _count: AgencyCountAggregateOutputType | null
    _avg: AgencyAvgAggregateOutputType | null
    _sum: AgencySumAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  type GetAgencyGroupByPayload<T extends AgencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyGroupByOutputType[P]>
        }
      >
    >


  export type AgencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connectAccountId?: boolean
    customerId?: boolean
    name?: boolean
    agencyLogo?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    whiteLabel?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    goal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Agency$usersArgs<ExtArgs>
    SubAccount?: boolean | Agency$SubAccountArgs<ExtArgs>
    SidebarOption?: boolean | Agency$SidebarOptionArgs<ExtArgs>
    Invitation?: boolean | Agency$InvitationArgs<ExtArgs>
    Notification?: boolean | Agency$NotificationArgs<ExtArgs>
    Subscription?: boolean | Agency$SubscriptionArgs<ExtArgs>
    AddOns?: boolean | Agency$AddOnsArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>



  export type AgencySelectScalar = {
    id?: boolean
    connectAccountId?: boolean
    customerId?: boolean
    name?: boolean
    agencyLogo?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    whiteLabel?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    goal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "connectAccountId" | "customerId" | "name" | "agencyLogo" | "companyEmail" | "companyPhone" | "whiteLabel" | "address" | "city" | "zipCode" | "state" | "country" | "goal" | "createdAt" | "updatedAt", ExtArgs["result"]["agency"]>
  export type AgencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Agency$usersArgs<ExtArgs>
    SubAccount?: boolean | Agency$SubAccountArgs<ExtArgs>
    SidebarOption?: boolean | Agency$SidebarOptionArgs<ExtArgs>
    Invitation?: boolean | Agency$InvitationArgs<ExtArgs>
    Notification?: boolean | Agency$NotificationArgs<ExtArgs>
    Subscription?: boolean | Agency$SubscriptionArgs<ExtArgs>
    AddOns?: boolean | Agency$AddOnsArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AgencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agency"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      SubAccount: Prisma.$SubAccountPayload<ExtArgs>[]
      SidebarOption: Prisma.$AgencySidebarOptionPayload<ExtArgs>[]
      Invitation: Prisma.$InvitationPayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
      Subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      AddOns: Prisma.$AddOnsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      connectAccountId: string | null
      customerId: string | null
      name: string
      agencyLogo: string
      companyEmail: string
      companyPhone: string
      whiteLabel: boolean
      address: string
      city: string
      zipCode: string
      state: string
      country: string
      goal: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agency"]>
    composites: {}
  }

  type AgencyGetPayload<S extends boolean | null | undefined | AgencyDefaultArgs> = $Result.GetResult<Prisma.$AgencyPayload, S>

  type AgencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgencyCountAggregateInputType | true
    }

  export interface AgencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agency'], meta: { name: 'Agency' } }
    /**
     * Find zero or one Agency that matches the filter.
     * @param {AgencyFindUniqueArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyFindUniqueArgs>(args: SelectSubset<T, AgencyFindUniqueArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyFindUniqueOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyFindFirstArgs>(args?: SelectSubset<T, AgencyFindFirstArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agencies
     * const agencies = await prisma.agency.findMany()
     * 
     * // Get first 10 Agencies
     * const agencies = await prisma.agency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyWithIdOnly = await prisma.agency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyFindManyArgs>(args?: SelectSubset<T, AgencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agency.
     * @param {AgencyCreateArgs} args - Arguments to create a Agency.
     * @example
     * // Create one Agency
     * const Agency = await prisma.agency.create({
     *   data: {
     *     // ... data to create a Agency
     *   }
     * })
     * 
     */
    create<T extends AgencyCreateArgs>(args: SelectSubset<T, AgencyCreateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agencies.
     * @param {AgencyCreateManyArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyCreateManyArgs>(args?: SelectSubset<T, AgencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Agency.
     * @param {AgencyDeleteArgs} args - Arguments to delete one Agency.
     * @example
     * // Delete one Agency
     * const Agency = await prisma.agency.delete({
     *   where: {
     *     // ... filter to delete one Agency
     *   }
     * })
     * 
     */
    delete<T extends AgencyDeleteArgs>(args: SelectSubset<T, AgencyDeleteArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agency.
     * @param {AgencyUpdateArgs} args - Arguments to update one Agency.
     * @example
     * // Update one Agency
     * const agency = await prisma.agency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyUpdateArgs>(args: SelectSubset<T, AgencyUpdateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agencies.
     * @param {AgencyDeleteManyArgs} args - Arguments to filter Agencies to delete.
     * @example
     * // Delete a few Agencies
     * const { count } = await prisma.agency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyDeleteManyArgs>(args?: SelectSubset<T, AgencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyUpdateManyArgs>(args: SelectSubset<T, AgencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agency.
     * @param {AgencyUpsertArgs} args - Arguments to update or create a Agency.
     * @example
     * // Update or create a Agency
     * const agency = await prisma.agency.upsert({
     *   create: {
     *     // ... data to create a Agency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agency we want to update
     *   }
     * })
     */
    upsert<T extends AgencyUpsertArgs>(args: SelectSubset<T, AgencyUpsertArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyCountArgs} args - Arguments to filter Agencies to count.
     * @example
     * // Count the number of Agencies
     * const count = await prisma.agency.count({
     *   where: {
     *     // ... the filter for the Agencies we want to count
     *   }
     * })
    **/
    count<T extends AgencyCountArgs>(
      args?: Subset<T, AgencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyAggregateArgs>(args: Subset<T, AgencyAggregateArgs>): Prisma.PrismaPromise<GetAgencyAggregateType<T>>

    /**
     * Group by Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyGroupByArgs['orderBy'] }
        : { orderBy?: AgencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agency model
   */
  readonly fields: AgencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Agency$usersArgs<ExtArgs> = {}>(args?: Subset<T, Agency$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SubAccount<T extends Agency$SubAccountArgs<ExtArgs> = {}>(args?: Subset<T, Agency$SubAccountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SidebarOption<T extends Agency$SidebarOptionArgs<ExtArgs> = {}>(args?: Subset<T, Agency$SidebarOptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Invitation<T extends Agency$InvitationArgs<ExtArgs> = {}>(args?: Subset<T, Agency$InvitationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notification<T extends Agency$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, Agency$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Subscription<T extends Agency$SubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Agency$SubscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    AddOns<T extends Agency$AddOnsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$AddOnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agency model
   */
  interface AgencyFieldRefs {
    readonly id: FieldRef<"Agency", 'String'>
    readonly connectAccountId: FieldRef<"Agency", 'String'>
    readonly customerId: FieldRef<"Agency", 'String'>
    readonly name: FieldRef<"Agency", 'String'>
    readonly agencyLogo: FieldRef<"Agency", 'String'>
    readonly companyEmail: FieldRef<"Agency", 'String'>
    readonly companyPhone: FieldRef<"Agency", 'String'>
    readonly whiteLabel: FieldRef<"Agency", 'Boolean'>
    readonly address: FieldRef<"Agency", 'String'>
    readonly city: FieldRef<"Agency", 'String'>
    readonly zipCode: FieldRef<"Agency", 'String'>
    readonly state: FieldRef<"Agency", 'String'>
    readonly country: FieldRef<"Agency", 'String'>
    readonly goal: FieldRef<"Agency", 'Int'>
    readonly createdAt: FieldRef<"Agency", 'DateTime'>
    readonly updatedAt: FieldRef<"Agency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agency findUnique
   */
  export type AgencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findUniqueOrThrow
   */
  export type AgencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findFirst
   */
  export type AgencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findFirstOrThrow
   */
  export type AgencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findMany
   */
  export type AgencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agencies to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency create
   */
  export type AgencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Agency.
     */
    data: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
  }

  /**
   * Agency createMany
   */
  export type AgencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agency update
   */
  export type AgencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Agency.
     */
    data: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
    /**
     * Choose, which Agency to update.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency updateMany
   */
  export type AgencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to update.
     */
    limit?: number
  }

  /**
   * Agency upsert
   */
  export type AgencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Agency to update in case it exists.
     */
    where: AgencyWhereUniqueInput
    /**
     * In case the Agency found by the `where` argument doesn't exist, create a new Agency with this data.
     */
    create: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
    /**
     * In case the Agency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
  }

  /**
   * Agency delete
   */
  export type AgencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter which Agency to delete.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency deleteMany
   */
  export type AgencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agencies to delete
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to delete.
     */
    limit?: number
  }

  /**
   * Agency.users
   */
  export type Agency$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Agency.SubAccount
   */
  export type Agency$SubAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    where?: SubAccountWhereInput
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    cursor?: SubAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * Agency.SidebarOption
   */
  export type Agency$SidebarOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    where?: AgencySidebarOptionWhereInput
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    cursor?: AgencySidebarOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencySidebarOptionScalarFieldEnum | AgencySidebarOptionScalarFieldEnum[]
  }

  /**
   * Agency.Invitation
   */
  export type Agency$InvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Agency.Notification
   */
  export type Agency$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Agency.Subscription
   */
  export type Agency$SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Agency.AddOns
   */
  export type Agency$AddOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    where?: AddOnsWhereInput
    orderBy?: AddOnsOrderByWithRelationInput | AddOnsOrderByWithRelationInput[]
    cursor?: AddOnsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddOnsScalarFieldEnum | AddOnsScalarFieldEnum[]
  }

  /**
   * Agency without action
   */
  export type AgencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
  }


  /**
   * Model Permissions
   */

  export type AggregatePermissions = {
    _count: PermissionsCountAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  export type PermissionsMinAggregateOutputType = {
    id: string | null
    email: string | null
    subAccountId: string | null
    access: boolean | null
  }

  export type PermissionsMaxAggregateOutputType = {
    id: string | null
    email: string | null
    subAccountId: string | null
    access: boolean | null
  }

  export type PermissionsCountAggregateOutputType = {
    id: number
    email: number
    subAccountId: number
    access: number
    _all: number
  }


  export type PermissionsMinAggregateInputType = {
    id?: true
    email?: true
    subAccountId?: true
    access?: true
  }

  export type PermissionsMaxAggregateInputType = {
    id?: true
    email?: true
    subAccountId?: true
    access?: true
  }

  export type PermissionsCountAggregateInputType = {
    id?: true
    email?: true
    subAccountId?: true
    access?: true
    _all?: true
  }

  export type PermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to aggregate.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionsMaxAggregateInputType
  }

  export type GetPermissionsAggregateType<T extends PermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissions[P]>
      : GetScalarType<T[P], AggregatePermissions[P]>
  }




  export type PermissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionsWhereInput
    orderBy?: PermissionsOrderByWithAggregationInput | PermissionsOrderByWithAggregationInput[]
    by: PermissionsScalarFieldEnum[] | PermissionsScalarFieldEnum
    having?: PermissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionsCountAggregateInputType | true
    _min?: PermissionsMinAggregateInputType
    _max?: PermissionsMaxAggregateInputType
  }

  export type PermissionsGroupByOutputType = {
    id: string
    email: string
    subAccountId: string
    access: boolean
    _count: PermissionsCountAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  type GetPermissionsGroupByPayload<T extends PermissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
        }
      >
    >


  export type PermissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    subAccountId?: boolean
    access?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>



  export type PermissionsSelectScalar = {
    id?: boolean
    email?: boolean
    subAccountId?: boolean
    access?: boolean
  }

  export type PermissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "subAccountId" | "access", ExtArgs["result"]["permissions"]>
  export type PermissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    subAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }

  export type $PermissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permissions"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      subAccount: Prisma.$SubAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      subAccountId: string
      access: boolean
    }, ExtArgs["result"]["permissions"]>
    composites: {}
  }

  type PermissionsGetPayload<S extends boolean | null | undefined | PermissionsDefaultArgs> = $Result.GetResult<Prisma.$PermissionsPayload, S>

  type PermissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionsCountAggregateInputType | true
    }

  export interface PermissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permissions'], meta: { name: 'Permissions' } }
    /**
     * Find zero or one Permissions that matches the filter.
     * @param {PermissionsFindUniqueArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionsFindUniqueArgs>(args: SelectSubset<T, PermissionsFindUniqueArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionsFindUniqueOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindFirstArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionsFindFirstArgs>(args?: SelectSubset<T, PermissionsFindFirstArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindFirstOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permissions.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionsWithIdOnly = await prisma.permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionsFindManyArgs>(args?: SelectSubset<T, PermissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permissions.
     * @param {PermissionsCreateArgs} args - Arguments to create a Permissions.
     * @example
     * // Create one Permissions
     * const Permissions = await prisma.permissions.create({
     *   data: {
     *     // ... data to create a Permissions
     *   }
     * })
     * 
     */
    create<T extends PermissionsCreateArgs>(args: SelectSubset<T, PermissionsCreateArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionsCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionsCreateManyArgs>(args?: SelectSubset<T, PermissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permissions.
     * @param {PermissionsDeleteArgs} args - Arguments to delete one Permissions.
     * @example
     * // Delete one Permissions
     * const Permissions = await prisma.permissions.delete({
     *   where: {
     *     // ... filter to delete one Permissions
     *   }
     * })
     * 
     */
    delete<T extends PermissionsDeleteArgs>(args: SelectSubset<T, PermissionsDeleteArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permissions.
     * @param {PermissionsUpdateArgs} args - Arguments to update one Permissions.
     * @example
     * // Update one Permissions
     * const permissions = await prisma.permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionsUpdateArgs>(args: SelectSubset<T, PermissionsUpdateArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionsDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionsDeleteManyArgs>(args?: SelectSubset<T, PermissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionsUpdateManyArgs>(args: SelectSubset<T, PermissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permissions.
     * @param {PermissionsUpsertArgs} args - Arguments to update or create a Permissions.
     * @example
     * // Update or create a Permissions
     * const permissions = await prisma.permissions.upsert({
     *   create: {
     *     // ... data to create a Permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissions we want to update
     *   }
     * })
     */
    upsert<T extends PermissionsUpsertArgs>(args: SelectSubset<T, PermissionsUpsertArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permissions.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionsCountArgs>(
      args?: Subset<T, PermissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionsAggregateArgs>(args: Subset<T, PermissionsAggregateArgs>): Prisma.PrismaPromise<GetPermissionsAggregateType<T>>

    /**
     * Group by Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionsGroupByArgs['orderBy'] }
        : { orderBy?: PermissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permissions model
   */
  readonly fields: PermissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subAccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permissions model
   */
  interface PermissionsFieldRefs {
    readonly id: FieldRef<"Permissions", 'String'>
    readonly email: FieldRef<"Permissions", 'String'>
    readonly subAccountId: FieldRef<"Permissions", 'String'>
    readonly access: FieldRef<"Permissions", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Permissions findUnique
   */
  export type PermissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions findUniqueOrThrow
   */
  export type PermissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions findFirst
   */
  export type PermissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Permissions findFirstOrThrow
   */
  export type PermissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Permissions findMany
   */
  export type PermissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Permissions create
   */
  export type PermissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Permissions.
     */
    data: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
  }

  /**
   * Permissions createMany
   */
  export type PermissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionsCreateManyInput | PermissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permissions update
   */
  export type PermissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Permissions.
     */
    data: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
    /**
     * Choose, which Permissions to update.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions updateMany
   */
  export type PermissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionsWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permissions upsert
   */
  export type PermissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Permissions to update in case it exists.
     */
    where: PermissionsWhereUniqueInput
    /**
     * In case the Permissions found by the `where` argument doesn't exist, create a new Permissions with this data.
     */
    create: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
    /**
     * In case the Permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
  }

  /**
   * Permissions delete
   */
  export type PermissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter which Permissions to delete.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions deleteMany
   */
  export type PermissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionsWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permissions without action
   */
  export type PermissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
  }


  /**
   * Model SubAccount
   */

  export type AggregateSubAccount = {
    _count: SubAccountCountAggregateOutputType | null
    _avg: SubAccountAvgAggregateOutputType | null
    _sum: SubAccountSumAggregateOutputType | null
    _min: SubAccountMinAggregateOutputType | null
    _max: SubAccountMaxAggregateOutputType | null
  }

  export type SubAccountAvgAggregateOutputType = {
    goal: number | null
  }

  export type SubAccountSumAggregateOutputType = {
    goal: number | null
  }

  export type SubAccountMinAggregateOutputType = {
    id: string | null
    connectAccountId: string | null
    name: string | null
    subAccountLogo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyEmail: string | null
    companyPhone: string | null
    goal: number | null
    address: string | null
    city: string | null
    zipCode: string | null
    state: string | null
    country: string | null
    agencyId: string | null
  }

  export type SubAccountMaxAggregateOutputType = {
    id: string | null
    connectAccountId: string | null
    name: string | null
    subAccountLogo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyEmail: string | null
    companyPhone: string | null
    goal: number | null
    address: string | null
    city: string | null
    zipCode: string | null
    state: string | null
    country: string | null
    agencyId: string | null
  }

  export type SubAccountCountAggregateOutputType = {
    id: number
    connectAccountId: number
    name: number
    subAccountLogo: number
    createdAt: number
    updatedAt: number
    companyEmail: number
    companyPhone: number
    goal: number
    address: number
    city: number
    zipCode: number
    state: number
    country: number
    agencyId: number
    _all: number
  }


  export type SubAccountAvgAggregateInputType = {
    goal?: true
  }

  export type SubAccountSumAggregateInputType = {
    goal?: true
  }

  export type SubAccountMinAggregateInputType = {
    id?: true
    connectAccountId?: true
    name?: true
    subAccountLogo?: true
    createdAt?: true
    updatedAt?: true
    companyEmail?: true
    companyPhone?: true
    goal?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    agencyId?: true
  }

  export type SubAccountMaxAggregateInputType = {
    id?: true
    connectAccountId?: true
    name?: true
    subAccountLogo?: true
    createdAt?: true
    updatedAt?: true
    companyEmail?: true
    companyPhone?: true
    goal?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    agencyId?: true
  }

  export type SubAccountCountAggregateInputType = {
    id?: true
    connectAccountId?: true
    name?: true
    subAccountLogo?: true
    createdAt?: true
    updatedAt?: true
    companyEmail?: true
    companyPhone?: true
    goal?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    agencyId?: true
    _all?: true
  }

  export type SubAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccount to aggregate.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubAccounts
    **/
    _count?: true | SubAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubAccountMaxAggregateInputType
  }

  export type GetSubAccountAggregateType<T extends SubAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateSubAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubAccount[P]>
      : GetScalarType<T[P], AggregateSubAccount[P]>
  }




  export type SubAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountWhereInput
    orderBy?: SubAccountOrderByWithAggregationInput | SubAccountOrderByWithAggregationInput[]
    by: SubAccountScalarFieldEnum[] | SubAccountScalarFieldEnum
    having?: SubAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubAccountCountAggregateInputType | true
    _avg?: SubAccountAvgAggregateInputType
    _sum?: SubAccountSumAggregateInputType
    _min?: SubAccountMinAggregateInputType
    _max?: SubAccountMaxAggregateInputType
  }

  export type SubAccountGroupByOutputType = {
    id: string
    connectAccountId: string | null
    name: string
    subAccountLogo: string
    createdAt: Date
    updatedAt: Date
    companyEmail: string
    companyPhone: string
    goal: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    _count: SubAccountCountAggregateOutputType | null
    _avg: SubAccountAvgAggregateOutputType | null
    _sum: SubAccountSumAggregateOutputType | null
    _min: SubAccountMinAggregateOutputType | null
    _max: SubAccountMaxAggregateOutputType | null
  }

  type GetSubAccountGroupByPayload<T extends SubAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubAccountGroupByOutputType[P]>
            : GetScalarType<T[P], SubAccountGroupByOutputType[P]>
        }
      >
    >


  export type SubAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connectAccountId?: boolean
    name?: boolean
    subAccountLogo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    goal?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    agencyId?: boolean
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SidebarOption?: boolean | SubAccount$SidebarOptionArgs<ExtArgs>
    Permissions?: boolean | SubAccount$PermissionsArgs<ExtArgs>
    Funnels?: boolean | SubAccount$FunnelsArgs<ExtArgs>
    Media?: boolean | SubAccount$MediaArgs<ExtArgs>
    Contact?: boolean | SubAccount$ContactArgs<ExtArgs>
    Trigger?: boolean | SubAccount$TriggerArgs<ExtArgs>
    Automation?: boolean | SubAccount$AutomationArgs<ExtArgs>
    Pipeline?: boolean | SubAccount$PipelineArgs<ExtArgs>
    Tags?: boolean | SubAccount$TagsArgs<ExtArgs>
    Notification?: boolean | SubAccount$NotificationArgs<ExtArgs>
    _count?: boolean | SubAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subAccount"]>



  export type SubAccountSelectScalar = {
    id?: boolean
    connectAccountId?: boolean
    name?: boolean
    subAccountLogo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    goal?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    agencyId?: boolean
  }

  export type SubAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "connectAccountId" | "name" | "subAccountLogo" | "createdAt" | "updatedAt" | "companyEmail" | "companyPhone" | "goal" | "address" | "city" | "zipCode" | "state" | "country" | "agencyId", ExtArgs["result"]["subAccount"]>
  export type SubAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SidebarOption?: boolean | SubAccount$SidebarOptionArgs<ExtArgs>
    Permissions?: boolean | SubAccount$PermissionsArgs<ExtArgs>
    Funnels?: boolean | SubAccount$FunnelsArgs<ExtArgs>
    Media?: boolean | SubAccount$MediaArgs<ExtArgs>
    Contact?: boolean | SubAccount$ContactArgs<ExtArgs>
    Trigger?: boolean | SubAccount$TriggerArgs<ExtArgs>
    Automation?: boolean | SubAccount$AutomationArgs<ExtArgs>
    Pipeline?: boolean | SubAccount$PipelineArgs<ExtArgs>
    Tags?: boolean | SubAccount$TagsArgs<ExtArgs>
    Notification?: boolean | SubAccount$NotificationArgs<ExtArgs>
    _count?: boolean | SubAccountCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SubAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubAccount"
    objects: {
      Agency: Prisma.$AgencyPayload<ExtArgs>
      SidebarOption: Prisma.$SubAccountSidebarOptionPayload<ExtArgs>[]
      Permissions: Prisma.$PermissionsPayload<ExtArgs>[]
      Funnels: Prisma.$FunnelsPayload<ExtArgs>[]
      Media: Prisma.$MediaPayload<ExtArgs>[]
      Contact: Prisma.$ContactPayload<ExtArgs>[]
      Trigger: Prisma.$TriggerPayload<ExtArgs>[]
      Automation: Prisma.$AutomationPayload<ExtArgs>[]
      Pipeline: Prisma.$PipelinePayload<ExtArgs>[]
      Tags: Prisma.$TagsPayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      connectAccountId: string | null
      name: string
      subAccountLogo: string
      createdAt: Date
      updatedAt: Date
      companyEmail: string
      companyPhone: string
      goal: number
      address: string
      city: string
      zipCode: string
      state: string
      country: string
      agencyId: string
    }, ExtArgs["result"]["subAccount"]>
    composites: {}
  }

  type SubAccountGetPayload<S extends boolean | null | undefined | SubAccountDefaultArgs> = $Result.GetResult<Prisma.$SubAccountPayload, S>

  type SubAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubAccountCountAggregateInputType | true
    }

  export interface SubAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubAccount'], meta: { name: 'SubAccount' } }
    /**
     * Find zero or one SubAccount that matches the filter.
     * @param {SubAccountFindUniqueArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubAccountFindUniqueArgs>(args: SelectSubset<T, SubAccountFindUniqueArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubAccountFindUniqueOrThrowArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, SubAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountFindFirstArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubAccountFindFirstArgs>(args?: SelectSubset<T, SubAccountFindFirstArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountFindFirstOrThrowArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, SubAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubAccounts
     * const subAccounts = await prisma.subAccount.findMany()
     * 
     * // Get first 10 SubAccounts
     * const subAccounts = await prisma.subAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subAccountWithIdOnly = await prisma.subAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubAccountFindManyArgs>(args?: SelectSubset<T, SubAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubAccount.
     * @param {SubAccountCreateArgs} args - Arguments to create a SubAccount.
     * @example
     * // Create one SubAccount
     * const SubAccount = await prisma.subAccount.create({
     *   data: {
     *     // ... data to create a SubAccount
     *   }
     * })
     * 
     */
    create<T extends SubAccountCreateArgs>(args: SelectSubset<T, SubAccountCreateArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubAccounts.
     * @param {SubAccountCreateManyArgs} args - Arguments to create many SubAccounts.
     * @example
     * // Create many SubAccounts
     * const subAccount = await prisma.subAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubAccountCreateManyArgs>(args?: SelectSubset<T, SubAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubAccount.
     * @param {SubAccountDeleteArgs} args - Arguments to delete one SubAccount.
     * @example
     * // Delete one SubAccount
     * const SubAccount = await prisma.subAccount.delete({
     *   where: {
     *     // ... filter to delete one SubAccount
     *   }
     * })
     * 
     */
    delete<T extends SubAccountDeleteArgs>(args: SelectSubset<T, SubAccountDeleteArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubAccount.
     * @param {SubAccountUpdateArgs} args - Arguments to update one SubAccount.
     * @example
     * // Update one SubAccount
     * const subAccount = await prisma.subAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubAccountUpdateArgs>(args: SelectSubset<T, SubAccountUpdateArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubAccounts.
     * @param {SubAccountDeleteManyArgs} args - Arguments to filter SubAccounts to delete.
     * @example
     * // Delete a few SubAccounts
     * const { count } = await prisma.subAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubAccountDeleteManyArgs>(args?: SelectSubset<T, SubAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubAccounts
     * const subAccount = await prisma.subAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubAccountUpdateManyArgs>(args: SelectSubset<T, SubAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubAccount.
     * @param {SubAccountUpsertArgs} args - Arguments to update or create a SubAccount.
     * @example
     * // Update or create a SubAccount
     * const subAccount = await prisma.subAccount.upsert({
     *   create: {
     *     // ... data to create a SubAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubAccount we want to update
     *   }
     * })
     */
    upsert<T extends SubAccountUpsertArgs>(args: SelectSubset<T, SubAccountUpsertArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountCountArgs} args - Arguments to filter SubAccounts to count.
     * @example
     * // Count the number of SubAccounts
     * const count = await prisma.subAccount.count({
     *   where: {
     *     // ... the filter for the SubAccounts we want to count
     *   }
     * })
    **/
    count<T extends SubAccountCountArgs>(
      args?: Subset<T, SubAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubAccountAggregateArgs>(args: Subset<T, SubAccountAggregateArgs>): Prisma.PrismaPromise<GetSubAccountAggregateType<T>>

    /**
     * Group by SubAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubAccountGroupByArgs['orderBy'] }
        : { orderBy?: SubAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubAccount model
   */
  readonly fields: SubAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    SidebarOption<T extends SubAccount$SidebarOptionArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$SidebarOptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Permissions<T extends SubAccount$PermissionsArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$PermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Funnels<T extends SubAccount$FunnelsArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$FunnelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Media<T extends SubAccount$MediaArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$MediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Contact<T extends SubAccount$ContactArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$ContactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Trigger<T extends SubAccount$TriggerArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$TriggerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Automation<T extends SubAccount$AutomationArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$AutomationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Pipeline<T extends SubAccount$PipelineArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$PipelineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Tags<T extends SubAccount$TagsArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$TagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notification<T extends SubAccount$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, SubAccount$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubAccount model
   */
  interface SubAccountFieldRefs {
    readonly id: FieldRef<"SubAccount", 'String'>
    readonly connectAccountId: FieldRef<"SubAccount", 'String'>
    readonly name: FieldRef<"SubAccount", 'String'>
    readonly subAccountLogo: FieldRef<"SubAccount", 'String'>
    readonly createdAt: FieldRef<"SubAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"SubAccount", 'DateTime'>
    readonly companyEmail: FieldRef<"SubAccount", 'String'>
    readonly companyPhone: FieldRef<"SubAccount", 'String'>
    readonly goal: FieldRef<"SubAccount", 'Int'>
    readonly address: FieldRef<"SubAccount", 'String'>
    readonly city: FieldRef<"SubAccount", 'String'>
    readonly zipCode: FieldRef<"SubAccount", 'String'>
    readonly state: FieldRef<"SubAccount", 'String'>
    readonly country: FieldRef<"SubAccount", 'String'>
    readonly agencyId: FieldRef<"SubAccount", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubAccount findUnique
   */
  export type SubAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount findUniqueOrThrow
   */
  export type SubAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount findFirst
   */
  export type SubAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccounts.
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccounts.
     */
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * SubAccount findFirstOrThrow
   */
  export type SubAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccounts.
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccounts.
     */
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * SubAccount findMany
   */
  export type SubAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccounts to fetch.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubAccounts.
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * SubAccount create
   */
  export type SubAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a SubAccount.
     */
    data: XOR<SubAccountCreateInput, SubAccountUncheckedCreateInput>
  }

  /**
   * SubAccount createMany
   */
  export type SubAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubAccounts.
     */
    data: SubAccountCreateManyInput | SubAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubAccount update
   */
  export type SubAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a SubAccount.
     */
    data: XOR<SubAccountUpdateInput, SubAccountUncheckedUpdateInput>
    /**
     * Choose, which SubAccount to update.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount updateMany
   */
  export type SubAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubAccounts.
     */
    data: XOR<SubAccountUpdateManyMutationInput, SubAccountUncheckedUpdateManyInput>
    /**
     * Filter which SubAccounts to update
     */
    where?: SubAccountWhereInput
    /**
     * Limit how many SubAccounts to update.
     */
    limit?: number
  }

  /**
   * SubAccount upsert
   */
  export type SubAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the SubAccount to update in case it exists.
     */
    where: SubAccountWhereUniqueInput
    /**
     * In case the SubAccount found by the `where` argument doesn't exist, create a new SubAccount with this data.
     */
    create: XOR<SubAccountCreateInput, SubAccountUncheckedCreateInput>
    /**
     * In case the SubAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubAccountUpdateInput, SubAccountUncheckedUpdateInput>
  }

  /**
   * SubAccount delete
   */
  export type SubAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter which SubAccount to delete.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount deleteMany
   */
  export type SubAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccounts to delete
     */
    where?: SubAccountWhereInput
    /**
     * Limit how many SubAccounts to delete.
     */
    limit?: number
  }

  /**
   * SubAccount.SidebarOption
   */
  export type SubAccount$SidebarOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    where?: SubAccountSidebarOptionWhereInput
    orderBy?: SubAccountSidebarOptionOrderByWithRelationInput | SubAccountSidebarOptionOrderByWithRelationInput[]
    cursor?: SubAccountSidebarOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubAccountSidebarOptionScalarFieldEnum | SubAccountSidebarOptionScalarFieldEnum[]
  }

  /**
   * SubAccount.Permissions
   */
  export type SubAccount$PermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    where?: PermissionsWhereInput
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    cursor?: PermissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * SubAccount.Funnels
   */
  export type SubAccount$FunnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    where?: FunnelsWhereInput
    orderBy?: FunnelsOrderByWithRelationInput | FunnelsOrderByWithRelationInput[]
    cursor?: FunnelsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FunnelsScalarFieldEnum | FunnelsScalarFieldEnum[]
  }

  /**
   * SubAccount.Media
   */
  export type SubAccount$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * SubAccount.Contact
   */
  export type SubAccount$ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * SubAccount.Trigger
   */
  export type SubAccount$TriggerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    where?: TriggerWhereInput
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    cursor?: TriggerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TriggerScalarFieldEnum | TriggerScalarFieldEnum[]
  }

  /**
   * SubAccount.Automation
   */
  export type SubAccount$AutomationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    where?: AutomationWhereInput
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    cursor?: AutomationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * SubAccount.Pipeline
   */
  export type SubAccount$PipelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    where?: PipelineWhereInput
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    cursor?: PipelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * SubAccount.Tags
   */
  export type SubAccount$TagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    where?: TagsWhereInput
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    cursor?: TagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * SubAccount.Notification
   */
  export type SubAccount$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * SubAccount without action
   */
  export type SubAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
  }


  /**
   * Model Tags
   */

  export type AggregateTags = {
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  export type TagsMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
    ticketsId: string | null
  }

  export type TagsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
    ticketsId: string | null
  }

  export type TagsCountAggregateOutputType = {
    id: number
    name: number
    color: number
    createdAt: number
    updatedAt: number
    subAccountId: number
    ticketsId: number
    _all: number
  }


  export type TagsMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
    ticketsId?: true
  }

  export type TagsMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
    ticketsId?: true
  }

  export type TagsCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
    ticketsId?: true
    _all?: true
  }

  export type TagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to aggregate.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsMaxAggregateInputType
  }

  export type GetTagsAggregateType<T extends TagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTags[P]>
      : GetScalarType<T[P], AggregateTags[P]>
  }




  export type TagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsWhereInput
    orderBy?: TagsOrderByWithAggregationInput | TagsOrderByWithAggregationInput[]
    by: TagsScalarFieldEnum[] | TagsScalarFieldEnum
    having?: TagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsCountAggregateInputType | true
    _min?: TagsMinAggregateInputType
    _max?: TagsMaxAggregateInputType
  }

  export type TagsGroupByOutputType = {
    id: string
    name: string
    color: string
    createdAt: Date
    updatedAt: Date
    subAccountId: string
    ticketsId: string | null
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  type GetTagsGroupByPayload<T extends TagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsGroupByOutputType[P]>
        }
      >
    >


  export type TagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    ticketsId?: boolean
    SubAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    Tickets?: boolean | Tags$TicketsArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>



  export type TagsSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    ticketsId?: boolean
  }

  export type TagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "createdAt" | "updatedAt" | "subAccountId" | "ticketsId", ExtArgs["result"]["tags"]>
  export type TagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    Tickets?: boolean | Tags$TicketsArgs<ExtArgs>
  }

  export type $TagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tags"
    objects: {
      SubAccount: Prisma.$SubAccountPayload<ExtArgs>
      Tickets: Prisma.$TicketsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string
      createdAt: Date
      updatedAt: Date
      subAccountId: string
      ticketsId: string | null
    }, ExtArgs["result"]["tags"]>
    composites: {}
  }

  type TagsGetPayload<S extends boolean | null | undefined | TagsDefaultArgs> = $Result.GetResult<Prisma.$TagsPayload, S>

  type TagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagsCountAggregateInputType | true
    }

  export interface TagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tags'], meta: { name: 'Tags' } }
    /**
     * Find zero or one Tags that matches the filter.
     * @param {TagsFindUniqueArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagsFindUniqueArgs>(args: SelectSubset<T, TagsFindUniqueArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagsFindUniqueOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagsFindUniqueOrThrowArgs>(args: SelectSubset<T, TagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagsFindFirstArgs>(args?: SelectSubset<T, TagsFindFirstArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagsFindFirstOrThrowArgs>(args?: SelectSubset<T, TagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tags.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagsWithIdOnly = await prisma.tags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagsFindManyArgs>(args?: SelectSubset<T, TagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tags.
     * @param {TagsCreateArgs} args - Arguments to create a Tags.
     * @example
     * // Create one Tags
     * const Tags = await prisma.tags.create({
     *   data: {
     *     // ... data to create a Tags
     *   }
     * })
     * 
     */
    create<T extends TagsCreateArgs>(args: SelectSubset<T, TagsCreateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagsCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagsCreateManyArgs>(args?: SelectSubset<T, TagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tags.
     * @param {TagsDeleteArgs} args - Arguments to delete one Tags.
     * @example
     * // Delete one Tags
     * const Tags = await prisma.tags.delete({
     *   where: {
     *     // ... filter to delete one Tags
     *   }
     * })
     * 
     */
    delete<T extends TagsDeleteArgs>(args: SelectSubset<T, TagsDeleteArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tags.
     * @param {TagsUpdateArgs} args - Arguments to update one Tags.
     * @example
     * // Update one Tags
     * const tags = await prisma.tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagsUpdateArgs>(args: SelectSubset<T, TagsUpdateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagsDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagsDeleteManyArgs>(args?: SelectSubset<T, TagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagsUpdateManyArgs>(args: SelectSubset<T, TagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tags.
     * @param {TagsUpsertArgs} args - Arguments to update or create a Tags.
     * @example
     * // Update or create a Tags
     * const tags = await prisma.tags.upsert({
     *   create: {
     *     // ... data to create a Tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tags we want to update
     *   }
     * })
     */
    upsert<T extends TagsUpsertArgs>(args: SelectSubset<T, TagsUpsertArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tags.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagsCountArgs>(
      args?: Subset<T, TagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsAggregateArgs>(args: Subset<T, TagsAggregateArgs>): Prisma.PrismaPromise<GetTagsAggregateType<T>>

    /**
     * Group by Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagsGroupByArgs['orderBy'] }
        : { orderBy?: TagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tags model
   */
  readonly fields: TagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SubAccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Tickets<T extends Tags$TicketsArgs<ExtArgs> = {}>(args?: Subset<T, Tags$TicketsArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tags model
   */
  interface TagsFieldRefs {
    readonly id: FieldRef<"Tags", 'String'>
    readonly name: FieldRef<"Tags", 'String'>
    readonly color: FieldRef<"Tags", 'String'>
    readonly createdAt: FieldRef<"Tags", 'DateTime'>
    readonly updatedAt: FieldRef<"Tags", 'DateTime'>
    readonly subAccountId: FieldRef<"Tags", 'String'>
    readonly ticketsId: FieldRef<"Tags", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tags findUnique
   */
  export type TagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findUniqueOrThrow
   */
  export type TagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findFirst
   */
  export type TagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findFirstOrThrow
   */
  export type TagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findMany
   */
  export type TagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags create
   */
  export type TagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The data needed to create a Tags.
     */
    data: XOR<TagsCreateInput, TagsUncheckedCreateInput>
  }

  /**
   * Tags createMany
   */
  export type TagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagsCreateManyInput | TagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tags update
   */
  export type TagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The data needed to update a Tags.
     */
    data: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
    /**
     * Choose, which Tags to update.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags updateMany
   */
  export type TagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tags upsert
   */
  export type TagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The filter to search for the Tags to update in case it exists.
     */
    where: TagsWhereUniqueInput
    /**
     * In case the Tags found by the `where` argument doesn't exist, create a new Tags with this data.
     */
    create: XOR<TagsCreateInput, TagsUncheckedCreateInput>
    /**
     * In case the Tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
  }

  /**
   * Tags delete
   */
  export type TagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter which Tags to delete.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags deleteMany
   */
  export type TagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tags.Tickets
   */
  export type Tags$TicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    where?: TicketsWhereInput
  }

  /**
   * Tags without action
   */
  export type TagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
  }


  /**
   * Model Pipeline
   */

  export type AggregatePipeline = {
    _count: PipelineCountAggregateOutputType | null
    _min: PipelineMinAggregateOutputType | null
    _max: PipelineMaxAggregateOutputType | null
  }

  export type PipelineMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type PipelineMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type PipelineCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    subAccountId: number
    _all: number
  }


  export type PipelineMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type PipelineMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type PipelineCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
    _all?: true
  }

  export type PipelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipeline to aggregate.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pipelines
    **/
    _count?: true | PipelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PipelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PipelineMaxAggregateInputType
  }

  export type GetPipelineAggregateType<T extends PipelineAggregateArgs> = {
        [P in keyof T & keyof AggregatePipeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePipeline[P]>
      : GetScalarType<T[P], AggregatePipeline[P]>
  }




  export type PipelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineWhereInput
    orderBy?: PipelineOrderByWithAggregationInput | PipelineOrderByWithAggregationInput[]
    by: PipelineScalarFieldEnum[] | PipelineScalarFieldEnum
    having?: PipelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PipelineCountAggregateInputType | true
    _min?: PipelineMinAggregateInputType
    _max?: PipelineMaxAggregateInputType
  }

  export type PipelineGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    subAccountId: string
    _count: PipelineCountAggregateOutputType | null
    _min: PipelineMinAggregateOutputType | null
    _max: PipelineMaxAggregateOutputType | null
  }

  type GetPipelineGroupByPayload<T extends PipelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PipelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PipelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PipelineGroupByOutputType[P]>
            : GetScalarType<T[P], PipelineGroupByOutputType[P]>
        }
      >
    >


  export type PipelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    Lane?: boolean | Pipeline$LaneArgs<ExtArgs>
    SubAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    _count?: boolean | PipelineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipeline"]>



  export type PipelineSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
  }

  export type PipelineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "subAccountId", ExtArgs["result"]["pipeline"]>
  export type PipelineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lane?: boolean | Pipeline$LaneArgs<ExtArgs>
    SubAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    _count?: boolean | PipelineCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PipelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pipeline"
    objects: {
      Lane: Prisma.$LanePayload<ExtArgs>[]
      SubAccount: Prisma.$SubAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      subAccountId: string
    }, ExtArgs["result"]["pipeline"]>
    composites: {}
  }

  type PipelineGetPayload<S extends boolean | null | undefined | PipelineDefaultArgs> = $Result.GetResult<Prisma.$PipelinePayload, S>

  type PipelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PipelineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PipelineCountAggregateInputType | true
    }

  export interface PipelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pipeline'], meta: { name: 'Pipeline' } }
    /**
     * Find zero or one Pipeline that matches the filter.
     * @param {PipelineFindUniqueArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PipelineFindUniqueArgs>(args: SelectSubset<T, PipelineFindUniqueArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pipeline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PipelineFindUniqueOrThrowArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PipelineFindUniqueOrThrowArgs>(args: SelectSubset<T, PipelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pipeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindFirstArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PipelineFindFirstArgs>(args?: SelectSubset<T, PipelineFindFirstArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pipeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindFirstOrThrowArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PipelineFindFirstOrThrowArgs>(args?: SelectSubset<T, PipelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pipelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pipelines
     * const pipelines = await prisma.pipeline.findMany()
     * 
     * // Get first 10 Pipelines
     * const pipelines = await prisma.pipeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pipelineWithIdOnly = await prisma.pipeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PipelineFindManyArgs>(args?: SelectSubset<T, PipelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pipeline.
     * @param {PipelineCreateArgs} args - Arguments to create a Pipeline.
     * @example
     * // Create one Pipeline
     * const Pipeline = await prisma.pipeline.create({
     *   data: {
     *     // ... data to create a Pipeline
     *   }
     * })
     * 
     */
    create<T extends PipelineCreateArgs>(args: SelectSubset<T, PipelineCreateArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pipelines.
     * @param {PipelineCreateManyArgs} args - Arguments to create many Pipelines.
     * @example
     * // Create many Pipelines
     * const pipeline = await prisma.pipeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PipelineCreateManyArgs>(args?: SelectSubset<T, PipelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pipeline.
     * @param {PipelineDeleteArgs} args - Arguments to delete one Pipeline.
     * @example
     * // Delete one Pipeline
     * const Pipeline = await prisma.pipeline.delete({
     *   where: {
     *     // ... filter to delete one Pipeline
     *   }
     * })
     * 
     */
    delete<T extends PipelineDeleteArgs>(args: SelectSubset<T, PipelineDeleteArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pipeline.
     * @param {PipelineUpdateArgs} args - Arguments to update one Pipeline.
     * @example
     * // Update one Pipeline
     * const pipeline = await prisma.pipeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PipelineUpdateArgs>(args: SelectSubset<T, PipelineUpdateArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pipelines.
     * @param {PipelineDeleteManyArgs} args - Arguments to filter Pipelines to delete.
     * @example
     * // Delete a few Pipelines
     * const { count } = await prisma.pipeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PipelineDeleteManyArgs>(args?: SelectSubset<T, PipelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pipelines
     * const pipeline = await prisma.pipeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PipelineUpdateManyArgs>(args: SelectSubset<T, PipelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pipeline.
     * @param {PipelineUpsertArgs} args - Arguments to update or create a Pipeline.
     * @example
     * // Update or create a Pipeline
     * const pipeline = await prisma.pipeline.upsert({
     *   create: {
     *     // ... data to create a Pipeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pipeline we want to update
     *   }
     * })
     */
    upsert<T extends PipelineUpsertArgs>(args: SelectSubset<T, PipelineUpsertArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineCountArgs} args - Arguments to filter Pipelines to count.
     * @example
     * // Count the number of Pipelines
     * const count = await prisma.pipeline.count({
     *   where: {
     *     // ... the filter for the Pipelines we want to count
     *   }
     * })
    **/
    count<T extends PipelineCountArgs>(
      args?: Subset<T, PipelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PipelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PipelineAggregateArgs>(args: Subset<T, PipelineAggregateArgs>): Prisma.PrismaPromise<GetPipelineAggregateType<T>>

    /**
     * Group by Pipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PipelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PipelineGroupByArgs['orderBy'] }
        : { orderBy?: PipelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PipelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPipelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pipeline model
   */
  readonly fields: PipelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pipeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PipelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lane<T extends Pipeline$LaneArgs<ExtArgs> = {}>(args?: Subset<T, Pipeline$LaneArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SubAccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pipeline model
   */
  interface PipelineFieldRefs {
    readonly id: FieldRef<"Pipeline", 'String'>
    readonly name: FieldRef<"Pipeline", 'String'>
    readonly createdAt: FieldRef<"Pipeline", 'DateTime'>
    readonly updatedAt: FieldRef<"Pipeline", 'DateTime'>
    readonly subAccountId: FieldRef<"Pipeline", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pipeline findUnique
   */
  export type PipelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline findUniqueOrThrow
   */
  export type PipelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline findFirst
   */
  export type PipelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline findFirstOrThrow
   */
  export type PipelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline findMany
   */
  export type PipelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline create
   */
  export type PipelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * The data needed to create a Pipeline.
     */
    data: XOR<PipelineCreateInput, PipelineUncheckedCreateInput>
  }

  /**
   * Pipeline createMany
   */
  export type PipelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pipelines.
     */
    data: PipelineCreateManyInput | PipelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pipeline update
   */
  export type PipelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * The data needed to update a Pipeline.
     */
    data: XOR<PipelineUpdateInput, PipelineUncheckedUpdateInput>
    /**
     * Choose, which Pipeline to update.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline updateMany
   */
  export type PipelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pipelines.
     */
    data: XOR<PipelineUpdateManyMutationInput, PipelineUncheckedUpdateManyInput>
    /**
     * Filter which Pipelines to update
     */
    where?: PipelineWhereInput
    /**
     * Limit how many Pipelines to update.
     */
    limit?: number
  }

  /**
   * Pipeline upsert
   */
  export type PipelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * The filter to search for the Pipeline to update in case it exists.
     */
    where: PipelineWhereUniqueInput
    /**
     * In case the Pipeline found by the `where` argument doesn't exist, create a new Pipeline with this data.
     */
    create: XOR<PipelineCreateInput, PipelineUncheckedCreateInput>
    /**
     * In case the Pipeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PipelineUpdateInput, PipelineUncheckedUpdateInput>
  }

  /**
   * Pipeline delete
   */
  export type PipelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter which Pipeline to delete.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline deleteMany
   */
  export type PipelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipelines to delete
     */
    where?: PipelineWhereInput
    /**
     * Limit how many Pipelines to delete.
     */
    limit?: number
  }

  /**
   * Pipeline.Lane
   */
  export type Pipeline$LaneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    where?: LaneWhereInput
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    cursor?: LaneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaneScalarFieldEnum | LaneScalarFieldEnum[]
  }

  /**
   * Pipeline without action
   */
  export type PipelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
  }


  /**
   * Model Lane
   */

  export type AggregateLane = {
    _count: LaneCountAggregateOutputType | null
    _avg: LaneAvgAggregateOutputType | null
    _sum: LaneSumAggregateOutputType | null
    _min: LaneMinAggregateOutputType | null
    _max: LaneMaxAggregateOutputType | null
  }

  export type LaneAvgAggregateOutputType = {
    order: number | null
  }

  export type LaneSumAggregateOutputType = {
    order: number | null
  }

  export type LaneMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    pipelineId: string | null
    order: number | null
  }

  export type LaneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    pipelineId: string | null
    order: number | null
  }

  export type LaneCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    pipelineId: number
    order: number
    _all: number
  }


  export type LaneAvgAggregateInputType = {
    order?: true
  }

  export type LaneSumAggregateInputType = {
    order?: true
  }

  export type LaneMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    pipelineId?: true
    order?: true
  }

  export type LaneMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    pipelineId?: true
    order?: true
  }

  export type LaneCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    pipelineId?: true
    order?: true
    _all?: true
  }

  export type LaneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lane to aggregate.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lanes
    **/
    _count?: true | LaneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaneMaxAggregateInputType
  }

  export type GetLaneAggregateType<T extends LaneAggregateArgs> = {
        [P in keyof T & keyof AggregateLane]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLane[P]>
      : GetScalarType<T[P], AggregateLane[P]>
  }




  export type LaneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaneWhereInput
    orderBy?: LaneOrderByWithAggregationInput | LaneOrderByWithAggregationInput[]
    by: LaneScalarFieldEnum[] | LaneScalarFieldEnum
    having?: LaneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaneCountAggregateInputType | true
    _avg?: LaneAvgAggregateInputType
    _sum?: LaneSumAggregateInputType
    _min?: LaneMinAggregateInputType
    _max?: LaneMaxAggregateInputType
  }

  export type LaneGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    pipelineId: string
    order: number
    _count: LaneCountAggregateOutputType | null
    _avg: LaneAvgAggregateOutputType | null
    _sum: LaneSumAggregateOutputType | null
    _min: LaneMinAggregateOutputType | null
    _max: LaneMaxAggregateOutputType | null
  }

  type GetLaneGroupByPayload<T extends LaneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaneGroupByOutputType[P]>
            : GetScalarType<T[P], LaneGroupByOutputType[P]>
        }
      >
    >


  export type LaneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pipelineId?: boolean
    order?: boolean
    Pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
    Tickets?: boolean | Lane$TicketsArgs<ExtArgs>
    _count?: boolean | LaneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lane"]>



  export type LaneSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pipelineId?: boolean
    order?: boolean
  }

  export type LaneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "pipelineId" | "order", ExtArgs["result"]["lane"]>
  export type LaneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
    Tickets?: boolean | Lane$TicketsArgs<ExtArgs>
    _count?: boolean | LaneCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LanePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lane"
    objects: {
      Pipeline: Prisma.$PipelinePayload<ExtArgs>
      Tickets: Prisma.$TicketsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      pipelineId: string
      order: number
    }, ExtArgs["result"]["lane"]>
    composites: {}
  }

  type LaneGetPayload<S extends boolean | null | undefined | LaneDefaultArgs> = $Result.GetResult<Prisma.$LanePayload, S>

  type LaneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LaneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LaneCountAggregateInputType | true
    }

  export interface LaneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lane'], meta: { name: 'Lane' } }
    /**
     * Find zero or one Lane that matches the filter.
     * @param {LaneFindUniqueArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LaneFindUniqueArgs>(args: SelectSubset<T, LaneFindUniqueArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lane that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LaneFindUniqueOrThrowArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LaneFindUniqueOrThrowArgs>(args: SelectSubset<T, LaneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lane that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneFindFirstArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LaneFindFirstArgs>(args?: SelectSubset<T, LaneFindFirstArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lane that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneFindFirstOrThrowArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LaneFindFirstOrThrowArgs>(args?: SelectSubset<T, LaneFindFirstOrThrowArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lanes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lanes
     * const lanes = await prisma.lane.findMany()
     * 
     * // Get first 10 Lanes
     * const lanes = await prisma.lane.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laneWithIdOnly = await prisma.lane.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LaneFindManyArgs>(args?: SelectSubset<T, LaneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lane.
     * @param {LaneCreateArgs} args - Arguments to create a Lane.
     * @example
     * // Create one Lane
     * const Lane = await prisma.lane.create({
     *   data: {
     *     // ... data to create a Lane
     *   }
     * })
     * 
     */
    create<T extends LaneCreateArgs>(args: SelectSubset<T, LaneCreateArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lanes.
     * @param {LaneCreateManyArgs} args - Arguments to create many Lanes.
     * @example
     * // Create many Lanes
     * const lane = await prisma.lane.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LaneCreateManyArgs>(args?: SelectSubset<T, LaneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lane.
     * @param {LaneDeleteArgs} args - Arguments to delete one Lane.
     * @example
     * // Delete one Lane
     * const Lane = await prisma.lane.delete({
     *   where: {
     *     // ... filter to delete one Lane
     *   }
     * })
     * 
     */
    delete<T extends LaneDeleteArgs>(args: SelectSubset<T, LaneDeleteArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lane.
     * @param {LaneUpdateArgs} args - Arguments to update one Lane.
     * @example
     * // Update one Lane
     * const lane = await prisma.lane.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LaneUpdateArgs>(args: SelectSubset<T, LaneUpdateArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lanes.
     * @param {LaneDeleteManyArgs} args - Arguments to filter Lanes to delete.
     * @example
     * // Delete a few Lanes
     * const { count } = await prisma.lane.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LaneDeleteManyArgs>(args?: SelectSubset<T, LaneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lanes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lanes
     * const lane = await prisma.lane.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LaneUpdateManyArgs>(args: SelectSubset<T, LaneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lane.
     * @param {LaneUpsertArgs} args - Arguments to update or create a Lane.
     * @example
     * // Update or create a Lane
     * const lane = await prisma.lane.upsert({
     *   create: {
     *     // ... data to create a Lane
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lane we want to update
     *   }
     * })
     */
    upsert<T extends LaneUpsertArgs>(args: SelectSubset<T, LaneUpsertArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lanes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneCountArgs} args - Arguments to filter Lanes to count.
     * @example
     * // Count the number of Lanes
     * const count = await prisma.lane.count({
     *   where: {
     *     // ... the filter for the Lanes we want to count
     *   }
     * })
    **/
    count<T extends LaneCountArgs>(
      args?: Subset<T, LaneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lane.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaneAggregateArgs>(args: Subset<T, LaneAggregateArgs>): Prisma.PrismaPromise<GetLaneAggregateType<T>>

    /**
     * Group by Lane.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaneGroupByArgs['orderBy'] }
        : { orderBy?: LaneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lane model
   */
  readonly fields: LaneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lane.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LaneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Pipeline<T extends PipelineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PipelineDefaultArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Tickets<T extends Lane$TicketsArgs<ExtArgs> = {}>(args?: Subset<T, Lane$TicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lane model
   */
  interface LaneFieldRefs {
    readonly id: FieldRef<"Lane", 'String'>
    readonly name: FieldRef<"Lane", 'String'>
    readonly createdAt: FieldRef<"Lane", 'DateTime'>
    readonly updatedAt: FieldRef<"Lane", 'DateTime'>
    readonly pipelineId: FieldRef<"Lane", 'String'>
    readonly order: FieldRef<"Lane", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Lane findUnique
   */
  export type LaneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane findUniqueOrThrow
   */
  export type LaneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane findFirst
   */
  export type LaneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lanes.
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lanes.
     */
    distinct?: LaneScalarFieldEnum | LaneScalarFieldEnum[]
  }

  /**
   * Lane findFirstOrThrow
   */
  export type LaneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lanes.
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lanes.
     */
    distinct?: LaneScalarFieldEnum | LaneScalarFieldEnum[]
  }

  /**
   * Lane findMany
   */
  export type LaneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lanes to fetch.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lanes.
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    distinct?: LaneScalarFieldEnum | LaneScalarFieldEnum[]
  }

  /**
   * Lane create
   */
  export type LaneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * The data needed to create a Lane.
     */
    data: XOR<LaneCreateInput, LaneUncheckedCreateInput>
  }

  /**
   * Lane createMany
   */
  export type LaneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lanes.
     */
    data: LaneCreateManyInput | LaneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lane update
   */
  export type LaneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * The data needed to update a Lane.
     */
    data: XOR<LaneUpdateInput, LaneUncheckedUpdateInput>
    /**
     * Choose, which Lane to update.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane updateMany
   */
  export type LaneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lanes.
     */
    data: XOR<LaneUpdateManyMutationInput, LaneUncheckedUpdateManyInput>
    /**
     * Filter which Lanes to update
     */
    where?: LaneWhereInput
    /**
     * Limit how many Lanes to update.
     */
    limit?: number
  }

  /**
   * Lane upsert
   */
  export type LaneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * The filter to search for the Lane to update in case it exists.
     */
    where: LaneWhereUniqueInput
    /**
     * In case the Lane found by the `where` argument doesn't exist, create a new Lane with this data.
     */
    create: XOR<LaneCreateInput, LaneUncheckedCreateInput>
    /**
     * In case the Lane was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaneUpdateInput, LaneUncheckedUpdateInput>
  }

  /**
   * Lane delete
   */
  export type LaneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter which Lane to delete.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane deleteMany
   */
  export type LaneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lanes to delete
     */
    where?: LaneWhereInput
    /**
     * Limit how many Lanes to delete.
     */
    limit?: number
  }

  /**
   * Lane.Tickets
   */
  export type Lane$TicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    where?: TicketsWhereInput
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    cursor?: TicketsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * Lane without action
   */
  export type LaneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
  }


  /**
   * Model Tickets
   */

  export type AggregateTickets = {
    _count: TicketsCountAggregateOutputType | null
    _avg: TicketsAvgAggregateOutputType | null
    _sum: TicketsSumAggregateOutputType | null
    _min: TicketsMinAggregateOutputType | null
    _max: TicketsMaxAggregateOutputType | null
  }

  export type TicketsAvgAggregateOutputType = {
    order: number | null
    value: Decimal | null
  }

  export type TicketsSumAggregateOutputType = {
    order: number | null
    value: Decimal | null
  }

  export type TicketsMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    laneId: string | null
    order: number | null
    value: Decimal | null
    description: string | null
    customerId: string | null
    assignedUserId: string | null
  }

  export type TicketsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    laneId: string | null
    order: number | null
    value: Decimal | null
    description: string | null
    customerId: string | null
    assignedUserId: string | null
  }

  export type TicketsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    laneId: number
    order: number
    value: number
    description: number
    customerId: number
    assignedUserId: number
    _all: number
  }


  export type TicketsAvgAggregateInputType = {
    order?: true
    value?: true
  }

  export type TicketsSumAggregateInputType = {
    order?: true
    value?: true
  }

  export type TicketsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    laneId?: true
    order?: true
    value?: true
    description?: true
    customerId?: true
    assignedUserId?: true
  }

  export type TicketsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    laneId?: true
    order?: true
    value?: true
    description?: true
    customerId?: true
    assignedUserId?: true
  }

  export type TicketsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    laneId?: true
    order?: true
    value?: true
    description?: true
    customerId?: true
    assignedUserId?: true
    _all?: true
  }

  export type TicketsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to aggregate.
     */
    where?: TicketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketsMaxAggregateInputType
  }

  export type GetTicketsAggregateType<T extends TicketsAggregateArgs> = {
        [P in keyof T & keyof AggregateTickets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTickets[P]>
      : GetScalarType<T[P], AggregateTickets[P]>
  }




  export type TicketsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketsWhereInput
    orderBy?: TicketsOrderByWithAggregationInput | TicketsOrderByWithAggregationInput[]
    by: TicketsScalarFieldEnum[] | TicketsScalarFieldEnum
    having?: TicketsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketsCountAggregateInputType | true
    _avg?: TicketsAvgAggregateInputType
    _sum?: TicketsSumAggregateInputType
    _min?: TicketsMinAggregateInputType
    _max?: TicketsMaxAggregateInputType
  }

  export type TicketsGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    laneId: string
    order: number
    value: Decimal | null
    description: string | null
    customerId: string | null
    assignedUserId: string | null
    _count: TicketsCountAggregateOutputType | null
    _avg: TicketsAvgAggregateOutputType | null
    _sum: TicketsSumAggregateOutputType | null
    _min: TicketsMinAggregateOutputType | null
    _max: TicketsMaxAggregateOutputType | null
  }

  type GetTicketsGroupByPayload<T extends TicketsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketsGroupByOutputType[P]>
            : GetScalarType<T[P], TicketsGroupByOutputType[P]>
        }
      >
    >


  export type TicketsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laneId?: boolean
    order?: boolean
    value?: boolean
    description?: boolean
    customerId?: boolean
    assignedUserId?: boolean
    Lane?: boolean | LaneDefaultArgs<ExtArgs>
    Tags?: boolean | Tickets$TagsArgs<ExtArgs>
    Customer?: boolean | Tickets$CustomerArgs<ExtArgs>
    Assigned?: boolean | Tickets$AssignedArgs<ExtArgs>
    _count?: boolean | TicketsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tickets"]>



  export type TicketsSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    laneId?: boolean
    order?: boolean
    value?: boolean
    description?: boolean
    customerId?: boolean
    assignedUserId?: boolean
  }

  export type TicketsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "laneId" | "order" | "value" | "description" | "customerId" | "assignedUserId", ExtArgs["result"]["tickets"]>
  export type TicketsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lane?: boolean | LaneDefaultArgs<ExtArgs>
    Tags?: boolean | Tickets$TagsArgs<ExtArgs>
    Customer?: boolean | Tickets$CustomerArgs<ExtArgs>
    Assigned?: boolean | Tickets$AssignedArgs<ExtArgs>
    _count?: boolean | TicketsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TicketsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tickets"
    objects: {
      Lane: Prisma.$LanePayload<ExtArgs>
      Tags: Prisma.$TagsPayload<ExtArgs>[]
      Customer: Prisma.$ContactPayload<ExtArgs> | null
      Assigned: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      laneId: string
      order: number
      value: Prisma.Decimal | null
      description: string | null
      customerId: string | null
      assignedUserId: string | null
    }, ExtArgs["result"]["tickets"]>
    composites: {}
  }

  type TicketsGetPayload<S extends boolean | null | undefined | TicketsDefaultArgs> = $Result.GetResult<Prisma.$TicketsPayload, S>

  type TicketsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketsCountAggregateInputType | true
    }

  export interface TicketsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tickets'], meta: { name: 'Tickets' } }
    /**
     * Find zero or one Tickets that matches the filter.
     * @param {TicketsFindUniqueArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketsFindUniqueArgs>(args: SelectSubset<T, TicketsFindUniqueArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tickets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketsFindUniqueOrThrowArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketsFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsFindFirstArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketsFindFirstArgs>(args?: SelectSubset<T, TicketsFindFirstArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tickets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsFindFirstOrThrowArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketsFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.tickets.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.tickets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketsWithIdOnly = await prisma.tickets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketsFindManyArgs>(args?: SelectSubset<T, TicketsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tickets.
     * @param {TicketsCreateArgs} args - Arguments to create a Tickets.
     * @example
     * // Create one Tickets
     * const Tickets = await prisma.tickets.create({
     *   data: {
     *     // ... data to create a Tickets
     *   }
     * })
     * 
     */
    create<T extends TicketsCreateArgs>(args: SelectSubset<T, TicketsCreateArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketsCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const tickets = await prisma.tickets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketsCreateManyArgs>(args?: SelectSubset<T, TicketsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tickets.
     * @param {TicketsDeleteArgs} args - Arguments to delete one Tickets.
     * @example
     * // Delete one Tickets
     * const Tickets = await prisma.tickets.delete({
     *   where: {
     *     // ... filter to delete one Tickets
     *   }
     * })
     * 
     */
    delete<T extends TicketsDeleteArgs>(args: SelectSubset<T, TicketsDeleteArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tickets.
     * @param {TicketsUpdateArgs} args - Arguments to update one Tickets.
     * @example
     * // Update one Tickets
     * const tickets = await prisma.tickets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketsUpdateArgs>(args: SelectSubset<T, TicketsUpdateArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketsDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.tickets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketsDeleteManyArgs>(args?: SelectSubset<T, TicketsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const tickets = await prisma.tickets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketsUpdateManyArgs>(args: SelectSubset<T, TicketsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tickets.
     * @param {TicketsUpsertArgs} args - Arguments to update or create a Tickets.
     * @example
     * // Update or create a Tickets
     * const tickets = await prisma.tickets.upsert({
     *   create: {
     *     // ... data to create a Tickets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tickets we want to update
     *   }
     * })
     */
    upsert<T extends TicketsUpsertArgs>(args: SelectSubset<T, TicketsUpsertArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.tickets.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketsCountArgs>(
      args?: Subset<T, TicketsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketsAggregateArgs>(args: Subset<T, TicketsAggregateArgs>): Prisma.PrismaPromise<GetTicketsAggregateType<T>>

    /**
     * Group by Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketsGroupByArgs['orderBy'] }
        : { orderBy?: TicketsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tickets model
   */
  readonly fields: TicketsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tickets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lane<T extends LaneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LaneDefaultArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Tags<T extends Tickets$TagsArgs<ExtArgs> = {}>(args?: Subset<T, Tickets$TagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Customer<T extends Tickets$CustomerArgs<ExtArgs> = {}>(args?: Subset<T, Tickets$CustomerArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Assigned<T extends Tickets$AssignedArgs<ExtArgs> = {}>(args?: Subset<T, Tickets$AssignedArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tickets model
   */
  interface TicketsFieldRefs {
    readonly id: FieldRef<"Tickets", 'String'>
    readonly name: FieldRef<"Tickets", 'String'>
    readonly createdAt: FieldRef<"Tickets", 'DateTime'>
    readonly updatedAt: FieldRef<"Tickets", 'DateTime'>
    readonly laneId: FieldRef<"Tickets", 'String'>
    readonly order: FieldRef<"Tickets", 'Int'>
    readonly value: FieldRef<"Tickets", 'Decimal'>
    readonly description: FieldRef<"Tickets", 'String'>
    readonly customerId: FieldRef<"Tickets", 'String'>
    readonly assignedUserId: FieldRef<"Tickets", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tickets findUnique
   */
  export type TicketsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where: TicketsWhereUniqueInput
  }

  /**
   * Tickets findUniqueOrThrow
   */
  export type TicketsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where: TicketsWhereUniqueInput
  }

  /**
   * Tickets findFirst
   */
  export type TicketsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * Tickets findFirstOrThrow
   */
  export type TicketsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * Tickets findMany
   */
  export type TicketsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * Tickets create
   */
  export type TicketsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * The data needed to create a Tickets.
     */
    data: XOR<TicketsCreateInput, TicketsUncheckedCreateInput>
  }

  /**
   * Tickets createMany
   */
  export type TicketsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketsCreateManyInput | TicketsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tickets update
   */
  export type TicketsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * The data needed to update a Tickets.
     */
    data: XOR<TicketsUpdateInput, TicketsUncheckedUpdateInput>
    /**
     * Choose, which Tickets to update.
     */
    where: TicketsWhereUniqueInput
  }

  /**
   * Tickets updateMany
   */
  export type TicketsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketsUpdateManyMutationInput, TicketsUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketsWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Tickets upsert
   */
  export type TicketsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * The filter to search for the Tickets to update in case it exists.
     */
    where: TicketsWhereUniqueInput
    /**
     * In case the Tickets found by the `where` argument doesn't exist, create a new Tickets with this data.
     */
    create: XOR<TicketsCreateInput, TicketsUncheckedCreateInput>
    /**
     * In case the Tickets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketsUpdateInput, TicketsUncheckedUpdateInput>
  }

  /**
   * Tickets delete
   */
  export type TicketsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter which Tickets to delete.
     */
    where: TicketsWhereUniqueInput
  }

  /**
   * Tickets deleteMany
   */
  export type TicketsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketsWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Tickets.Tags
   */
  export type Tickets$TagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    where?: TagsWhereInput
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    cursor?: TagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tickets.Customer
   */
  export type Tickets$CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Tickets.Assigned
   */
  export type Tickets$AssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Tickets without action
   */
  export type TicketsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
  }


  /**
   * Model Trigger
   */

  export type AggregateTrigger = {
    _count: TriggerCountAggregateOutputType | null
    _min: TriggerMinAggregateOutputType | null
    _max: TriggerMaxAggregateOutputType | null
  }

  export type TriggerMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.TriggerTypes | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type TriggerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.TriggerTypes | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type TriggerCountAggregateOutputType = {
    id: number
    name: number
    type: number
    createdAt: number
    updatedAt: number
    subAccountId: number
    _all: number
  }


  export type TriggerMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type TriggerMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type TriggerCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
    _all?: true
  }

  export type TriggerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trigger to aggregate.
     */
    where?: TriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Triggers
    **/
    _count?: true | TriggerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TriggerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TriggerMaxAggregateInputType
  }

  export type GetTriggerAggregateType<T extends TriggerAggregateArgs> = {
        [P in keyof T & keyof AggregateTrigger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrigger[P]>
      : GetScalarType<T[P], AggregateTrigger[P]>
  }




  export type TriggerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriggerWhereInput
    orderBy?: TriggerOrderByWithAggregationInput | TriggerOrderByWithAggregationInput[]
    by: TriggerScalarFieldEnum[] | TriggerScalarFieldEnum
    having?: TriggerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TriggerCountAggregateInputType | true
    _min?: TriggerMinAggregateInputType
    _max?: TriggerMaxAggregateInputType
  }

  export type TriggerGroupByOutputType = {
    id: string
    name: string
    type: $Enums.TriggerTypes
    createdAt: Date
    updatedAt: Date
    subAccountId: string
    _count: TriggerCountAggregateOutputType | null
    _min: TriggerMinAggregateOutputType | null
    _max: TriggerMaxAggregateOutputType | null
  }

  type GetTriggerGroupByPayload<T extends TriggerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TriggerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TriggerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TriggerGroupByOutputType[P]>
            : GetScalarType<T[P], TriggerGroupByOutputType[P]>
        }
      >
    >


  export type TriggerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    SubAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    Automation?: boolean | Trigger$AutomationArgs<ExtArgs>
    _count?: boolean | TriggerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trigger"]>



  export type TriggerSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
  }

  export type TriggerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "createdAt" | "updatedAt" | "subAccountId", ExtArgs["result"]["trigger"]>
  export type TriggerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    Automation?: boolean | Trigger$AutomationArgs<ExtArgs>
    _count?: boolean | TriggerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TriggerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trigger"
    objects: {
      SubAccount: Prisma.$SubAccountPayload<ExtArgs>
      Automation: Prisma.$AutomationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.TriggerTypes
      createdAt: Date
      updatedAt: Date
      subAccountId: string
    }, ExtArgs["result"]["trigger"]>
    composites: {}
  }

  type TriggerGetPayload<S extends boolean | null | undefined | TriggerDefaultArgs> = $Result.GetResult<Prisma.$TriggerPayload, S>

  type TriggerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TriggerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TriggerCountAggregateInputType | true
    }

  export interface TriggerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trigger'], meta: { name: 'Trigger' } }
    /**
     * Find zero or one Trigger that matches the filter.
     * @param {TriggerFindUniqueArgs} args - Arguments to find a Trigger
     * @example
     * // Get one Trigger
     * const trigger = await prisma.trigger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TriggerFindUniqueArgs>(args: SelectSubset<T, TriggerFindUniqueArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trigger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TriggerFindUniqueOrThrowArgs} args - Arguments to find a Trigger
     * @example
     * // Get one Trigger
     * const trigger = await prisma.trigger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TriggerFindUniqueOrThrowArgs>(args: SelectSubset<T, TriggerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trigger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerFindFirstArgs} args - Arguments to find a Trigger
     * @example
     * // Get one Trigger
     * const trigger = await prisma.trigger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TriggerFindFirstArgs>(args?: SelectSubset<T, TriggerFindFirstArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trigger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerFindFirstOrThrowArgs} args - Arguments to find a Trigger
     * @example
     * // Get one Trigger
     * const trigger = await prisma.trigger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TriggerFindFirstOrThrowArgs>(args?: SelectSubset<T, TriggerFindFirstOrThrowArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Triggers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Triggers
     * const triggers = await prisma.trigger.findMany()
     * 
     * // Get first 10 Triggers
     * const triggers = await prisma.trigger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const triggerWithIdOnly = await prisma.trigger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TriggerFindManyArgs>(args?: SelectSubset<T, TriggerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trigger.
     * @param {TriggerCreateArgs} args - Arguments to create a Trigger.
     * @example
     * // Create one Trigger
     * const Trigger = await prisma.trigger.create({
     *   data: {
     *     // ... data to create a Trigger
     *   }
     * })
     * 
     */
    create<T extends TriggerCreateArgs>(args: SelectSubset<T, TriggerCreateArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Triggers.
     * @param {TriggerCreateManyArgs} args - Arguments to create many Triggers.
     * @example
     * // Create many Triggers
     * const trigger = await prisma.trigger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TriggerCreateManyArgs>(args?: SelectSubset<T, TriggerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trigger.
     * @param {TriggerDeleteArgs} args - Arguments to delete one Trigger.
     * @example
     * // Delete one Trigger
     * const Trigger = await prisma.trigger.delete({
     *   where: {
     *     // ... filter to delete one Trigger
     *   }
     * })
     * 
     */
    delete<T extends TriggerDeleteArgs>(args: SelectSubset<T, TriggerDeleteArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trigger.
     * @param {TriggerUpdateArgs} args - Arguments to update one Trigger.
     * @example
     * // Update one Trigger
     * const trigger = await prisma.trigger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TriggerUpdateArgs>(args: SelectSubset<T, TriggerUpdateArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Triggers.
     * @param {TriggerDeleteManyArgs} args - Arguments to filter Triggers to delete.
     * @example
     * // Delete a few Triggers
     * const { count } = await prisma.trigger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TriggerDeleteManyArgs>(args?: SelectSubset<T, TriggerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Triggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Triggers
     * const trigger = await prisma.trigger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TriggerUpdateManyArgs>(args: SelectSubset<T, TriggerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trigger.
     * @param {TriggerUpsertArgs} args - Arguments to update or create a Trigger.
     * @example
     * // Update or create a Trigger
     * const trigger = await prisma.trigger.upsert({
     *   create: {
     *     // ... data to create a Trigger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trigger we want to update
     *   }
     * })
     */
    upsert<T extends TriggerUpsertArgs>(args: SelectSubset<T, TriggerUpsertArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Triggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerCountArgs} args - Arguments to filter Triggers to count.
     * @example
     * // Count the number of Triggers
     * const count = await prisma.trigger.count({
     *   where: {
     *     // ... the filter for the Triggers we want to count
     *   }
     * })
    **/
    count<T extends TriggerCountArgs>(
      args?: Subset<T, TriggerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TriggerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trigger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TriggerAggregateArgs>(args: Subset<T, TriggerAggregateArgs>): Prisma.PrismaPromise<GetTriggerAggregateType<T>>

    /**
     * Group by Trigger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TriggerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TriggerGroupByArgs['orderBy'] }
        : { orderBy?: TriggerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TriggerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTriggerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trigger model
   */
  readonly fields: TriggerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trigger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TriggerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SubAccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Automation<T extends Trigger$AutomationArgs<ExtArgs> = {}>(args?: Subset<T, Trigger$AutomationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trigger model
   */
  interface TriggerFieldRefs {
    readonly id: FieldRef<"Trigger", 'String'>
    readonly name: FieldRef<"Trigger", 'String'>
    readonly type: FieldRef<"Trigger", 'TriggerTypes'>
    readonly createdAt: FieldRef<"Trigger", 'DateTime'>
    readonly updatedAt: FieldRef<"Trigger", 'DateTime'>
    readonly subAccountId: FieldRef<"Trigger", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Trigger findUnique
   */
  export type TriggerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter, which Trigger to fetch.
     */
    where: TriggerWhereUniqueInput
  }

  /**
   * Trigger findUniqueOrThrow
   */
  export type TriggerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter, which Trigger to fetch.
     */
    where: TriggerWhereUniqueInput
  }

  /**
   * Trigger findFirst
   */
  export type TriggerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter, which Trigger to fetch.
     */
    where?: TriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Triggers.
     */
    cursor?: TriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Triggers.
     */
    distinct?: TriggerScalarFieldEnum | TriggerScalarFieldEnum[]
  }

  /**
   * Trigger findFirstOrThrow
   */
  export type TriggerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter, which Trigger to fetch.
     */
    where?: TriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Triggers.
     */
    cursor?: TriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Triggers.
     */
    distinct?: TriggerScalarFieldEnum | TriggerScalarFieldEnum[]
  }

  /**
   * Trigger findMany
   */
  export type TriggerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter, which Triggers to fetch.
     */
    where?: TriggerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggerOrderByWithRelationInput | TriggerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Triggers.
     */
    cursor?: TriggerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    distinct?: TriggerScalarFieldEnum | TriggerScalarFieldEnum[]
  }

  /**
   * Trigger create
   */
  export type TriggerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * The data needed to create a Trigger.
     */
    data: XOR<TriggerCreateInput, TriggerUncheckedCreateInput>
  }

  /**
   * Trigger createMany
   */
  export type TriggerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Triggers.
     */
    data: TriggerCreateManyInput | TriggerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trigger update
   */
  export type TriggerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * The data needed to update a Trigger.
     */
    data: XOR<TriggerUpdateInput, TriggerUncheckedUpdateInput>
    /**
     * Choose, which Trigger to update.
     */
    where: TriggerWhereUniqueInput
  }

  /**
   * Trigger updateMany
   */
  export type TriggerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Triggers.
     */
    data: XOR<TriggerUpdateManyMutationInput, TriggerUncheckedUpdateManyInput>
    /**
     * Filter which Triggers to update
     */
    where?: TriggerWhereInput
    /**
     * Limit how many Triggers to update.
     */
    limit?: number
  }

  /**
   * Trigger upsert
   */
  export type TriggerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * The filter to search for the Trigger to update in case it exists.
     */
    where: TriggerWhereUniqueInput
    /**
     * In case the Trigger found by the `where` argument doesn't exist, create a new Trigger with this data.
     */
    create: XOR<TriggerCreateInput, TriggerUncheckedCreateInput>
    /**
     * In case the Trigger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TriggerUpdateInput, TriggerUncheckedUpdateInput>
  }

  /**
   * Trigger delete
   */
  export type TriggerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    /**
     * Filter which Trigger to delete.
     */
    where: TriggerWhereUniqueInput
  }

  /**
   * Trigger deleteMany
   */
  export type TriggerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Triggers to delete
     */
    where?: TriggerWhereInput
    /**
     * Limit how many Triggers to delete.
     */
    limit?: number
  }

  /**
   * Trigger.Automation
   */
  export type Trigger$AutomationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    where?: AutomationWhereInput
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    cursor?: AutomationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Trigger without action
   */
  export type TriggerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
  }


  /**
   * Model Automation
   */

  export type AggregateAutomation = {
    _count: AutomationCountAggregateOutputType | null
    _min: AutomationMinAggregateOutputType | null
    _max: AutomationMaxAggregateOutputType | null
  }

  export type AutomationMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    triggerId: string | null
    published: boolean | null
    subAccountId: string | null
  }

  export type AutomationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    triggerId: string | null
    published: boolean | null
    subAccountId: string | null
  }

  export type AutomationCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    triggerId: number
    published: number
    subAccountId: number
    _all: number
  }


  export type AutomationMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    triggerId?: true
    published?: true
    subAccountId?: true
  }

  export type AutomationMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    triggerId?: true
    published?: true
    subAccountId?: true
  }

  export type AutomationCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    triggerId?: true
    published?: true
    subAccountId?: true
    _all?: true
  }

  export type AutomationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automation to aggregate.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Automations
    **/
    _count?: true | AutomationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationMaxAggregateInputType
  }

  export type GetAutomationAggregateType<T extends AutomationAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomation[P]>
      : GetScalarType<T[P], AggregateAutomation[P]>
  }




  export type AutomationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationWhereInput
    orderBy?: AutomationOrderByWithAggregationInput | AutomationOrderByWithAggregationInput[]
    by: AutomationScalarFieldEnum[] | AutomationScalarFieldEnum
    having?: AutomationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationCountAggregateInputType | true
    _min?: AutomationMinAggregateInputType
    _max?: AutomationMaxAggregateInputType
  }

  export type AutomationGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    triggerId: string | null
    published: boolean
    subAccountId: string
    _count: AutomationCountAggregateOutputType | null
    _min: AutomationMinAggregateOutputType | null
    _max: AutomationMaxAggregateOutputType | null
  }

  type GetAutomationGroupByPayload<T extends AutomationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationGroupByOutputType[P]>
        }
      >
    >


  export type AutomationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    triggerId?: boolean
    published?: boolean
    subAccountId?: boolean
    Trigger?: boolean | Automation$TriggerArgs<ExtArgs>
    SubAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    Action?: boolean | Automation$ActionArgs<ExtArgs>
    AutomationInstance?: boolean | Automation$AutomationInstanceArgs<ExtArgs>
    _count?: boolean | AutomationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automation"]>



  export type AutomationSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    triggerId?: boolean
    published?: boolean
    subAccountId?: boolean
  }

  export type AutomationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "triggerId" | "published" | "subAccountId", ExtArgs["result"]["automation"]>
  export type AutomationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Trigger?: boolean | Automation$TriggerArgs<ExtArgs>
    SubAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    Action?: boolean | Automation$ActionArgs<ExtArgs>
    AutomationInstance?: boolean | Automation$AutomationInstanceArgs<ExtArgs>
    _count?: boolean | AutomationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AutomationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Automation"
    objects: {
      Trigger: Prisma.$TriggerPayload<ExtArgs> | null
      SubAccount: Prisma.$SubAccountPayload<ExtArgs>
      Action: Prisma.$ActionPayload<ExtArgs>[]
      AutomationInstance: Prisma.$AutomationInstancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      triggerId: string | null
      published: boolean
      subAccountId: string
    }, ExtArgs["result"]["automation"]>
    composites: {}
  }

  type AutomationGetPayload<S extends boolean | null | undefined | AutomationDefaultArgs> = $Result.GetResult<Prisma.$AutomationPayload, S>

  type AutomationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutomationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutomationCountAggregateInputType | true
    }

  export interface AutomationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Automation'], meta: { name: 'Automation' } }
    /**
     * Find zero or one Automation that matches the filter.
     * @param {AutomationFindUniqueArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationFindUniqueArgs>(args: SelectSubset<T, AutomationFindUniqueArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Automation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutomationFindUniqueOrThrowArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Automation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindFirstArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationFindFirstArgs>(args?: SelectSubset<T, AutomationFindFirstArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Automation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindFirstOrThrowArgs} args - Arguments to find a Automation
     * @example
     * // Get one Automation
     * const automation = await prisma.automation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Automations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Automations
     * const automations = await prisma.automation.findMany()
     * 
     * // Get first 10 Automations
     * const automations = await prisma.automation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationWithIdOnly = await prisma.automation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationFindManyArgs>(args?: SelectSubset<T, AutomationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Automation.
     * @param {AutomationCreateArgs} args - Arguments to create a Automation.
     * @example
     * // Create one Automation
     * const Automation = await prisma.automation.create({
     *   data: {
     *     // ... data to create a Automation
     *   }
     * })
     * 
     */
    create<T extends AutomationCreateArgs>(args: SelectSubset<T, AutomationCreateArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Automations.
     * @param {AutomationCreateManyArgs} args - Arguments to create many Automations.
     * @example
     * // Create many Automations
     * const automation = await prisma.automation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationCreateManyArgs>(args?: SelectSubset<T, AutomationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Automation.
     * @param {AutomationDeleteArgs} args - Arguments to delete one Automation.
     * @example
     * // Delete one Automation
     * const Automation = await prisma.automation.delete({
     *   where: {
     *     // ... filter to delete one Automation
     *   }
     * })
     * 
     */
    delete<T extends AutomationDeleteArgs>(args: SelectSubset<T, AutomationDeleteArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Automation.
     * @param {AutomationUpdateArgs} args - Arguments to update one Automation.
     * @example
     * // Update one Automation
     * const automation = await prisma.automation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationUpdateArgs>(args: SelectSubset<T, AutomationUpdateArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Automations.
     * @param {AutomationDeleteManyArgs} args - Arguments to filter Automations to delete.
     * @example
     * // Delete a few Automations
     * const { count } = await prisma.automation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationDeleteManyArgs>(args?: SelectSubset<T, AutomationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Automations
     * const automation = await prisma.automation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationUpdateManyArgs>(args: SelectSubset<T, AutomationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Automation.
     * @param {AutomationUpsertArgs} args - Arguments to update or create a Automation.
     * @example
     * // Update or create a Automation
     * const automation = await prisma.automation.upsert({
     *   create: {
     *     // ... data to create a Automation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Automation we want to update
     *   }
     * })
     */
    upsert<T extends AutomationUpsertArgs>(args: SelectSubset<T, AutomationUpsertArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationCountArgs} args - Arguments to filter Automations to count.
     * @example
     * // Count the number of Automations
     * const count = await prisma.automation.count({
     *   where: {
     *     // ... the filter for the Automations we want to count
     *   }
     * })
    **/
    count<T extends AutomationCountArgs>(
      args?: Subset<T, AutomationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Automation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationAggregateArgs>(args: Subset<T, AutomationAggregateArgs>): Prisma.PrismaPromise<GetAutomationAggregateType<T>>

    /**
     * Group by Automation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationGroupByArgs['orderBy'] }
        : { orderBy?: AutomationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Automation model
   */
  readonly fields: AutomationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Automation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Trigger<T extends Automation$TriggerArgs<ExtArgs> = {}>(args?: Subset<T, Automation$TriggerArgs<ExtArgs>>): Prisma__TriggerClient<$Result.GetResult<Prisma.$TriggerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    SubAccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Action<T extends Automation$ActionArgs<ExtArgs> = {}>(args?: Subset<T, Automation$ActionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AutomationInstance<T extends Automation$AutomationInstanceArgs<ExtArgs> = {}>(args?: Subset<T, Automation$AutomationInstanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Automation model
   */
  interface AutomationFieldRefs {
    readonly id: FieldRef<"Automation", 'String'>
    readonly name: FieldRef<"Automation", 'String'>
    readonly createdAt: FieldRef<"Automation", 'DateTime'>
    readonly updatedAt: FieldRef<"Automation", 'DateTime'>
    readonly triggerId: FieldRef<"Automation", 'String'>
    readonly published: FieldRef<"Automation", 'Boolean'>
    readonly subAccountId: FieldRef<"Automation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Automation findUnique
   */
  export type AutomationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation findUniqueOrThrow
   */
  export type AutomationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation findFirst
   */
  export type AutomationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation findFirstOrThrow
   */
  export type AutomationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automation to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation findMany
   */
  export type AutomationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter, which Automations to fetch.
     */
    where?: AutomationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationOrderByWithRelationInput | AutomationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Automations.
     */
    cursor?: AutomationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    distinct?: AutomationScalarFieldEnum | AutomationScalarFieldEnum[]
  }

  /**
   * Automation create
   */
  export type AutomationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The data needed to create a Automation.
     */
    data: XOR<AutomationCreateInput, AutomationUncheckedCreateInput>
  }

  /**
   * Automation createMany
   */
  export type AutomationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Automations.
     */
    data: AutomationCreateManyInput | AutomationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Automation update
   */
  export type AutomationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The data needed to update a Automation.
     */
    data: XOR<AutomationUpdateInput, AutomationUncheckedUpdateInput>
    /**
     * Choose, which Automation to update.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation updateMany
   */
  export type AutomationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Automations.
     */
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyInput>
    /**
     * Filter which Automations to update
     */
    where?: AutomationWhereInput
    /**
     * Limit how many Automations to update.
     */
    limit?: number
  }

  /**
   * Automation upsert
   */
  export type AutomationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * The filter to search for the Automation to update in case it exists.
     */
    where: AutomationWhereUniqueInput
    /**
     * In case the Automation found by the `where` argument doesn't exist, create a new Automation with this data.
     */
    create: XOR<AutomationCreateInput, AutomationUncheckedCreateInput>
    /**
     * In case the Automation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationUpdateInput, AutomationUncheckedUpdateInput>
  }

  /**
   * Automation delete
   */
  export type AutomationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
    /**
     * Filter which Automation to delete.
     */
    where: AutomationWhereUniqueInput
  }

  /**
   * Automation deleteMany
   */
  export type AutomationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automations to delete
     */
    where?: AutomationWhereInput
    /**
     * Limit how many Automations to delete.
     */
    limit?: number
  }

  /**
   * Automation.Trigger
   */
  export type Automation$TriggerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trigger
     */
    select?: TriggerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trigger
     */
    omit?: TriggerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggerInclude<ExtArgs> | null
    where?: TriggerWhereInput
  }

  /**
   * Automation.Action
   */
  export type Automation$ActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    where?: ActionWhereInput
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    cursor?: ActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Automation.AutomationInstance
   */
  export type Automation$AutomationInstanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    where?: AutomationInstanceWhereInput
    orderBy?: AutomationInstanceOrderByWithRelationInput | AutomationInstanceOrderByWithRelationInput[]
    cursor?: AutomationInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationInstanceScalarFieldEnum | AutomationInstanceScalarFieldEnum[]
  }

  /**
   * Automation without action
   */
  export type AutomationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automation
     */
    select?: AutomationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automation
     */
    omit?: AutomationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInclude<ExtArgs> | null
  }


  /**
   * Model AutomationInstance
   */

  export type AggregateAutomationInstance = {
    _count: AutomationInstanceCountAggregateOutputType | null
    _min: AutomationInstanceMinAggregateOutputType | null
    _max: AutomationInstanceMaxAggregateOutputType | null
  }

  export type AutomationInstanceMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    automationId: string | null
    active: boolean | null
  }

  export type AutomationInstanceMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    automationId: string | null
    active: boolean | null
  }

  export type AutomationInstanceCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    automationId: number
    active: number
    _all: number
  }


  export type AutomationInstanceMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    automationId?: true
    active?: true
  }

  export type AutomationInstanceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    automationId?: true
    active?: true
  }

  export type AutomationInstanceCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    automationId?: true
    active?: true
    _all?: true
  }

  export type AutomationInstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationInstance to aggregate.
     */
    where?: AutomationInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationInstances to fetch.
     */
    orderBy?: AutomationInstanceOrderByWithRelationInput | AutomationInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationInstances
    **/
    _count?: true | AutomationInstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationInstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationInstanceMaxAggregateInputType
  }

  export type GetAutomationInstanceAggregateType<T extends AutomationInstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationInstance[P]>
      : GetScalarType<T[P], AggregateAutomationInstance[P]>
  }




  export type AutomationInstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationInstanceWhereInput
    orderBy?: AutomationInstanceOrderByWithAggregationInput | AutomationInstanceOrderByWithAggregationInput[]
    by: AutomationInstanceScalarFieldEnum[] | AutomationInstanceScalarFieldEnum
    having?: AutomationInstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationInstanceCountAggregateInputType | true
    _min?: AutomationInstanceMinAggregateInputType
    _max?: AutomationInstanceMaxAggregateInputType
  }

  export type AutomationInstanceGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    automationId: string
    active: boolean
    _count: AutomationInstanceCountAggregateOutputType | null
    _min: AutomationInstanceMinAggregateOutputType | null
    _max: AutomationInstanceMaxAggregateOutputType | null
  }

  type GetAutomationInstanceGroupByPayload<T extends AutomationInstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationInstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationInstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationInstanceGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationInstanceGroupByOutputType[P]>
        }
      >
    >


  export type AutomationInstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automationId?: boolean
    active?: boolean
    Automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationInstance"]>



  export type AutomationInstanceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automationId?: boolean
    active?: boolean
  }

  export type AutomationInstanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "automationId" | "active", ExtArgs["result"]["automationInstance"]>
  export type AutomationInstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }

  export type $AutomationInstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationInstance"
    objects: {
      Automation: Prisma.$AutomationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      automationId: string
      active: boolean
    }, ExtArgs["result"]["automationInstance"]>
    composites: {}
  }

  type AutomationInstanceGetPayload<S extends boolean | null | undefined | AutomationInstanceDefaultArgs> = $Result.GetResult<Prisma.$AutomationInstancePayload, S>

  type AutomationInstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutomationInstanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutomationInstanceCountAggregateInputType | true
    }

  export interface AutomationInstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationInstance'], meta: { name: 'AutomationInstance' } }
    /**
     * Find zero or one AutomationInstance that matches the filter.
     * @param {AutomationInstanceFindUniqueArgs} args - Arguments to find a AutomationInstance
     * @example
     * // Get one AutomationInstance
     * const automationInstance = await prisma.automationInstance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationInstanceFindUniqueArgs>(args: SelectSubset<T, AutomationInstanceFindUniqueArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutomationInstance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutomationInstanceFindUniqueOrThrowArgs} args - Arguments to find a AutomationInstance
     * @example
     * // Get one AutomationInstance
     * const automationInstance = await prisma.automationInstance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationInstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationInstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationInstance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceFindFirstArgs} args - Arguments to find a AutomationInstance
     * @example
     * // Get one AutomationInstance
     * const automationInstance = await prisma.automationInstance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationInstanceFindFirstArgs>(args?: SelectSubset<T, AutomationInstanceFindFirstArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationInstance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceFindFirstOrThrowArgs} args - Arguments to find a AutomationInstance
     * @example
     * // Get one AutomationInstance
     * const automationInstance = await prisma.automationInstance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationInstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationInstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutomationInstances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationInstances
     * const automationInstances = await prisma.automationInstance.findMany()
     * 
     * // Get first 10 AutomationInstances
     * const automationInstances = await prisma.automationInstance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationInstanceWithIdOnly = await prisma.automationInstance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationInstanceFindManyArgs>(args?: SelectSubset<T, AutomationInstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutomationInstance.
     * @param {AutomationInstanceCreateArgs} args - Arguments to create a AutomationInstance.
     * @example
     * // Create one AutomationInstance
     * const AutomationInstance = await prisma.automationInstance.create({
     *   data: {
     *     // ... data to create a AutomationInstance
     *   }
     * })
     * 
     */
    create<T extends AutomationInstanceCreateArgs>(args: SelectSubset<T, AutomationInstanceCreateArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutomationInstances.
     * @param {AutomationInstanceCreateManyArgs} args - Arguments to create many AutomationInstances.
     * @example
     * // Create many AutomationInstances
     * const automationInstance = await prisma.automationInstance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationInstanceCreateManyArgs>(args?: SelectSubset<T, AutomationInstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AutomationInstance.
     * @param {AutomationInstanceDeleteArgs} args - Arguments to delete one AutomationInstance.
     * @example
     * // Delete one AutomationInstance
     * const AutomationInstance = await prisma.automationInstance.delete({
     *   where: {
     *     // ... filter to delete one AutomationInstance
     *   }
     * })
     * 
     */
    delete<T extends AutomationInstanceDeleteArgs>(args: SelectSubset<T, AutomationInstanceDeleteArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutomationInstance.
     * @param {AutomationInstanceUpdateArgs} args - Arguments to update one AutomationInstance.
     * @example
     * // Update one AutomationInstance
     * const automationInstance = await prisma.automationInstance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationInstanceUpdateArgs>(args: SelectSubset<T, AutomationInstanceUpdateArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutomationInstances.
     * @param {AutomationInstanceDeleteManyArgs} args - Arguments to filter AutomationInstances to delete.
     * @example
     * // Delete a few AutomationInstances
     * const { count } = await prisma.automationInstance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationInstanceDeleteManyArgs>(args?: SelectSubset<T, AutomationInstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationInstances
     * const automationInstance = await prisma.automationInstance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationInstanceUpdateManyArgs>(args: SelectSubset<T, AutomationInstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutomationInstance.
     * @param {AutomationInstanceUpsertArgs} args - Arguments to update or create a AutomationInstance.
     * @example
     * // Update or create a AutomationInstance
     * const automationInstance = await prisma.automationInstance.upsert({
     *   create: {
     *     // ... data to create a AutomationInstance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationInstance we want to update
     *   }
     * })
     */
    upsert<T extends AutomationInstanceUpsertArgs>(args: SelectSubset<T, AutomationInstanceUpsertArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AutomationInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceCountArgs} args - Arguments to filter AutomationInstances to count.
     * @example
     * // Count the number of AutomationInstances
     * const count = await prisma.automationInstance.count({
     *   where: {
     *     // ... the filter for the AutomationInstances we want to count
     *   }
     * })
    **/
    count<T extends AutomationInstanceCountArgs>(
      args?: Subset<T, AutomationInstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationInstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationInstanceAggregateArgs>(args: Subset<T, AutomationInstanceAggregateArgs>): Prisma.PrismaPromise<GetAutomationInstanceAggregateType<T>>

    /**
     * Group by AutomationInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationInstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationInstanceGroupByArgs['orderBy'] }
        : { orderBy?: AutomationInstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationInstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationInstance model
   */
  readonly fields: AutomationInstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationInstance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationInstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Automation<T extends AutomationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationDefaultArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationInstance model
   */
  interface AutomationInstanceFieldRefs {
    readonly id: FieldRef<"AutomationInstance", 'String'>
    readonly createdAt: FieldRef<"AutomationInstance", 'DateTime'>
    readonly updatedAt: FieldRef<"AutomationInstance", 'DateTime'>
    readonly automationId: FieldRef<"AutomationInstance", 'String'>
    readonly active: FieldRef<"AutomationInstance", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AutomationInstance findUnique
   */
  export type AutomationInstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter, which AutomationInstance to fetch.
     */
    where: AutomationInstanceWhereUniqueInput
  }

  /**
   * AutomationInstance findUniqueOrThrow
   */
  export type AutomationInstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter, which AutomationInstance to fetch.
     */
    where: AutomationInstanceWhereUniqueInput
  }

  /**
   * AutomationInstance findFirst
   */
  export type AutomationInstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter, which AutomationInstance to fetch.
     */
    where?: AutomationInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationInstances to fetch.
     */
    orderBy?: AutomationInstanceOrderByWithRelationInput | AutomationInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationInstances.
     */
    cursor?: AutomationInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationInstances.
     */
    distinct?: AutomationInstanceScalarFieldEnum | AutomationInstanceScalarFieldEnum[]
  }

  /**
   * AutomationInstance findFirstOrThrow
   */
  export type AutomationInstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter, which AutomationInstance to fetch.
     */
    where?: AutomationInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationInstances to fetch.
     */
    orderBy?: AutomationInstanceOrderByWithRelationInput | AutomationInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationInstances.
     */
    cursor?: AutomationInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationInstances.
     */
    distinct?: AutomationInstanceScalarFieldEnum | AutomationInstanceScalarFieldEnum[]
  }

  /**
   * AutomationInstance findMany
   */
  export type AutomationInstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter, which AutomationInstances to fetch.
     */
    where?: AutomationInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationInstances to fetch.
     */
    orderBy?: AutomationInstanceOrderByWithRelationInput | AutomationInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationInstances.
     */
    cursor?: AutomationInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationInstances.
     */
    skip?: number
    distinct?: AutomationInstanceScalarFieldEnum | AutomationInstanceScalarFieldEnum[]
  }

  /**
   * AutomationInstance create
   */
  export type AutomationInstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a AutomationInstance.
     */
    data: XOR<AutomationInstanceCreateInput, AutomationInstanceUncheckedCreateInput>
  }

  /**
   * AutomationInstance createMany
   */
  export type AutomationInstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationInstances.
     */
    data: AutomationInstanceCreateManyInput | AutomationInstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationInstance update
   */
  export type AutomationInstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a AutomationInstance.
     */
    data: XOR<AutomationInstanceUpdateInput, AutomationInstanceUncheckedUpdateInput>
    /**
     * Choose, which AutomationInstance to update.
     */
    where: AutomationInstanceWhereUniqueInput
  }

  /**
   * AutomationInstance updateMany
   */
  export type AutomationInstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationInstances.
     */
    data: XOR<AutomationInstanceUpdateManyMutationInput, AutomationInstanceUncheckedUpdateManyInput>
    /**
     * Filter which AutomationInstances to update
     */
    where?: AutomationInstanceWhereInput
    /**
     * Limit how many AutomationInstances to update.
     */
    limit?: number
  }

  /**
   * AutomationInstance upsert
   */
  export type AutomationInstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the AutomationInstance to update in case it exists.
     */
    where: AutomationInstanceWhereUniqueInput
    /**
     * In case the AutomationInstance found by the `where` argument doesn't exist, create a new AutomationInstance with this data.
     */
    create: XOR<AutomationInstanceCreateInput, AutomationInstanceUncheckedCreateInput>
    /**
     * In case the AutomationInstance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationInstanceUpdateInput, AutomationInstanceUncheckedUpdateInput>
  }

  /**
   * AutomationInstance delete
   */
  export type AutomationInstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter which AutomationInstance to delete.
     */
    where: AutomationInstanceWhereUniqueInput
  }

  /**
   * AutomationInstance deleteMany
   */
  export type AutomationInstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationInstances to delete
     */
    where?: AutomationInstanceWhereInput
    /**
     * Limit how many AutomationInstances to delete.
     */
    limit?: number
  }

  /**
   * AutomationInstance without action
   */
  export type AutomationInstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
  }


  /**
   * Model Action
   */

  export type AggregateAction = {
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  export type ActionAvgAggregateOutputType = {
    order: number | null
  }

  export type ActionSumAggregateOutputType = {
    order: number | null
  }

  export type ActionMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ActionType | null
    createdAt: Date | null
    updatedAt: Date | null
    automationId: string | null
    order: number | null
    laneId: string | null
  }

  export type ActionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ActionType | null
    createdAt: Date | null
    updatedAt: Date | null
    automationId: string | null
    order: number | null
    laneId: string | null
  }

  export type ActionCountAggregateOutputType = {
    id: number
    name: number
    type: number
    createdAt: number
    updatedAt: number
    automationId: number
    order: number
    laneId: number
    _all: number
  }


  export type ActionAvgAggregateInputType = {
    order?: true
  }

  export type ActionSumAggregateInputType = {
    order?: true
  }

  export type ActionMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    automationId?: true
    order?: true
    laneId?: true
  }

  export type ActionMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    automationId?: true
    order?: true
    laneId?: true
  }

  export type ActionCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    automationId?: true
    order?: true
    laneId?: true
    _all?: true
  }

  export type ActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Action to aggregate.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actions
    **/
    _count?: true | ActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionMaxAggregateInputType
  }

  export type GetActionAggregateType<T extends ActionAggregateArgs> = {
        [P in keyof T & keyof AggregateAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAction[P]>
      : GetScalarType<T[P], AggregateAction[P]>
  }




  export type ActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionWhereInput
    orderBy?: ActionOrderByWithAggregationInput | ActionOrderByWithAggregationInput[]
    by: ActionScalarFieldEnum[] | ActionScalarFieldEnum
    having?: ActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionCountAggregateInputType | true
    _avg?: ActionAvgAggregateInputType
    _sum?: ActionSumAggregateInputType
    _min?: ActionMinAggregateInputType
    _max?: ActionMaxAggregateInputType
  }

  export type ActionGroupByOutputType = {
    id: string
    name: string
    type: $Enums.ActionType
    createdAt: Date
    updatedAt: Date
    automationId: string
    order: number
    laneId: string
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  type GetActionGroupByPayload<T extends ActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionGroupByOutputType[P]>
            : GetScalarType<T[P], ActionGroupByOutputType[P]>
        }
      >
    >


  export type ActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automationId?: boolean
    order?: boolean
    laneId?: boolean
    Automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["action"]>



  export type ActionSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automationId?: boolean
    order?: boolean
    laneId?: boolean
  }

  export type ActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "createdAt" | "updatedAt" | "automationId" | "order" | "laneId", ExtArgs["result"]["action"]>
  export type ActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Automation?: boolean | AutomationDefaultArgs<ExtArgs>
  }

  export type $ActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Action"
    objects: {
      Automation: Prisma.$AutomationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.ActionType
      createdAt: Date
      updatedAt: Date
      automationId: string
      order: number
      laneId: string
    }, ExtArgs["result"]["action"]>
    composites: {}
  }

  type ActionGetPayload<S extends boolean | null | undefined | ActionDefaultArgs> = $Result.GetResult<Prisma.$ActionPayload, S>

  type ActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActionCountAggregateInputType | true
    }

  export interface ActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Action'], meta: { name: 'Action' } }
    /**
     * Find zero or one Action that matches the filter.
     * @param {ActionFindUniqueArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionFindUniqueArgs>(args: SelectSubset<T, ActionFindUniqueArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Action that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActionFindUniqueOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Action that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionFindFirstArgs>(args?: SelectSubset<T, ActionFindFirstArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Action that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actions
     * const actions = await prisma.action.findMany()
     * 
     * // Get first 10 Actions
     * const actions = await prisma.action.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionWithIdOnly = await prisma.action.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionFindManyArgs>(args?: SelectSubset<T, ActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Action.
     * @param {ActionCreateArgs} args - Arguments to create a Action.
     * @example
     * // Create one Action
     * const Action = await prisma.action.create({
     *   data: {
     *     // ... data to create a Action
     *   }
     * })
     * 
     */
    create<T extends ActionCreateArgs>(args: SelectSubset<T, ActionCreateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Actions.
     * @param {ActionCreateManyArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const action = await prisma.action.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionCreateManyArgs>(args?: SelectSubset<T, ActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Action.
     * @param {ActionDeleteArgs} args - Arguments to delete one Action.
     * @example
     * // Delete one Action
     * const Action = await prisma.action.delete({
     *   where: {
     *     // ... filter to delete one Action
     *   }
     * })
     * 
     */
    delete<T extends ActionDeleteArgs>(args: SelectSubset<T, ActionDeleteArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Action.
     * @param {ActionUpdateArgs} args - Arguments to update one Action.
     * @example
     * // Update one Action
     * const action = await prisma.action.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionUpdateArgs>(args: SelectSubset<T, ActionUpdateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Actions.
     * @param {ActionDeleteManyArgs} args - Arguments to filter Actions to delete.
     * @example
     * // Delete a few Actions
     * const { count } = await prisma.action.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionDeleteManyArgs>(args?: SelectSubset<T, ActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actions
     * const action = await prisma.action.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionUpdateManyArgs>(args: SelectSubset<T, ActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Action.
     * @param {ActionUpsertArgs} args - Arguments to update or create a Action.
     * @example
     * // Update or create a Action
     * const action = await prisma.action.upsert({
     *   create: {
     *     // ... data to create a Action
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Action we want to update
     *   }
     * })
     */
    upsert<T extends ActionUpsertArgs>(args: SelectSubset<T, ActionUpsertArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionCountArgs} args - Arguments to filter Actions to count.
     * @example
     * // Count the number of Actions
     * const count = await prisma.action.count({
     *   where: {
     *     // ... the filter for the Actions we want to count
     *   }
     * })
    **/
    count<T extends ActionCountArgs>(
      args?: Subset<T, ActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionAggregateArgs>(args: Subset<T, ActionAggregateArgs>): Prisma.PrismaPromise<GetActionAggregateType<T>>

    /**
     * Group by Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionGroupByArgs['orderBy'] }
        : { orderBy?: ActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Action model
   */
  readonly fields: ActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Action.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Automation<T extends AutomationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationDefaultArgs<ExtArgs>>): Prisma__AutomationClient<$Result.GetResult<Prisma.$AutomationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Action model
   */
  interface ActionFieldRefs {
    readonly id: FieldRef<"Action", 'String'>
    readonly name: FieldRef<"Action", 'String'>
    readonly type: FieldRef<"Action", 'ActionType'>
    readonly createdAt: FieldRef<"Action", 'DateTime'>
    readonly updatedAt: FieldRef<"Action", 'DateTime'>
    readonly automationId: FieldRef<"Action", 'String'>
    readonly order: FieldRef<"Action", 'Int'>
    readonly laneId: FieldRef<"Action", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Action findUnique
   */
  export type ActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findUniqueOrThrow
   */
  export type ActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findFirst
   */
  export type ActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findFirstOrThrow
   */
  export type ActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findMany
   */
  export type ActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Actions to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action create
   */
  export type ActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The data needed to create a Action.
     */
    data: XOR<ActionCreateInput, ActionUncheckedCreateInput>
  }

  /**
   * Action createMany
   */
  export type ActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Actions.
     */
    data: ActionCreateManyInput | ActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Action update
   */
  export type ActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The data needed to update a Action.
     */
    data: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
    /**
     * Choose, which Action to update.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action updateMany
   */
  export type ActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Actions.
     */
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to update.
     */
    limit?: number
  }

  /**
   * Action upsert
   */
  export type ActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The filter to search for the Action to update in case it exists.
     */
    where: ActionWhereUniqueInput
    /**
     * In case the Action found by the `where` argument doesn't exist, create a new Action with this data.
     */
    create: XOR<ActionCreateInput, ActionUncheckedCreateInput>
    /**
     * In case the Action was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
  }

  /**
   * Action delete
   */
  export type ActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter which Action to delete.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action deleteMany
   */
  export type ActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actions to delete
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to delete.
     */
    limit?: number
  }

  /**
   * Action without action
   */
  export type ActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    name: number
    email: number
    createdAt: number
    updatedAt: number
    subAccountId: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    name: string
    email: string
    createdAt: Date
    updatedAt: Date
    subAccountId: string
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    SubAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    Tickets?: boolean | Contact$TicketsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>



  export type ContactSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "createdAt" | "updatedAt" | "subAccountId", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    Tickets?: boolean | Contact$TicketsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      SubAccount: Prisma.$SubAccountPayload<ExtArgs>
      Tickets: Prisma.$TicketsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      createdAt: Date
      updatedAt: Date
      subAccountId: string
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SubAccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Tickets<T extends Contact$TicketsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$TicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
    readonly subAccountId: FieldRef<"Contact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.Tickets
   */
  export type Contact$TicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    where?: TicketsWhereInput
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    cursor?: TicketsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    link: string | null
    subAccountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    link: string | null
    subAccountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    type: number
    name: number
    link: number
    subAccountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    link?: true
    subAccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    link?: true
    subAccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    link?: true
    subAccountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    type: string | null
    name: string
    link: string
    subAccountId: string
    createdAt: Date
    updatedAt: Date
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    link?: boolean
    subAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    SubAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>



  export type MediaSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    link?: boolean
    subAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "name" | "link" | "subAccountId" | "createdAt" | "updatedAt", ExtArgs["result"]["media"]>
  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      SubAccount: Prisma.$SubAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string | null
      name: string
      link: string
      subAccountId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SubAccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly type: FieldRef<"Media", 'String'>
    readonly name: FieldRef<"Media", 'String'>
    readonly link: FieldRef<"Media", 'String'>
    readonly subAccountId: FieldRef<"Media", 'String'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
    readonly updatedAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to delete.
     */
    limit?: number
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model Funnels
   */

  export type AggregateFunnels = {
    _count: FunnelsCountAggregateOutputType | null
    _min: FunnelsMinAggregateOutputType | null
    _max: FunnelsMaxAggregateOutputType | null
  }

  export type FunnelsMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    published: boolean | null
    subDomainName: string | null
    favicon: string | null
    subAccountId: string | null
    liveProducts: string | null
  }

  export type FunnelsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    published: boolean | null
    subDomainName: string | null
    favicon: string | null
    subAccountId: string | null
    liveProducts: string | null
  }

  export type FunnelsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    description: number
    published: number
    subDomainName: number
    favicon: number
    subAccountId: number
    liveProducts: number
    _all: number
  }


  export type FunnelsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    published?: true
    subDomainName?: true
    favicon?: true
    subAccountId?: true
    liveProducts?: true
  }

  export type FunnelsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    published?: true
    subDomainName?: true
    favicon?: true
    subAccountId?: true
    liveProducts?: true
  }

  export type FunnelsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    published?: true
    subDomainName?: true
    favicon?: true
    subAccountId?: true
    liveProducts?: true
    _all?: true
  }

  export type FunnelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Funnels to aggregate.
     */
    where?: FunnelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelsOrderByWithRelationInput | FunnelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FunnelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Funnels
    **/
    _count?: true | FunnelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FunnelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FunnelsMaxAggregateInputType
  }

  export type GetFunnelsAggregateType<T extends FunnelsAggregateArgs> = {
        [P in keyof T & keyof AggregateFunnels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunnels[P]>
      : GetScalarType<T[P], AggregateFunnels[P]>
  }




  export type FunnelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunnelsWhereInput
    orderBy?: FunnelsOrderByWithAggregationInput | FunnelsOrderByWithAggregationInput[]
    by: FunnelsScalarFieldEnum[] | FunnelsScalarFieldEnum
    having?: FunnelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FunnelsCountAggregateInputType | true
    _min?: FunnelsMinAggregateInputType
    _max?: FunnelsMaxAggregateInputType
  }

  export type FunnelsGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    description: string | null
    published: boolean
    subDomainName: string | null
    favicon: string | null
    subAccountId: string
    liveProducts: string | null
    _count: FunnelsCountAggregateOutputType | null
    _min: FunnelsMinAggregateOutputType | null
    _max: FunnelsMaxAggregateOutputType | null
  }

  type GetFunnelsGroupByPayload<T extends FunnelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FunnelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FunnelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FunnelsGroupByOutputType[P]>
            : GetScalarType<T[P], FunnelsGroupByOutputType[P]>
        }
      >
    >


  export type FunnelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    published?: boolean
    subDomainName?: boolean
    favicon?: boolean
    subAccountId?: boolean
    liveProducts?: boolean
    SubAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    FunnelPages?: boolean | Funnels$FunnelPagesArgs<ExtArgs>
    ClassName?: boolean | Funnels$ClassNameArgs<ExtArgs>
    _count?: boolean | FunnelsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnels"]>



  export type FunnelsSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    published?: boolean
    subDomainName?: boolean
    favicon?: boolean
    subAccountId?: boolean
    liveProducts?: boolean
  }

  export type FunnelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "description" | "published" | "subDomainName" | "favicon" | "subAccountId" | "liveProducts", ExtArgs["result"]["funnels"]>
  export type FunnelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccount?: boolean | SubAccountDefaultArgs<ExtArgs>
    FunnelPages?: boolean | Funnels$FunnelPagesArgs<ExtArgs>
    ClassName?: boolean | Funnels$ClassNameArgs<ExtArgs>
    _count?: boolean | FunnelsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FunnelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Funnels"
    objects: {
      SubAccount: Prisma.$SubAccountPayload<ExtArgs>
      FunnelPages: Prisma.$FunnelPagesPayload<ExtArgs>[]
      ClassName: Prisma.$ClassNamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      description: string | null
      published: boolean
      subDomainName: string | null
      favicon: string | null
      subAccountId: string
      liveProducts: string | null
    }, ExtArgs["result"]["funnels"]>
    composites: {}
  }

  type FunnelsGetPayload<S extends boolean | null | undefined | FunnelsDefaultArgs> = $Result.GetResult<Prisma.$FunnelsPayload, S>

  type FunnelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FunnelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FunnelsCountAggregateInputType | true
    }

  export interface FunnelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Funnels'], meta: { name: 'Funnels' } }
    /**
     * Find zero or one Funnels that matches the filter.
     * @param {FunnelsFindUniqueArgs} args - Arguments to find a Funnels
     * @example
     * // Get one Funnels
     * const funnels = await prisma.funnels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FunnelsFindUniqueArgs>(args: SelectSubset<T, FunnelsFindUniqueArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Funnels that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FunnelsFindUniqueOrThrowArgs} args - Arguments to find a Funnels
     * @example
     * // Get one Funnels
     * const funnels = await prisma.funnels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FunnelsFindUniqueOrThrowArgs>(args: SelectSubset<T, FunnelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Funnels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelsFindFirstArgs} args - Arguments to find a Funnels
     * @example
     * // Get one Funnels
     * const funnels = await prisma.funnels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FunnelsFindFirstArgs>(args?: SelectSubset<T, FunnelsFindFirstArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Funnels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelsFindFirstOrThrowArgs} args - Arguments to find a Funnels
     * @example
     * // Get one Funnels
     * const funnels = await prisma.funnels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FunnelsFindFirstOrThrowArgs>(args?: SelectSubset<T, FunnelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Funnels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Funnels
     * const funnels = await prisma.funnels.findMany()
     * 
     * // Get first 10 Funnels
     * const funnels = await prisma.funnels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const funnelsWithIdOnly = await prisma.funnels.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FunnelsFindManyArgs>(args?: SelectSubset<T, FunnelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Funnels.
     * @param {FunnelsCreateArgs} args - Arguments to create a Funnels.
     * @example
     * // Create one Funnels
     * const Funnels = await prisma.funnels.create({
     *   data: {
     *     // ... data to create a Funnels
     *   }
     * })
     * 
     */
    create<T extends FunnelsCreateArgs>(args: SelectSubset<T, FunnelsCreateArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Funnels.
     * @param {FunnelsCreateManyArgs} args - Arguments to create many Funnels.
     * @example
     * // Create many Funnels
     * const funnels = await prisma.funnels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FunnelsCreateManyArgs>(args?: SelectSubset<T, FunnelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Funnels.
     * @param {FunnelsDeleteArgs} args - Arguments to delete one Funnels.
     * @example
     * // Delete one Funnels
     * const Funnels = await prisma.funnels.delete({
     *   where: {
     *     // ... filter to delete one Funnels
     *   }
     * })
     * 
     */
    delete<T extends FunnelsDeleteArgs>(args: SelectSubset<T, FunnelsDeleteArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Funnels.
     * @param {FunnelsUpdateArgs} args - Arguments to update one Funnels.
     * @example
     * // Update one Funnels
     * const funnels = await prisma.funnels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FunnelsUpdateArgs>(args: SelectSubset<T, FunnelsUpdateArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Funnels.
     * @param {FunnelsDeleteManyArgs} args - Arguments to filter Funnels to delete.
     * @example
     * // Delete a few Funnels
     * const { count } = await prisma.funnels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FunnelsDeleteManyArgs>(args?: SelectSubset<T, FunnelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Funnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Funnels
     * const funnels = await prisma.funnels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FunnelsUpdateManyArgs>(args: SelectSubset<T, FunnelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Funnels.
     * @param {FunnelsUpsertArgs} args - Arguments to update or create a Funnels.
     * @example
     * // Update or create a Funnels
     * const funnels = await prisma.funnels.upsert({
     *   create: {
     *     // ... data to create a Funnels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Funnels we want to update
     *   }
     * })
     */
    upsert<T extends FunnelsUpsertArgs>(args: SelectSubset<T, FunnelsUpsertArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Funnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelsCountArgs} args - Arguments to filter Funnels to count.
     * @example
     * // Count the number of Funnels
     * const count = await prisma.funnels.count({
     *   where: {
     *     // ... the filter for the Funnels we want to count
     *   }
     * })
    **/
    count<T extends FunnelsCountArgs>(
      args?: Subset<T, FunnelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FunnelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Funnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FunnelsAggregateArgs>(args: Subset<T, FunnelsAggregateArgs>): Prisma.PrismaPromise<GetFunnelsAggregateType<T>>

    /**
     * Group by Funnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FunnelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FunnelsGroupByArgs['orderBy'] }
        : { orderBy?: FunnelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FunnelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunnelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Funnels model
   */
  readonly fields: FunnelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Funnels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FunnelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SubAccount<T extends SubAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountDefaultArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    FunnelPages<T extends Funnels$FunnelPagesArgs<ExtArgs> = {}>(args?: Subset<T, Funnels$FunnelPagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelPagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ClassName<T extends Funnels$ClassNameArgs<ExtArgs> = {}>(args?: Subset<T, Funnels$ClassNameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Funnels model
   */
  interface FunnelsFieldRefs {
    readonly id: FieldRef<"Funnels", 'String'>
    readonly name: FieldRef<"Funnels", 'String'>
    readonly createdAt: FieldRef<"Funnels", 'DateTime'>
    readonly updatedAt: FieldRef<"Funnels", 'DateTime'>
    readonly description: FieldRef<"Funnels", 'String'>
    readonly published: FieldRef<"Funnels", 'Boolean'>
    readonly subDomainName: FieldRef<"Funnels", 'String'>
    readonly favicon: FieldRef<"Funnels", 'String'>
    readonly subAccountId: FieldRef<"Funnels", 'String'>
    readonly liveProducts: FieldRef<"Funnels", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Funnels findUnique
   */
  export type FunnelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * Filter, which Funnels to fetch.
     */
    where: FunnelsWhereUniqueInput
  }

  /**
   * Funnels findUniqueOrThrow
   */
  export type FunnelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * Filter, which Funnels to fetch.
     */
    where: FunnelsWhereUniqueInput
  }

  /**
   * Funnels findFirst
   */
  export type FunnelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * Filter, which Funnels to fetch.
     */
    where?: FunnelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelsOrderByWithRelationInput | FunnelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Funnels.
     */
    cursor?: FunnelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Funnels.
     */
    distinct?: FunnelsScalarFieldEnum | FunnelsScalarFieldEnum[]
  }

  /**
   * Funnels findFirstOrThrow
   */
  export type FunnelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * Filter, which Funnels to fetch.
     */
    where?: FunnelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelsOrderByWithRelationInput | FunnelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Funnels.
     */
    cursor?: FunnelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Funnels.
     */
    distinct?: FunnelsScalarFieldEnum | FunnelsScalarFieldEnum[]
  }

  /**
   * Funnels findMany
   */
  export type FunnelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * Filter, which Funnels to fetch.
     */
    where?: FunnelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelsOrderByWithRelationInput | FunnelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Funnels.
     */
    cursor?: FunnelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    distinct?: FunnelsScalarFieldEnum | FunnelsScalarFieldEnum[]
  }

  /**
   * Funnels create
   */
  export type FunnelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * The data needed to create a Funnels.
     */
    data: XOR<FunnelsCreateInput, FunnelsUncheckedCreateInput>
  }

  /**
   * Funnels createMany
   */
  export type FunnelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Funnels.
     */
    data: FunnelsCreateManyInput | FunnelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Funnels update
   */
  export type FunnelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * The data needed to update a Funnels.
     */
    data: XOR<FunnelsUpdateInput, FunnelsUncheckedUpdateInput>
    /**
     * Choose, which Funnels to update.
     */
    where: FunnelsWhereUniqueInput
  }

  /**
   * Funnels updateMany
   */
  export type FunnelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Funnels.
     */
    data: XOR<FunnelsUpdateManyMutationInput, FunnelsUncheckedUpdateManyInput>
    /**
     * Filter which Funnels to update
     */
    where?: FunnelsWhereInput
    /**
     * Limit how many Funnels to update.
     */
    limit?: number
  }

  /**
   * Funnels upsert
   */
  export type FunnelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * The filter to search for the Funnels to update in case it exists.
     */
    where: FunnelsWhereUniqueInput
    /**
     * In case the Funnels found by the `where` argument doesn't exist, create a new Funnels with this data.
     */
    create: XOR<FunnelsCreateInput, FunnelsUncheckedCreateInput>
    /**
     * In case the Funnels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FunnelsUpdateInput, FunnelsUncheckedUpdateInput>
  }

  /**
   * Funnels delete
   */
  export type FunnelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * Filter which Funnels to delete.
     */
    where: FunnelsWhereUniqueInput
  }

  /**
   * Funnels deleteMany
   */
  export type FunnelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Funnels to delete
     */
    where?: FunnelsWhereInput
    /**
     * Limit how many Funnels to delete.
     */
    limit?: number
  }

  /**
   * Funnels.FunnelPages
   */
  export type Funnels$FunnelPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPages
     */
    select?: FunnelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPages
     */
    omit?: FunnelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPagesInclude<ExtArgs> | null
    where?: FunnelPagesWhereInput
    orderBy?: FunnelPagesOrderByWithRelationInput | FunnelPagesOrderByWithRelationInput[]
    cursor?: FunnelPagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FunnelPagesScalarFieldEnum | FunnelPagesScalarFieldEnum[]
  }

  /**
   * Funnels.ClassName
   */
  export type Funnels$ClassNameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    where?: ClassNameWhereInput
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    cursor?: ClassNameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * Funnels without action
   */
  export type FunnelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
  }


  /**
   * Model FunnelPages
   */

  export type AggregateFunnelPages = {
    _count: FunnelPagesCountAggregateOutputType | null
    _avg: FunnelPagesAvgAggregateOutputType | null
    _sum: FunnelPagesSumAggregateOutputType | null
    _min: FunnelPagesMinAggregateOutputType | null
    _max: FunnelPagesMaxAggregateOutputType | null
  }

  export type FunnelPagesAvgAggregateOutputType = {
    visits: number | null
    order: number | null
  }

  export type FunnelPagesSumAggregateOutputType = {
    visits: number | null
    order: number | null
  }

  export type FunnelPagesMinAggregateOutputType = {
    id: string | null
    name: string | null
    pathName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    visits: number | null
    content: string | null
    order: number | null
    previewImage: string | null
    funnelId: string | null
  }

  export type FunnelPagesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    pathName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    visits: number | null
    content: string | null
    order: number | null
    previewImage: string | null
    funnelId: string | null
  }

  export type FunnelPagesCountAggregateOutputType = {
    id: number
    name: number
    pathName: number
    createdAt: number
    updatedAt: number
    visits: number
    content: number
    order: number
    previewImage: number
    funnelId: number
    _all: number
  }


  export type FunnelPagesAvgAggregateInputType = {
    visits?: true
    order?: true
  }

  export type FunnelPagesSumAggregateInputType = {
    visits?: true
    order?: true
  }

  export type FunnelPagesMinAggregateInputType = {
    id?: true
    name?: true
    pathName?: true
    createdAt?: true
    updatedAt?: true
    visits?: true
    content?: true
    order?: true
    previewImage?: true
    funnelId?: true
  }

  export type FunnelPagesMaxAggregateInputType = {
    id?: true
    name?: true
    pathName?: true
    createdAt?: true
    updatedAt?: true
    visits?: true
    content?: true
    order?: true
    previewImage?: true
    funnelId?: true
  }

  export type FunnelPagesCountAggregateInputType = {
    id?: true
    name?: true
    pathName?: true
    createdAt?: true
    updatedAt?: true
    visits?: true
    content?: true
    order?: true
    previewImage?: true
    funnelId?: true
    _all?: true
  }

  export type FunnelPagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FunnelPages to aggregate.
     */
    where?: FunnelPagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelPages to fetch.
     */
    orderBy?: FunnelPagesOrderByWithRelationInput | FunnelPagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FunnelPagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FunnelPages
    **/
    _count?: true | FunnelPagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FunnelPagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FunnelPagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FunnelPagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FunnelPagesMaxAggregateInputType
  }

  export type GetFunnelPagesAggregateType<T extends FunnelPagesAggregateArgs> = {
        [P in keyof T & keyof AggregateFunnelPages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunnelPages[P]>
      : GetScalarType<T[P], AggregateFunnelPages[P]>
  }




  export type FunnelPagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunnelPagesWhereInput
    orderBy?: FunnelPagesOrderByWithAggregationInput | FunnelPagesOrderByWithAggregationInput[]
    by: FunnelPagesScalarFieldEnum[] | FunnelPagesScalarFieldEnum
    having?: FunnelPagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FunnelPagesCountAggregateInputType | true
    _avg?: FunnelPagesAvgAggregateInputType
    _sum?: FunnelPagesSumAggregateInputType
    _min?: FunnelPagesMinAggregateInputType
    _max?: FunnelPagesMaxAggregateInputType
  }

  export type FunnelPagesGroupByOutputType = {
    id: string
    name: string
    pathName: string
    createdAt: Date
    updatedAt: Date
    visits: number
    content: string | null
    order: number
    previewImage: string | null
    funnelId: string
    _count: FunnelPagesCountAggregateOutputType | null
    _avg: FunnelPagesAvgAggregateOutputType | null
    _sum: FunnelPagesSumAggregateOutputType | null
    _min: FunnelPagesMinAggregateOutputType | null
    _max: FunnelPagesMaxAggregateOutputType | null
  }

  type GetFunnelPagesGroupByPayload<T extends FunnelPagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FunnelPagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FunnelPagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FunnelPagesGroupByOutputType[P]>
            : GetScalarType<T[P], FunnelPagesGroupByOutputType[P]>
        }
      >
    >


  export type FunnelPagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pathName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visits?: boolean
    content?: boolean
    order?: boolean
    previewImage?: boolean
    funnelId?: boolean
    Funnels?: boolean | FunnelsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnelPages"]>



  export type FunnelPagesSelectScalar = {
    id?: boolean
    name?: boolean
    pathName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visits?: boolean
    content?: boolean
    order?: boolean
    previewImage?: boolean
    funnelId?: boolean
  }

  export type FunnelPagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "pathName" | "createdAt" | "updatedAt" | "visits" | "content" | "order" | "previewImage" | "funnelId", ExtArgs["result"]["funnelPages"]>
  export type FunnelPagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Funnels?: boolean | FunnelsDefaultArgs<ExtArgs>
  }

  export type $FunnelPagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FunnelPages"
    objects: {
      Funnels: Prisma.$FunnelsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      pathName: string
      createdAt: Date
      updatedAt: Date
      visits: number
      content: string | null
      order: number
      previewImage: string | null
      funnelId: string
    }, ExtArgs["result"]["funnelPages"]>
    composites: {}
  }

  type FunnelPagesGetPayload<S extends boolean | null | undefined | FunnelPagesDefaultArgs> = $Result.GetResult<Prisma.$FunnelPagesPayload, S>

  type FunnelPagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FunnelPagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FunnelPagesCountAggregateInputType | true
    }

  export interface FunnelPagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FunnelPages'], meta: { name: 'FunnelPages' } }
    /**
     * Find zero or one FunnelPages that matches the filter.
     * @param {FunnelPagesFindUniqueArgs} args - Arguments to find a FunnelPages
     * @example
     * // Get one FunnelPages
     * const funnelPages = await prisma.funnelPages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FunnelPagesFindUniqueArgs>(args: SelectSubset<T, FunnelPagesFindUniqueArgs<ExtArgs>>): Prisma__FunnelPagesClient<$Result.GetResult<Prisma.$FunnelPagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FunnelPages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FunnelPagesFindUniqueOrThrowArgs} args - Arguments to find a FunnelPages
     * @example
     * // Get one FunnelPages
     * const funnelPages = await prisma.funnelPages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FunnelPagesFindUniqueOrThrowArgs>(args: SelectSubset<T, FunnelPagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FunnelPagesClient<$Result.GetResult<Prisma.$FunnelPagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FunnelPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelPagesFindFirstArgs} args - Arguments to find a FunnelPages
     * @example
     * // Get one FunnelPages
     * const funnelPages = await prisma.funnelPages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FunnelPagesFindFirstArgs>(args?: SelectSubset<T, FunnelPagesFindFirstArgs<ExtArgs>>): Prisma__FunnelPagesClient<$Result.GetResult<Prisma.$FunnelPagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FunnelPages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelPagesFindFirstOrThrowArgs} args - Arguments to find a FunnelPages
     * @example
     * // Get one FunnelPages
     * const funnelPages = await prisma.funnelPages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FunnelPagesFindFirstOrThrowArgs>(args?: SelectSubset<T, FunnelPagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__FunnelPagesClient<$Result.GetResult<Prisma.$FunnelPagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FunnelPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelPagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FunnelPages
     * const funnelPages = await prisma.funnelPages.findMany()
     * 
     * // Get first 10 FunnelPages
     * const funnelPages = await prisma.funnelPages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const funnelPagesWithIdOnly = await prisma.funnelPages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FunnelPagesFindManyArgs>(args?: SelectSubset<T, FunnelPagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelPagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FunnelPages.
     * @param {FunnelPagesCreateArgs} args - Arguments to create a FunnelPages.
     * @example
     * // Create one FunnelPages
     * const FunnelPages = await prisma.funnelPages.create({
     *   data: {
     *     // ... data to create a FunnelPages
     *   }
     * })
     * 
     */
    create<T extends FunnelPagesCreateArgs>(args: SelectSubset<T, FunnelPagesCreateArgs<ExtArgs>>): Prisma__FunnelPagesClient<$Result.GetResult<Prisma.$FunnelPagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FunnelPages.
     * @param {FunnelPagesCreateManyArgs} args - Arguments to create many FunnelPages.
     * @example
     * // Create many FunnelPages
     * const funnelPages = await prisma.funnelPages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FunnelPagesCreateManyArgs>(args?: SelectSubset<T, FunnelPagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FunnelPages.
     * @param {FunnelPagesDeleteArgs} args - Arguments to delete one FunnelPages.
     * @example
     * // Delete one FunnelPages
     * const FunnelPages = await prisma.funnelPages.delete({
     *   where: {
     *     // ... filter to delete one FunnelPages
     *   }
     * })
     * 
     */
    delete<T extends FunnelPagesDeleteArgs>(args: SelectSubset<T, FunnelPagesDeleteArgs<ExtArgs>>): Prisma__FunnelPagesClient<$Result.GetResult<Prisma.$FunnelPagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FunnelPages.
     * @param {FunnelPagesUpdateArgs} args - Arguments to update one FunnelPages.
     * @example
     * // Update one FunnelPages
     * const funnelPages = await prisma.funnelPages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FunnelPagesUpdateArgs>(args: SelectSubset<T, FunnelPagesUpdateArgs<ExtArgs>>): Prisma__FunnelPagesClient<$Result.GetResult<Prisma.$FunnelPagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FunnelPages.
     * @param {FunnelPagesDeleteManyArgs} args - Arguments to filter FunnelPages to delete.
     * @example
     * // Delete a few FunnelPages
     * const { count } = await prisma.funnelPages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FunnelPagesDeleteManyArgs>(args?: SelectSubset<T, FunnelPagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FunnelPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelPagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FunnelPages
     * const funnelPages = await prisma.funnelPages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FunnelPagesUpdateManyArgs>(args: SelectSubset<T, FunnelPagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FunnelPages.
     * @param {FunnelPagesUpsertArgs} args - Arguments to update or create a FunnelPages.
     * @example
     * // Update or create a FunnelPages
     * const funnelPages = await prisma.funnelPages.upsert({
     *   create: {
     *     // ... data to create a FunnelPages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FunnelPages we want to update
     *   }
     * })
     */
    upsert<T extends FunnelPagesUpsertArgs>(args: SelectSubset<T, FunnelPagesUpsertArgs<ExtArgs>>): Prisma__FunnelPagesClient<$Result.GetResult<Prisma.$FunnelPagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FunnelPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelPagesCountArgs} args - Arguments to filter FunnelPages to count.
     * @example
     * // Count the number of FunnelPages
     * const count = await prisma.funnelPages.count({
     *   where: {
     *     // ... the filter for the FunnelPages we want to count
     *   }
     * })
    **/
    count<T extends FunnelPagesCountArgs>(
      args?: Subset<T, FunnelPagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FunnelPagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FunnelPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelPagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FunnelPagesAggregateArgs>(args: Subset<T, FunnelPagesAggregateArgs>): Prisma.PrismaPromise<GetFunnelPagesAggregateType<T>>

    /**
     * Group by FunnelPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelPagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FunnelPagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FunnelPagesGroupByArgs['orderBy'] }
        : { orderBy?: FunnelPagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FunnelPagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunnelPagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FunnelPages model
   */
  readonly fields: FunnelPagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FunnelPages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FunnelPagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Funnels<T extends FunnelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FunnelsDefaultArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FunnelPages model
   */
  interface FunnelPagesFieldRefs {
    readonly id: FieldRef<"FunnelPages", 'String'>
    readonly name: FieldRef<"FunnelPages", 'String'>
    readonly pathName: FieldRef<"FunnelPages", 'String'>
    readonly createdAt: FieldRef<"FunnelPages", 'DateTime'>
    readonly updatedAt: FieldRef<"FunnelPages", 'DateTime'>
    readonly visits: FieldRef<"FunnelPages", 'Int'>
    readonly content: FieldRef<"FunnelPages", 'String'>
    readonly order: FieldRef<"FunnelPages", 'Int'>
    readonly previewImage: FieldRef<"FunnelPages", 'String'>
    readonly funnelId: FieldRef<"FunnelPages", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FunnelPages findUnique
   */
  export type FunnelPagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPages
     */
    select?: FunnelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPages
     */
    omit?: FunnelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPagesInclude<ExtArgs> | null
    /**
     * Filter, which FunnelPages to fetch.
     */
    where: FunnelPagesWhereUniqueInput
  }

  /**
   * FunnelPages findUniqueOrThrow
   */
  export type FunnelPagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPages
     */
    select?: FunnelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPages
     */
    omit?: FunnelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPagesInclude<ExtArgs> | null
    /**
     * Filter, which FunnelPages to fetch.
     */
    where: FunnelPagesWhereUniqueInput
  }

  /**
   * FunnelPages findFirst
   */
  export type FunnelPagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPages
     */
    select?: FunnelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPages
     */
    omit?: FunnelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPagesInclude<ExtArgs> | null
    /**
     * Filter, which FunnelPages to fetch.
     */
    where?: FunnelPagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelPages to fetch.
     */
    orderBy?: FunnelPagesOrderByWithRelationInput | FunnelPagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FunnelPages.
     */
    cursor?: FunnelPagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FunnelPages.
     */
    distinct?: FunnelPagesScalarFieldEnum | FunnelPagesScalarFieldEnum[]
  }

  /**
   * FunnelPages findFirstOrThrow
   */
  export type FunnelPagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPages
     */
    select?: FunnelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPages
     */
    omit?: FunnelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPagesInclude<ExtArgs> | null
    /**
     * Filter, which FunnelPages to fetch.
     */
    where?: FunnelPagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelPages to fetch.
     */
    orderBy?: FunnelPagesOrderByWithRelationInput | FunnelPagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FunnelPages.
     */
    cursor?: FunnelPagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FunnelPages.
     */
    distinct?: FunnelPagesScalarFieldEnum | FunnelPagesScalarFieldEnum[]
  }

  /**
   * FunnelPages findMany
   */
  export type FunnelPagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPages
     */
    select?: FunnelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPages
     */
    omit?: FunnelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPagesInclude<ExtArgs> | null
    /**
     * Filter, which FunnelPages to fetch.
     */
    where?: FunnelPagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelPages to fetch.
     */
    orderBy?: FunnelPagesOrderByWithRelationInput | FunnelPagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FunnelPages.
     */
    cursor?: FunnelPagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelPages.
     */
    skip?: number
    distinct?: FunnelPagesScalarFieldEnum | FunnelPagesScalarFieldEnum[]
  }

  /**
   * FunnelPages create
   */
  export type FunnelPagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPages
     */
    select?: FunnelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPages
     */
    omit?: FunnelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPagesInclude<ExtArgs> | null
    /**
     * The data needed to create a FunnelPages.
     */
    data: XOR<FunnelPagesCreateInput, FunnelPagesUncheckedCreateInput>
  }

  /**
   * FunnelPages createMany
   */
  export type FunnelPagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FunnelPages.
     */
    data: FunnelPagesCreateManyInput | FunnelPagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FunnelPages update
   */
  export type FunnelPagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPages
     */
    select?: FunnelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPages
     */
    omit?: FunnelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPagesInclude<ExtArgs> | null
    /**
     * The data needed to update a FunnelPages.
     */
    data: XOR<FunnelPagesUpdateInput, FunnelPagesUncheckedUpdateInput>
    /**
     * Choose, which FunnelPages to update.
     */
    where: FunnelPagesWhereUniqueInput
  }

  /**
   * FunnelPages updateMany
   */
  export type FunnelPagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FunnelPages.
     */
    data: XOR<FunnelPagesUpdateManyMutationInput, FunnelPagesUncheckedUpdateManyInput>
    /**
     * Filter which FunnelPages to update
     */
    where?: FunnelPagesWhereInput
    /**
     * Limit how many FunnelPages to update.
     */
    limit?: number
  }

  /**
   * FunnelPages upsert
   */
  export type FunnelPagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPages
     */
    select?: FunnelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPages
     */
    omit?: FunnelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPagesInclude<ExtArgs> | null
    /**
     * The filter to search for the FunnelPages to update in case it exists.
     */
    where: FunnelPagesWhereUniqueInput
    /**
     * In case the FunnelPages found by the `where` argument doesn't exist, create a new FunnelPages with this data.
     */
    create: XOR<FunnelPagesCreateInput, FunnelPagesUncheckedCreateInput>
    /**
     * In case the FunnelPages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FunnelPagesUpdateInput, FunnelPagesUncheckedUpdateInput>
  }

  /**
   * FunnelPages delete
   */
  export type FunnelPagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPages
     */
    select?: FunnelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPages
     */
    omit?: FunnelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPagesInclude<ExtArgs> | null
    /**
     * Filter which FunnelPages to delete.
     */
    where: FunnelPagesWhereUniqueInput
  }

  /**
   * FunnelPages deleteMany
   */
  export type FunnelPagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FunnelPages to delete
     */
    where?: FunnelPagesWhereInput
    /**
     * Limit how many FunnelPages to delete.
     */
    limit?: number
  }

  /**
   * FunnelPages without action
   */
  export type FunnelPagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelPages
     */
    select?: FunnelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunnelPages
     */
    omit?: FunnelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelPagesInclude<ExtArgs> | null
  }


  /**
   * Model ClassName
   */

  export type AggregateClassName = {
    _count: ClassNameCountAggregateOutputType | null
    _min: ClassNameMinAggregateOutputType | null
    _max: ClassNameMaxAggregateOutputType | null
  }

  export type ClassNameMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    funnelId: string | null
    customDate: string | null
  }

  export type ClassNameMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    funnelId: string | null
    customDate: string | null
  }

  export type ClassNameCountAggregateOutputType = {
    id: number
    name: number
    color: number
    createdAt: number
    updatedAt: number
    funnelId: number
    customDate: number
    _all: number
  }


  export type ClassNameMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    funnelId?: true
    customDate?: true
  }

  export type ClassNameMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    funnelId?: true
    customDate?: true
  }

  export type ClassNameCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    funnelId?: true
    customDate?: true
    _all?: true
  }

  export type ClassNameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassName to aggregate.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassNames
    **/
    _count?: true | ClassNameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassNameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassNameMaxAggregateInputType
  }

  export type GetClassNameAggregateType<T extends ClassNameAggregateArgs> = {
        [P in keyof T & keyof AggregateClassName]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassName[P]>
      : GetScalarType<T[P], AggregateClassName[P]>
  }




  export type ClassNameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassNameWhereInput
    orderBy?: ClassNameOrderByWithAggregationInput | ClassNameOrderByWithAggregationInput[]
    by: ClassNameScalarFieldEnum[] | ClassNameScalarFieldEnum
    having?: ClassNameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassNameCountAggregateInputType | true
    _min?: ClassNameMinAggregateInputType
    _max?: ClassNameMaxAggregateInputType
  }

  export type ClassNameGroupByOutputType = {
    id: string
    name: string
    color: string
    createdAt: Date
    updatedAt: Date
    funnelId: string
    customDate: string | null
    _count: ClassNameCountAggregateOutputType | null
    _min: ClassNameMinAggregateOutputType | null
    _max: ClassNameMaxAggregateOutputType | null
  }

  type GetClassNameGroupByPayload<T extends ClassNameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassNameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassNameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassNameGroupByOutputType[P]>
            : GetScalarType<T[P], ClassNameGroupByOutputType[P]>
        }
      >
    >


  export type ClassNameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    funnelId?: boolean
    customDate?: boolean
    Funnels?: boolean | FunnelsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["className"]>



  export type ClassNameSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    funnelId?: boolean
    customDate?: boolean
  }

  export type ClassNameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "createdAt" | "updatedAt" | "funnelId" | "customDate", ExtArgs["result"]["className"]>
  export type ClassNameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Funnels?: boolean | FunnelsDefaultArgs<ExtArgs>
  }

  export type $ClassNamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassName"
    objects: {
      Funnels: Prisma.$FunnelsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string
      createdAt: Date
      updatedAt: Date
      funnelId: string
      customDate: string | null
    }, ExtArgs["result"]["className"]>
    composites: {}
  }

  type ClassNameGetPayload<S extends boolean | null | undefined | ClassNameDefaultArgs> = $Result.GetResult<Prisma.$ClassNamePayload, S>

  type ClassNameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassNameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassNameCountAggregateInputType | true
    }

  export interface ClassNameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassName'], meta: { name: 'ClassName' } }
    /**
     * Find zero or one ClassName that matches the filter.
     * @param {ClassNameFindUniqueArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassNameFindUniqueArgs>(args: SelectSubset<T, ClassNameFindUniqueArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassName that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassNameFindUniqueOrThrowArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassNameFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassNameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassName that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameFindFirstArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassNameFindFirstArgs>(args?: SelectSubset<T, ClassNameFindFirstArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassName that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameFindFirstOrThrowArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassNameFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassNameFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassNames
     * const classNames = await prisma.className.findMany()
     * 
     * // Get first 10 ClassNames
     * const classNames = await prisma.className.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classNameWithIdOnly = await prisma.className.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassNameFindManyArgs>(args?: SelectSubset<T, ClassNameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassName.
     * @param {ClassNameCreateArgs} args - Arguments to create a ClassName.
     * @example
     * // Create one ClassName
     * const ClassName = await prisma.className.create({
     *   data: {
     *     // ... data to create a ClassName
     *   }
     * })
     * 
     */
    create<T extends ClassNameCreateArgs>(args: SelectSubset<T, ClassNameCreateArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassNames.
     * @param {ClassNameCreateManyArgs} args - Arguments to create many ClassNames.
     * @example
     * // Create many ClassNames
     * const className = await prisma.className.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassNameCreateManyArgs>(args?: SelectSubset<T, ClassNameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassName.
     * @param {ClassNameDeleteArgs} args - Arguments to delete one ClassName.
     * @example
     * // Delete one ClassName
     * const ClassName = await prisma.className.delete({
     *   where: {
     *     // ... filter to delete one ClassName
     *   }
     * })
     * 
     */
    delete<T extends ClassNameDeleteArgs>(args: SelectSubset<T, ClassNameDeleteArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassName.
     * @param {ClassNameUpdateArgs} args - Arguments to update one ClassName.
     * @example
     * // Update one ClassName
     * const className = await prisma.className.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassNameUpdateArgs>(args: SelectSubset<T, ClassNameUpdateArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassNames.
     * @param {ClassNameDeleteManyArgs} args - Arguments to filter ClassNames to delete.
     * @example
     * // Delete a few ClassNames
     * const { count } = await prisma.className.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassNameDeleteManyArgs>(args?: SelectSubset<T, ClassNameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassNames
     * const className = await prisma.className.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassNameUpdateManyArgs>(args: SelectSubset<T, ClassNameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassName.
     * @param {ClassNameUpsertArgs} args - Arguments to update or create a ClassName.
     * @example
     * // Update or create a ClassName
     * const className = await prisma.className.upsert({
     *   create: {
     *     // ... data to create a ClassName
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassName we want to update
     *   }
     * })
     */
    upsert<T extends ClassNameUpsertArgs>(args: SelectSubset<T, ClassNameUpsertArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameCountArgs} args - Arguments to filter ClassNames to count.
     * @example
     * // Count the number of ClassNames
     * const count = await prisma.className.count({
     *   where: {
     *     // ... the filter for the ClassNames we want to count
     *   }
     * })
    **/
    count<T extends ClassNameCountArgs>(
      args?: Subset<T, ClassNameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassNameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassNameAggregateArgs>(args: Subset<T, ClassNameAggregateArgs>): Prisma.PrismaPromise<GetClassNameAggregateType<T>>

    /**
     * Group by ClassName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassNameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassNameGroupByArgs['orderBy'] }
        : { orderBy?: ClassNameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassNameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassNameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassName model
   */
  readonly fields: ClassNameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassName.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassNameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Funnels<T extends FunnelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FunnelsDefaultArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassName model
   */
  interface ClassNameFieldRefs {
    readonly id: FieldRef<"ClassName", 'String'>
    readonly name: FieldRef<"ClassName", 'String'>
    readonly color: FieldRef<"ClassName", 'String'>
    readonly createdAt: FieldRef<"ClassName", 'DateTime'>
    readonly updatedAt: FieldRef<"ClassName", 'DateTime'>
    readonly funnelId: FieldRef<"ClassName", 'String'>
    readonly customDate: FieldRef<"ClassName", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClassName findUnique
   */
  export type ClassNameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName findUniqueOrThrow
   */
  export type ClassNameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName findFirst
   */
  export type ClassNameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassNames.
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassNames.
     */
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * ClassName findFirstOrThrow
   */
  export type ClassNameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassNames.
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassNames.
     */
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * ClassName findMany
   */
  export type ClassNameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassNames to fetch.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassNames.
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * ClassName create
   */
  export type ClassNameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassName.
     */
    data: XOR<ClassNameCreateInput, ClassNameUncheckedCreateInput>
  }

  /**
   * ClassName createMany
   */
  export type ClassNameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassNames.
     */
    data: ClassNameCreateManyInput | ClassNameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassName update
   */
  export type ClassNameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassName.
     */
    data: XOR<ClassNameUpdateInput, ClassNameUncheckedUpdateInput>
    /**
     * Choose, which ClassName to update.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName updateMany
   */
  export type ClassNameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassNames.
     */
    data: XOR<ClassNameUpdateManyMutationInput, ClassNameUncheckedUpdateManyInput>
    /**
     * Filter which ClassNames to update
     */
    where?: ClassNameWhereInput
    /**
     * Limit how many ClassNames to update.
     */
    limit?: number
  }

  /**
   * ClassName upsert
   */
  export type ClassNameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassName to update in case it exists.
     */
    where: ClassNameWhereUniqueInput
    /**
     * In case the ClassName found by the `where` argument doesn't exist, create a new ClassName with this data.
     */
    create: XOR<ClassNameCreateInput, ClassNameUncheckedCreateInput>
    /**
     * In case the ClassName was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassNameUpdateInput, ClassNameUncheckedUpdateInput>
  }

  /**
   * ClassName delete
   */
  export type ClassNameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter which ClassName to delete.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName deleteMany
   */
  export type ClassNameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassNames to delete
     */
    where?: ClassNameWhereInput
    /**
     * Limit how many ClassNames to delete.
     */
    limit?: number
  }

  /**
   * ClassName without action
   */
  export type ClassNameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
  }


  /**
   * Model AgencySidebarOption
   */

  export type AggregateAgencySidebarOption = {
    _count: AgencySidebarOptionCountAggregateOutputType | null
    _min: AgencySidebarOptionMinAggregateOutputType | null
    _max: AgencySidebarOptionMaxAggregateOutputType | null
  }

  export type AgencySidebarOptionMinAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
    icon: $Enums.Icon | null
    agencyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencySidebarOptionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
    icon: $Enums.Icon | null
    agencyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencySidebarOptionCountAggregateOutputType = {
    id: number
    name: number
    link: number
    icon: number
    agencyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencySidebarOptionMinAggregateInputType = {
    id?: true
    name?: true
    link?: true
    icon?: true
    agencyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencySidebarOptionMaxAggregateInputType = {
    id?: true
    name?: true
    link?: true
    icon?: true
    agencyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencySidebarOptionCountAggregateInputType = {
    id?: true
    name?: true
    link?: true
    icon?: true
    agencyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencySidebarOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencySidebarOption to aggregate.
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySidebarOptions to fetch.
     */
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencySidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencySidebarOptions
    **/
    _count?: true | AgencySidebarOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencySidebarOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencySidebarOptionMaxAggregateInputType
  }

  export type GetAgencySidebarOptionAggregateType<T extends AgencySidebarOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencySidebarOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencySidebarOption[P]>
      : GetScalarType<T[P], AggregateAgencySidebarOption[P]>
  }




  export type AgencySidebarOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencySidebarOptionWhereInput
    orderBy?: AgencySidebarOptionOrderByWithAggregationInput | AgencySidebarOptionOrderByWithAggregationInput[]
    by: AgencySidebarOptionScalarFieldEnum[] | AgencySidebarOptionScalarFieldEnum
    having?: AgencySidebarOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencySidebarOptionCountAggregateInputType | true
    _min?: AgencySidebarOptionMinAggregateInputType
    _max?: AgencySidebarOptionMaxAggregateInputType
  }

  export type AgencySidebarOptionGroupByOutputType = {
    id: string
    name: string
    link: string
    icon: $Enums.Icon
    agencyId: string
    createdAt: Date
    updatedAt: Date
    _count: AgencySidebarOptionCountAggregateOutputType | null
    _min: AgencySidebarOptionMinAggregateOutputType | null
    _max: AgencySidebarOptionMaxAggregateOutputType | null
  }

  type GetAgencySidebarOptionGroupByPayload<T extends AgencySidebarOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencySidebarOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencySidebarOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencySidebarOptionGroupByOutputType[P]>
            : GetScalarType<T[P], AgencySidebarOptionGroupByOutputType[P]>
        }
      >
    >


  export type AgencySidebarOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    agencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Agency?: boolean | AgencySidebarOption$AgencyArgs<ExtArgs>
  }, ExtArgs["result"]["agencySidebarOption"]>



  export type AgencySidebarOptionSelectScalar = {
    id?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    agencyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencySidebarOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "link" | "icon" | "agencyId" | "createdAt" | "updatedAt", ExtArgs["result"]["agencySidebarOption"]>
  export type AgencySidebarOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AgencySidebarOption$AgencyArgs<ExtArgs>
  }

  export type $AgencySidebarOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencySidebarOption"
    objects: {
      Agency: Prisma.$AgencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      link: string
      icon: $Enums.Icon
      agencyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agencySidebarOption"]>
    composites: {}
  }

  type AgencySidebarOptionGetPayload<S extends boolean | null | undefined | AgencySidebarOptionDefaultArgs> = $Result.GetResult<Prisma.$AgencySidebarOptionPayload, S>

  type AgencySidebarOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencySidebarOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgencySidebarOptionCountAggregateInputType | true
    }

  export interface AgencySidebarOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencySidebarOption'], meta: { name: 'AgencySidebarOption' } }
    /**
     * Find zero or one AgencySidebarOption that matches the filter.
     * @param {AgencySidebarOptionFindUniqueArgs} args - Arguments to find a AgencySidebarOption
     * @example
     * // Get one AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencySidebarOptionFindUniqueArgs>(args: SelectSubset<T, AgencySidebarOptionFindUniqueArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgencySidebarOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencySidebarOptionFindUniqueOrThrowArgs} args - Arguments to find a AgencySidebarOption
     * @example
     * // Get one AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencySidebarOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencySidebarOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencySidebarOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionFindFirstArgs} args - Arguments to find a AgencySidebarOption
     * @example
     * // Get one AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencySidebarOptionFindFirstArgs>(args?: SelectSubset<T, AgencySidebarOptionFindFirstArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencySidebarOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionFindFirstOrThrowArgs} args - Arguments to find a AgencySidebarOption
     * @example
     * // Get one AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencySidebarOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencySidebarOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgencySidebarOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencySidebarOptions
     * const agencySidebarOptions = await prisma.agencySidebarOption.findMany()
     * 
     * // Get first 10 AgencySidebarOptions
     * const agencySidebarOptions = await prisma.agencySidebarOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencySidebarOptionWithIdOnly = await prisma.agencySidebarOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencySidebarOptionFindManyArgs>(args?: SelectSubset<T, AgencySidebarOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgencySidebarOption.
     * @param {AgencySidebarOptionCreateArgs} args - Arguments to create a AgencySidebarOption.
     * @example
     * // Create one AgencySidebarOption
     * const AgencySidebarOption = await prisma.agencySidebarOption.create({
     *   data: {
     *     // ... data to create a AgencySidebarOption
     *   }
     * })
     * 
     */
    create<T extends AgencySidebarOptionCreateArgs>(args: SelectSubset<T, AgencySidebarOptionCreateArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgencySidebarOptions.
     * @param {AgencySidebarOptionCreateManyArgs} args - Arguments to create many AgencySidebarOptions.
     * @example
     * // Create many AgencySidebarOptions
     * const agencySidebarOption = await prisma.agencySidebarOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencySidebarOptionCreateManyArgs>(args?: SelectSubset<T, AgencySidebarOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgencySidebarOption.
     * @param {AgencySidebarOptionDeleteArgs} args - Arguments to delete one AgencySidebarOption.
     * @example
     * // Delete one AgencySidebarOption
     * const AgencySidebarOption = await prisma.agencySidebarOption.delete({
     *   where: {
     *     // ... filter to delete one AgencySidebarOption
     *   }
     * })
     * 
     */
    delete<T extends AgencySidebarOptionDeleteArgs>(args: SelectSubset<T, AgencySidebarOptionDeleteArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgencySidebarOption.
     * @param {AgencySidebarOptionUpdateArgs} args - Arguments to update one AgencySidebarOption.
     * @example
     * // Update one AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencySidebarOptionUpdateArgs>(args: SelectSubset<T, AgencySidebarOptionUpdateArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgencySidebarOptions.
     * @param {AgencySidebarOptionDeleteManyArgs} args - Arguments to filter AgencySidebarOptions to delete.
     * @example
     * // Delete a few AgencySidebarOptions
     * const { count } = await prisma.agencySidebarOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencySidebarOptionDeleteManyArgs>(args?: SelectSubset<T, AgencySidebarOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencySidebarOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencySidebarOptions
     * const agencySidebarOption = await prisma.agencySidebarOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencySidebarOptionUpdateManyArgs>(args: SelectSubset<T, AgencySidebarOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgencySidebarOption.
     * @param {AgencySidebarOptionUpsertArgs} args - Arguments to update or create a AgencySidebarOption.
     * @example
     * // Update or create a AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.upsert({
     *   create: {
     *     // ... data to create a AgencySidebarOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencySidebarOption we want to update
     *   }
     * })
     */
    upsert<T extends AgencySidebarOptionUpsertArgs>(args: SelectSubset<T, AgencySidebarOptionUpsertArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgencySidebarOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionCountArgs} args - Arguments to filter AgencySidebarOptions to count.
     * @example
     * // Count the number of AgencySidebarOptions
     * const count = await prisma.agencySidebarOption.count({
     *   where: {
     *     // ... the filter for the AgencySidebarOptions we want to count
     *   }
     * })
    **/
    count<T extends AgencySidebarOptionCountArgs>(
      args?: Subset<T, AgencySidebarOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencySidebarOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencySidebarOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencySidebarOptionAggregateArgs>(args: Subset<T, AgencySidebarOptionAggregateArgs>): Prisma.PrismaPromise<GetAgencySidebarOptionAggregateType<T>>

    /**
     * Group by AgencySidebarOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencySidebarOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencySidebarOptionGroupByArgs['orderBy'] }
        : { orderBy?: AgencySidebarOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencySidebarOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencySidebarOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencySidebarOption model
   */
  readonly fields: AgencySidebarOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencySidebarOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencySidebarOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Agency<T extends AgencySidebarOption$AgencyArgs<ExtArgs> = {}>(args?: Subset<T, AgencySidebarOption$AgencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgencySidebarOption model
   */
  interface AgencySidebarOptionFieldRefs {
    readonly id: FieldRef<"AgencySidebarOption", 'String'>
    readonly name: FieldRef<"AgencySidebarOption", 'String'>
    readonly link: FieldRef<"AgencySidebarOption", 'String'>
    readonly icon: FieldRef<"AgencySidebarOption", 'Icon'>
    readonly agencyId: FieldRef<"AgencySidebarOption", 'String'>
    readonly createdAt: FieldRef<"AgencySidebarOption", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencySidebarOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgencySidebarOption findUnique
   */
  export type AgencySidebarOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which AgencySidebarOption to fetch.
     */
    where: AgencySidebarOptionWhereUniqueInput
  }

  /**
   * AgencySidebarOption findUniqueOrThrow
   */
  export type AgencySidebarOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which AgencySidebarOption to fetch.
     */
    where: AgencySidebarOptionWhereUniqueInput
  }

  /**
   * AgencySidebarOption findFirst
   */
  export type AgencySidebarOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which AgencySidebarOption to fetch.
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySidebarOptions to fetch.
     */
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencySidebarOptions.
     */
    cursor?: AgencySidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencySidebarOptions.
     */
    distinct?: AgencySidebarOptionScalarFieldEnum | AgencySidebarOptionScalarFieldEnum[]
  }

  /**
   * AgencySidebarOption findFirstOrThrow
   */
  export type AgencySidebarOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which AgencySidebarOption to fetch.
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySidebarOptions to fetch.
     */
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencySidebarOptions.
     */
    cursor?: AgencySidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencySidebarOptions.
     */
    distinct?: AgencySidebarOptionScalarFieldEnum | AgencySidebarOptionScalarFieldEnum[]
  }

  /**
   * AgencySidebarOption findMany
   */
  export type AgencySidebarOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which AgencySidebarOptions to fetch.
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySidebarOptions to fetch.
     */
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencySidebarOptions.
     */
    cursor?: AgencySidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySidebarOptions.
     */
    skip?: number
    distinct?: AgencySidebarOptionScalarFieldEnum | AgencySidebarOptionScalarFieldEnum[]
  }

  /**
   * AgencySidebarOption create
   */
  export type AgencySidebarOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencySidebarOption.
     */
    data: XOR<AgencySidebarOptionCreateInput, AgencySidebarOptionUncheckedCreateInput>
  }

  /**
   * AgencySidebarOption createMany
   */
  export type AgencySidebarOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencySidebarOptions.
     */
    data: AgencySidebarOptionCreateManyInput | AgencySidebarOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencySidebarOption update
   */
  export type AgencySidebarOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencySidebarOption.
     */
    data: XOR<AgencySidebarOptionUpdateInput, AgencySidebarOptionUncheckedUpdateInput>
    /**
     * Choose, which AgencySidebarOption to update.
     */
    where: AgencySidebarOptionWhereUniqueInput
  }

  /**
   * AgencySidebarOption updateMany
   */
  export type AgencySidebarOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencySidebarOptions.
     */
    data: XOR<AgencySidebarOptionUpdateManyMutationInput, AgencySidebarOptionUncheckedUpdateManyInput>
    /**
     * Filter which AgencySidebarOptions to update
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * Limit how many AgencySidebarOptions to update.
     */
    limit?: number
  }

  /**
   * AgencySidebarOption upsert
   */
  export type AgencySidebarOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencySidebarOption to update in case it exists.
     */
    where: AgencySidebarOptionWhereUniqueInput
    /**
     * In case the AgencySidebarOption found by the `where` argument doesn't exist, create a new AgencySidebarOption with this data.
     */
    create: XOR<AgencySidebarOptionCreateInput, AgencySidebarOptionUncheckedCreateInput>
    /**
     * In case the AgencySidebarOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencySidebarOptionUpdateInput, AgencySidebarOptionUncheckedUpdateInput>
  }

  /**
   * AgencySidebarOption delete
   */
  export type AgencySidebarOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter which AgencySidebarOption to delete.
     */
    where: AgencySidebarOptionWhereUniqueInput
  }

  /**
   * AgencySidebarOption deleteMany
   */
  export type AgencySidebarOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencySidebarOptions to delete
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * Limit how many AgencySidebarOptions to delete.
     */
    limit?: number
  }

  /**
   * AgencySidebarOption.Agency
   */
  export type AgencySidebarOption$AgencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * AgencySidebarOption without action
   */
  export type AgencySidebarOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
  }


  /**
   * Model SubAccountSidebarOption
   */

  export type AggregateSubAccountSidebarOption = {
    _count: SubAccountSidebarOptionCountAggregateOutputType | null
    _min: SubAccountSidebarOptionMinAggregateOutputType | null
    _max: SubAccountSidebarOptionMaxAggregateOutputType | null
  }

  export type SubAccountSidebarOptionMinAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
    icon: $Enums.Icon | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type SubAccountSidebarOptionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
    icon: $Enums.Icon | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type SubAccountSidebarOptionCountAggregateOutputType = {
    id: number
    name: number
    link: number
    icon: number
    createdAt: number
    updatedAt: number
    subAccountId: number
    _all: number
  }


  export type SubAccountSidebarOptionMinAggregateInputType = {
    id?: true
    name?: true
    link?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type SubAccountSidebarOptionMaxAggregateInputType = {
    id?: true
    name?: true
    link?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type SubAccountSidebarOptionCountAggregateInputType = {
    id?: true
    name?: true
    link?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
    _all?: true
  }

  export type SubAccountSidebarOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccountSidebarOption to aggregate.
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccountSidebarOptions to fetch.
     */
    orderBy?: SubAccountSidebarOptionOrderByWithRelationInput | SubAccountSidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubAccountSidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccountSidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccountSidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubAccountSidebarOptions
    **/
    _count?: true | SubAccountSidebarOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubAccountSidebarOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubAccountSidebarOptionMaxAggregateInputType
  }

  export type GetSubAccountSidebarOptionAggregateType<T extends SubAccountSidebarOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubAccountSidebarOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubAccountSidebarOption[P]>
      : GetScalarType<T[P], AggregateSubAccountSidebarOption[P]>
  }




  export type SubAccountSidebarOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountSidebarOptionWhereInput
    orderBy?: SubAccountSidebarOptionOrderByWithAggregationInput | SubAccountSidebarOptionOrderByWithAggregationInput[]
    by: SubAccountSidebarOptionScalarFieldEnum[] | SubAccountSidebarOptionScalarFieldEnum
    having?: SubAccountSidebarOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubAccountSidebarOptionCountAggregateInputType | true
    _min?: SubAccountSidebarOptionMinAggregateInputType
    _max?: SubAccountSidebarOptionMaxAggregateInputType
  }

  export type SubAccountSidebarOptionGroupByOutputType = {
    id: string
    name: string
    link: string
    icon: $Enums.Icon
    createdAt: Date
    updatedAt: Date
    subAccountId: string | null
    _count: SubAccountSidebarOptionCountAggregateOutputType | null
    _min: SubAccountSidebarOptionMinAggregateOutputType | null
    _max: SubAccountSidebarOptionMaxAggregateOutputType | null
  }

  type GetSubAccountSidebarOptionGroupByPayload<T extends SubAccountSidebarOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubAccountSidebarOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubAccountSidebarOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubAccountSidebarOptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubAccountSidebarOptionGroupByOutputType[P]>
        }
      >
    >


  export type SubAccountSidebarOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    SubAccount?: boolean | SubAccountSidebarOption$SubAccountArgs<ExtArgs>
  }, ExtArgs["result"]["subAccountSidebarOption"]>



  export type SubAccountSidebarOptionSelectScalar = {
    id?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
  }

  export type SubAccountSidebarOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "link" | "icon" | "createdAt" | "updatedAt" | "subAccountId", ExtArgs["result"]["subAccountSidebarOption"]>
  export type SubAccountSidebarOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccount?: boolean | SubAccountSidebarOption$SubAccountArgs<ExtArgs>
  }

  export type $SubAccountSidebarOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubAccountSidebarOption"
    objects: {
      SubAccount: Prisma.$SubAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      link: string
      icon: $Enums.Icon
      createdAt: Date
      updatedAt: Date
      subAccountId: string | null
    }, ExtArgs["result"]["subAccountSidebarOption"]>
    composites: {}
  }

  type SubAccountSidebarOptionGetPayload<S extends boolean | null | undefined | SubAccountSidebarOptionDefaultArgs> = $Result.GetResult<Prisma.$SubAccountSidebarOptionPayload, S>

  type SubAccountSidebarOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubAccountSidebarOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubAccountSidebarOptionCountAggregateInputType | true
    }

  export interface SubAccountSidebarOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubAccountSidebarOption'], meta: { name: 'SubAccountSidebarOption' } }
    /**
     * Find zero or one SubAccountSidebarOption that matches the filter.
     * @param {SubAccountSidebarOptionFindUniqueArgs} args - Arguments to find a SubAccountSidebarOption
     * @example
     * // Get one SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubAccountSidebarOptionFindUniqueArgs>(args: SelectSubset<T, SubAccountSidebarOptionFindUniqueArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubAccountSidebarOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubAccountSidebarOptionFindUniqueOrThrowArgs} args - Arguments to find a SubAccountSidebarOption
     * @example
     * // Get one SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubAccountSidebarOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubAccountSidebarOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubAccountSidebarOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionFindFirstArgs} args - Arguments to find a SubAccountSidebarOption
     * @example
     * // Get one SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubAccountSidebarOptionFindFirstArgs>(args?: SelectSubset<T, SubAccountSidebarOptionFindFirstArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubAccountSidebarOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionFindFirstOrThrowArgs} args - Arguments to find a SubAccountSidebarOption
     * @example
     * // Get one SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubAccountSidebarOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubAccountSidebarOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubAccountSidebarOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubAccountSidebarOptions
     * const subAccountSidebarOptions = await prisma.subAccountSidebarOption.findMany()
     * 
     * // Get first 10 SubAccountSidebarOptions
     * const subAccountSidebarOptions = await prisma.subAccountSidebarOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subAccountSidebarOptionWithIdOnly = await prisma.subAccountSidebarOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubAccountSidebarOptionFindManyArgs>(args?: SelectSubset<T, SubAccountSidebarOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubAccountSidebarOption.
     * @param {SubAccountSidebarOptionCreateArgs} args - Arguments to create a SubAccountSidebarOption.
     * @example
     * // Create one SubAccountSidebarOption
     * const SubAccountSidebarOption = await prisma.subAccountSidebarOption.create({
     *   data: {
     *     // ... data to create a SubAccountSidebarOption
     *   }
     * })
     * 
     */
    create<T extends SubAccountSidebarOptionCreateArgs>(args: SelectSubset<T, SubAccountSidebarOptionCreateArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubAccountSidebarOptions.
     * @param {SubAccountSidebarOptionCreateManyArgs} args - Arguments to create many SubAccountSidebarOptions.
     * @example
     * // Create many SubAccountSidebarOptions
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubAccountSidebarOptionCreateManyArgs>(args?: SelectSubset<T, SubAccountSidebarOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubAccountSidebarOption.
     * @param {SubAccountSidebarOptionDeleteArgs} args - Arguments to delete one SubAccountSidebarOption.
     * @example
     * // Delete one SubAccountSidebarOption
     * const SubAccountSidebarOption = await prisma.subAccountSidebarOption.delete({
     *   where: {
     *     // ... filter to delete one SubAccountSidebarOption
     *   }
     * })
     * 
     */
    delete<T extends SubAccountSidebarOptionDeleteArgs>(args: SelectSubset<T, SubAccountSidebarOptionDeleteArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubAccountSidebarOption.
     * @param {SubAccountSidebarOptionUpdateArgs} args - Arguments to update one SubAccountSidebarOption.
     * @example
     * // Update one SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubAccountSidebarOptionUpdateArgs>(args: SelectSubset<T, SubAccountSidebarOptionUpdateArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubAccountSidebarOptions.
     * @param {SubAccountSidebarOptionDeleteManyArgs} args - Arguments to filter SubAccountSidebarOptions to delete.
     * @example
     * // Delete a few SubAccountSidebarOptions
     * const { count } = await prisma.subAccountSidebarOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubAccountSidebarOptionDeleteManyArgs>(args?: SelectSubset<T, SubAccountSidebarOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubAccountSidebarOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubAccountSidebarOptions
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubAccountSidebarOptionUpdateManyArgs>(args: SelectSubset<T, SubAccountSidebarOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubAccountSidebarOption.
     * @param {SubAccountSidebarOptionUpsertArgs} args - Arguments to update or create a SubAccountSidebarOption.
     * @example
     * // Update or create a SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.upsert({
     *   create: {
     *     // ... data to create a SubAccountSidebarOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubAccountSidebarOption we want to update
     *   }
     * })
     */
    upsert<T extends SubAccountSidebarOptionUpsertArgs>(args: SelectSubset<T, SubAccountSidebarOptionUpsertArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubAccountSidebarOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionCountArgs} args - Arguments to filter SubAccountSidebarOptions to count.
     * @example
     * // Count the number of SubAccountSidebarOptions
     * const count = await prisma.subAccountSidebarOption.count({
     *   where: {
     *     // ... the filter for the SubAccountSidebarOptions we want to count
     *   }
     * })
    **/
    count<T extends SubAccountSidebarOptionCountArgs>(
      args?: Subset<T, SubAccountSidebarOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubAccountSidebarOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubAccountSidebarOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubAccountSidebarOptionAggregateArgs>(args: Subset<T, SubAccountSidebarOptionAggregateArgs>): Prisma.PrismaPromise<GetSubAccountSidebarOptionAggregateType<T>>

    /**
     * Group by SubAccountSidebarOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubAccountSidebarOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubAccountSidebarOptionGroupByArgs['orderBy'] }
        : { orderBy?: SubAccountSidebarOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubAccountSidebarOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubAccountSidebarOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubAccountSidebarOption model
   */
  readonly fields: SubAccountSidebarOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubAccountSidebarOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubAccountSidebarOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SubAccount<T extends SubAccountSidebarOption$SubAccountArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountSidebarOption$SubAccountArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubAccountSidebarOption model
   */
  interface SubAccountSidebarOptionFieldRefs {
    readonly id: FieldRef<"SubAccountSidebarOption", 'String'>
    readonly name: FieldRef<"SubAccountSidebarOption", 'String'>
    readonly link: FieldRef<"SubAccountSidebarOption", 'String'>
    readonly icon: FieldRef<"SubAccountSidebarOption", 'Icon'>
    readonly createdAt: FieldRef<"SubAccountSidebarOption", 'DateTime'>
    readonly updatedAt: FieldRef<"SubAccountSidebarOption", 'DateTime'>
    readonly subAccountId: FieldRef<"SubAccountSidebarOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubAccountSidebarOption findUnique
   */
  export type SubAccountSidebarOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which SubAccountSidebarOption to fetch.
     */
    where: SubAccountSidebarOptionWhereUniqueInput
  }

  /**
   * SubAccountSidebarOption findUniqueOrThrow
   */
  export type SubAccountSidebarOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which SubAccountSidebarOption to fetch.
     */
    where: SubAccountSidebarOptionWhereUniqueInput
  }

  /**
   * SubAccountSidebarOption findFirst
   */
  export type SubAccountSidebarOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which SubAccountSidebarOption to fetch.
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccountSidebarOptions to fetch.
     */
    orderBy?: SubAccountSidebarOptionOrderByWithRelationInput | SubAccountSidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccountSidebarOptions.
     */
    cursor?: SubAccountSidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccountSidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccountSidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccountSidebarOptions.
     */
    distinct?: SubAccountSidebarOptionScalarFieldEnum | SubAccountSidebarOptionScalarFieldEnum[]
  }

  /**
   * SubAccountSidebarOption findFirstOrThrow
   */
  export type SubAccountSidebarOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which SubAccountSidebarOption to fetch.
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccountSidebarOptions to fetch.
     */
    orderBy?: SubAccountSidebarOptionOrderByWithRelationInput | SubAccountSidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccountSidebarOptions.
     */
    cursor?: SubAccountSidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccountSidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccountSidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccountSidebarOptions.
     */
    distinct?: SubAccountSidebarOptionScalarFieldEnum | SubAccountSidebarOptionScalarFieldEnum[]
  }

  /**
   * SubAccountSidebarOption findMany
   */
  export type SubAccountSidebarOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which SubAccountSidebarOptions to fetch.
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccountSidebarOptions to fetch.
     */
    orderBy?: SubAccountSidebarOptionOrderByWithRelationInput | SubAccountSidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubAccountSidebarOptions.
     */
    cursor?: SubAccountSidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccountSidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccountSidebarOptions.
     */
    skip?: number
    distinct?: SubAccountSidebarOptionScalarFieldEnum | SubAccountSidebarOptionScalarFieldEnum[]
  }

  /**
   * SubAccountSidebarOption create
   */
  export type SubAccountSidebarOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a SubAccountSidebarOption.
     */
    data: XOR<SubAccountSidebarOptionCreateInput, SubAccountSidebarOptionUncheckedCreateInput>
  }

  /**
   * SubAccountSidebarOption createMany
   */
  export type SubAccountSidebarOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubAccountSidebarOptions.
     */
    data: SubAccountSidebarOptionCreateManyInput | SubAccountSidebarOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubAccountSidebarOption update
   */
  export type SubAccountSidebarOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a SubAccountSidebarOption.
     */
    data: XOR<SubAccountSidebarOptionUpdateInput, SubAccountSidebarOptionUncheckedUpdateInput>
    /**
     * Choose, which SubAccountSidebarOption to update.
     */
    where: SubAccountSidebarOptionWhereUniqueInput
  }

  /**
   * SubAccountSidebarOption updateMany
   */
  export type SubAccountSidebarOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubAccountSidebarOptions.
     */
    data: XOR<SubAccountSidebarOptionUpdateManyMutationInput, SubAccountSidebarOptionUncheckedUpdateManyInput>
    /**
     * Filter which SubAccountSidebarOptions to update
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * Limit how many SubAccountSidebarOptions to update.
     */
    limit?: number
  }

  /**
   * SubAccountSidebarOption upsert
   */
  export type SubAccountSidebarOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the SubAccountSidebarOption to update in case it exists.
     */
    where: SubAccountSidebarOptionWhereUniqueInput
    /**
     * In case the SubAccountSidebarOption found by the `where` argument doesn't exist, create a new SubAccountSidebarOption with this data.
     */
    create: XOR<SubAccountSidebarOptionCreateInput, SubAccountSidebarOptionUncheckedCreateInput>
    /**
     * In case the SubAccountSidebarOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubAccountSidebarOptionUpdateInput, SubAccountSidebarOptionUncheckedUpdateInput>
  }

  /**
   * SubAccountSidebarOption delete
   */
  export type SubAccountSidebarOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter which SubAccountSidebarOption to delete.
     */
    where: SubAccountSidebarOptionWhereUniqueInput
  }

  /**
   * SubAccountSidebarOption deleteMany
   */
  export type SubAccountSidebarOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccountSidebarOptions to delete
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * Limit how many SubAccountSidebarOptions to delete.
     */
    limit?: number
  }

  /**
   * SubAccountSidebarOption.SubAccount
   */
  export type SubAccountSidebarOption$SubAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    where?: SubAccountWhereInput
  }

  /**
   * SubAccountSidebarOption without action
   */
  export type SubAccountSidebarOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
  }


  /**
   * Model Invitation
   */

  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationMinAggregateOutputType = {
    id: string | null
    email: string | null
    agencyId: string | null
    status: $Enums.InvitationStatus | null
    role: $Enums.Role | null
  }

  export type InvitationMaxAggregateOutputType = {
    id: string | null
    email: string | null
    agencyId: string | null
    status: $Enums.InvitationStatus | null
    role: $Enums.Role | null
  }

  export type InvitationCountAggregateOutputType = {
    id: number
    email: number
    agencyId: number
    status: number
    role: number
    _all: number
  }


  export type InvitationMinAggregateInputType = {
    id?: true
    email?: true
    agencyId?: true
    status?: true
    role?: true
  }

  export type InvitationMaxAggregateInputType = {
    id?: true
    email?: true
    agencyId?: true
    status?: true
    role?: true
  }

  export type InvitationCountAggregateInputType = {
    id?: true
    email?: true
    agencyId?: true
    status?: true
    role?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type InvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithAggregationInput | InvitationOrderByWithAggregationInput[]
    by: InvitationScalarFieldEnum[] | InvitationScalarFieldEnum
    having?: InvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }

  export type InvitationGroupByOutputType = {
    id: string
    email: string
    agencyId: string
    status: $Enums.InvitationStatus
    role: $Enums.Role
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type InvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    agencyId?: boolean
    status?: boolean
    role?: boolean
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>



  export type InvitationSelectScalar = {
    id?: boolean
    email?: boolean
    agencyId?: boolean
    status?: boolean
    role?: boolean
  }

  export type InvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "agencyId" | "status" | "role", ExtArgs["result"]["invitation"]>
  export type InvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }

  export type $InvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invitation"
    objects: {
      Agency: Prisma.$AgencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      agencyId: string
      status: $Enums.InvitationStatus
      role: $Enums.Role
    }, ExtArgs["result"]["invitation"]>
    composites: {}
  }

  type InvitationGetPayload<S extends boolean | null | undefined | InvitationDefaultArgs> = $Result.GetResult<Prisma.$InvitationPayload, S>

  type InvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface InvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitation'], meta: { name: 'Invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationFindUniqueArgs>(args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationFindFirstArgs>(args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationFindManyArgs>(args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
     */
    create<T extends InvitationCreateArgs>(args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationCreateManyArgs>(args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
     */
    delete<T extends InvitationDeleteArgs>(args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationUpdateArgs>(args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationDeleteManyArgs>(args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationUpdateManyArgs>(args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
     */
    upsert<T extends InvitationUpsertArgs>(args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invitation model
   */
  readonly fields: InvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invitation model
   */
  interface InvitationFieldRefs {
    readonly id: FieldRef<"Invitation", 'String'>
    readonly email: FieldRef<"Invitation", 'String'>
    readonly agencyId: FieldRef<"Invitation", 'String'>
    readonly status: FieldRef<"Invitation", 'InvitationStatus'>
    readonly role: FieldRef<"Invitation", 'Role'>
  }
    

  // Custom InputTypes
  /**
   * Invitation findUnique
   */
  export type InvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findFirst
   */
  export type InvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation create
   */
  export type InvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
  }

  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
  }

  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
  }

  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to delete.
     */
    limit?: number
  }

  /**
   * Invitation without action
   */
  export type InvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    notification: string | null
    agencyId: string | null
    subAccountId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    notification: string | null
    agencyId: string | null
    subAccountId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    notification: number
    agencyId: number
    subAccountId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    notification?: true
    agencyId?: true
    subAccountId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    notification?: true
    agencyId?: true
    subAccountId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    notification?: true
    agencyId?: true
    subAccountId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    notification: string
    agencyId: string
    subAccountId: string | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notification?: boolean
    agencyId?: boolean
    subAccountId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SubAccount?: boolean | Notification$SubAccountArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    notification?: boolean
    agencyId?: boolean
    subAccountId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "notification" | "agencyId" | "subAccountId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SubAccount?: boolean | Notification$SubAccountArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Agency: Prisma.$AgencyPayload<ExtArgs>
      SubAccount: Prisma.$SubAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      notification: string
      agencyId: string
      subAccountId: string | null
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    SubAccount<T extends Notification$SubAccountArgs<ExtArgs> = {}>(args?: Subset<T, Notification$SubAccountArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly notification: FieldRef<"Notification", 'String'>
    readonly agencyId: FieldRef<"Notification", 'String'>
    readonly subAccountId: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.SubAccount
   */
  export type Notification$SubAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    where?: SubAccountWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    plan: $Enums.Plan | null
    price: string | null
    active: boolean | null
    priceId: string | null
    customerId: string | null
    currentPeriodEndDate: Date | null
    subscriptionId: string | null
    agencyId: string | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    plan: $Enums.Plan | null
    price: string | null
    active: boolean | null
    priceId: string | null
    customerId: string | null
    currentPeriodEndDate: Date | null
    subscriptionId: string | null
    agencyId: string | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    plan: number
    price: number
    active: number
    priceId: number
    customerId: number
    currentPeriodEndDate: number
    subscriptionId: number
    agencyId: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    plan?: true
    price?: true
    active?: true
    priceId?: true
    customerId?: true
    currentPeriodEndDate?: true
    subscriptionId?: true
    agencyId?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    plan?: true
    price?: true
    active?: true
    priceId?: true
    customerId?: true
    currentPeriodEndDate?: true
    subscriptionId?: true
    agencyId?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    plan?: true
    price?: true
    active?: true
    priceId?: true
    customerId?: true
    currentPeriodEndDate?: true
    subscriptionId?: true
    agencyId?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    plan: $Enums.Plan | null
    price: string | null
    active: boolean
    priceId: string | null
    customerId: string | null
    currentPeriodEndDate: Date | null
    subscriptionId: string
    agencyId: string | null
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean
    price?: boolean
    active?: boolean
    priceId?: boolean
    customerId?: boolean
    currentPeriodEndDate?: boolean
    subscriptionId?: boolean
    agencyId?: boolean
    Agency?: boolean | Subscription$AgencyArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>



  export type SubscriptionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean
    price?: boolean
    active?: boolean
    priceId?: boolean
    customerId?: boolean
    currentPeriodEndDate?: boolean
    subscriptionId?: boolean
    agencyId?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "plan" | "price" | "active" | "priceId" | "customerId" | "currentPeriodEndDate" | "subscriptionId" | "agencyId", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | Subscription$AgencyArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      Agency: Prisma.$AgencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      plan: $Enums.Plan | null
      price: string | null
      active: boolean
      priceId: string | null
      customerId: string | null
      currentPeriodEndDate: Date | null
      subscriptionId: string
      agencyId: string | null
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Agency<T extends Subscription$AgencyArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$AgencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
    readonly plan: FieldRef<"Subscription", 'Plan'>
    readonly price: FieldRef<"Subscription", 'String'>
    readonly active: FieldRef<"Subscription", 'Boolean'>
    readonly priceId: FieldRef<"Subscription", 'String'>
    readonly customerId: FieldRef<"Subscription", 'String'>
    readonly currentPeriodEndDate: FieldRef<"Subscription", 'DateTime'>
    readonly subscriptionId: FieldRef<"Subscription", 'String'>
    readonly agencyId: FieldRef<"Subscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.Agency
   */
  export type Subscription$AgencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model AddOns
   */

  export type AggregateAddOns = {
    _count: AddOnsCountAggregateOutputType | null
    _min: AddOnsMinAggregateOutputType | null
    _max: AddOnsMaxAggregateOutputType | null
  }

  export type AddOnsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    active: boolean | null
    priceId: string | null
    agencyId: string | null
  }

  export type AddOnsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    active: boolean | null
    priceId: string | null
    agencyId: string | null
  }

  export type AddOnsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    active: number
    priceId: number
    agencyId: number
    _all: number
  }


  export type AddOnsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    active?: true
    priceId?: true
    agencyId?: true
  }

  export type AddOnsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    active?: true
    priceId?: true
    agencyId?: true
  }

  export type AddOnsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    active?: true
    priceId?: true
    agencyId?: true
    _all?: true
  }

  export type AddOnsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddOns to aggregate.
     */
    where?: AddOnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnsOrderByWithRelationInput | AddOnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddOnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddOns
    **/
    _count?: true | AddOnsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddOnsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddOnsMaxAggregateInputType
  }

  export type GetAddOnsAggregateType<T extends AddOnsAggregateArgs> = {
        [P in keyof T & keyof AggregateAddOns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddOns[P]>
      : GetScalarType<T[P], AggregateAddOns[P]>
  }




  export type AddOnsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddOnsWhereInput
    orderBy?: AddOnsOrderByWithAggregationInput | AddOnsOrderByWithAggregationInput[]
    by: AddOnsScalarFieldEnum[] | AddOnsScalarFieldEnum
    having?: AddOnsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddOnsCountAggregateInputType | true
    _min?: AddOnsMinAggregateInputType
    _max?: AddOnsMaxAggregateInputType
  }

  export type AddOnsGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    active: boolean
    priceId: string
    agencyId: string | null
    _count: AddOnsCountAggregateOutputType | null
    _min: AddOnsMinAggregateOutputType | null
    _max: AddOnsMaxAggregateOutputType | null
  }

  type GetAddOnsGroupByPayload<T extends AddOnsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddOnsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddOnsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddOnsGroupByOutputType[P]>
            : GetScalarType<T[P], AddOnsGroupByOutputType[P]>
        }
      >
    >


  export type AddOnsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    active?: boolean
    priceId?: boolean
    agencyId?: boolean
    Agency?: boolean | AddOns$AgencyArgs<ExtArgs>
  }, ExtArgs["result"]["addOns"]>



  export type AddOnsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    active?: boolean
    priceId?: boolean
    agencyId?: boolean
  }

  export type AddOnsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "active" | "priceId" | "agencyId", ExtArgs["result"]["addOns"]>
  export type AddOnsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AddOns$AgencyArgs<ExtArgs>
  }

  export type $AddOnsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddOns"
    objects: {
      Agency: Prisma.$AgencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      active: boolean
      priceId: string
      agencyId: string | null
    }, ExtArgs["result"]["addOns"]>
    composites: {}
  }

  type AddOnsGetPayload<S extends boolean | null | undefined | AddOnsDefaultArgs> = $Result.GetResult<Prisma.$AddOnsPayload, S>

  type AddOnsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddOnsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddOnsCountAggregateInputType | true
    }

  export interface AddOnsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddOns'], meta: { name: 'AddOns' } }
    /**
     * Find zero or one AddOns that matches the filter.
     * @param {AddOnsFindUniqueArgs} args - Arguments to find a AddOns
     * @example
     * // Get one AddOns
     * const addOns = await prisma.addOns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddOnsFindUniqueArgs>(args: SelectSubset<T, AddOnsFindUniqueArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddOns that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddOnsFindUniqueOrThrowArgs} args - Arguments to find a AddOns
     * @example
     * // Get one AddOns
     * const addOns = await prisma.addOns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddOnsFindUniqueOrThrowArgs>(args: SelectSubset<T, AddOnsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddOns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsFindFirstArgs} args - Arguments to find a AddOns
     * @example
     * // Get one AddOns
     * const addOns = await prisma.addOns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddOnsFindFirstArgs>(args?: SelectSubset<T, AddOnsFindFirstArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddOns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsFindFirstOrThrowArgs} args - Arguments to find a AddOns
     * @example
     * // Get one AddOns
     * const addOns = await prisma.addOns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddOnsFindFirstOrThrowArgs>(args?: SelectSubset<T, AddOnsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddOns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddOns
     * const addOns = await prisma.addOns.findMany()
     * 
     * // Get first 10 AddOns
     * const addOns = await prisma.addOns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addOnsWithIdOnly = await prisma.addOns.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddOnsFindManyArgs>(args?: SelectSubset<T, AddOnsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddOns.
     * @param {AddOnsCreateArgs} args - Arguments to create a AddOns.
     * @example
     * // Create one AddOns
     * const AddOns = await prisma.addOns.create({
     *   data: {
     *     // ... data to create a AddOns
     *   }
     * })
     * 
     */
    create<T extends AddOnsCreateArgs>(args: SelectSubset<T, AddOnsCreateArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddOns.
     * @param {AddOnsCreateManyArgs} args - Arguments to create many AddOns.
     * @example
     * // Create many AddOns
     * const addOns = await prisma.addOns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddOnsCreateManyArgs>(args?: SelectSubset<T, AddOnsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AddOns.
     * @param {AddOnsDeleteArgs} args - Arguments to delete one AddOns.
     * @example
     * // Delete one AddOns
     * const AddOns = await prisma.addOns.delete({
     *   where: {
     *     // ... filter to delete one AddOns
     *   }
     * })
     * 
     */
    delete<T extends AddOnsDeleteArgs>(args: SelectSubset<T, AddOnsDeleteArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddOns.
     * @param {AddOnsUpdateArgs} args - Arguments to update one AddOns.
     * @example
     * // Update one AddOns
     * const addOns = await prisma.addOns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddOnsUpdateArgs>(args: SelectSubset<T, AddOnsUpdateArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddOns.
     * @param {AddOnsDeleteManyArgs} args - Arguments to filter AddOns to delete.
     * @example
     * // Delete a few AddOns
     * const { count } = await prisma.addOns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddOnsDeleteManyArgs>(args?: SelectSubset<T, AddOnsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddOns
     * const addOns = await prisma.addOns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddOnsUpdateManyArgs>(args: SelectSubset<T, AddOnsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddOns.
     * @param {AddOnsUpsertArgs} args - Arguments to update or create a AddOns.
     * @example
     * // Update or create a AddOns
     * const addOns = await prisma.addOns.upsert({
     *   create: {
     *     // ... data to create a AddOns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddOns we want to update
     *   }
     * })
     */
    upsert<T extends AddOnsUpsertArgs>(args: SelectSubset<T, AddOnsUpsertArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsCountArgs} args - Arguments to filter AddOns to count.
     * @example
     * // Count the number of AddOns
     * const count = await prisma.addOns.count({
     *   where: {
     *     // ... the filter for the AddOns we want to count
     *   }
     * })
    **/
    count<T extends AddOnsCountArgs>(
      args?: Subset<T, AddOnsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddOnsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddOnsAggregateArgs>(args: Subset<T, AddOnsAggregateArgs>): Prisma.PrismaPromise<GetAddOnsAggregateType<T>>

    /**
     * Group by AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddOnsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddOnsGroupByArgs['orderBy'] }
        : { orderBy?: AddOnsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddOnsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddOnsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddOns model
   */
  readonly fields: AddOnsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddOns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddOnsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Agency<T extends AddOns$AgencyArgs<ExtArgs> = {}>(args?: Subset<T, AddOns$AgencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddOns model
   */
  interface AddOnsFieldRefs {
    readonly id: FieldRef<"AddOns", 'String'>
    readonly createdAt: FieldRef<"AddOns", 'DateTime'>
    readonly updatedAt: FieldRef<"AddOns", 'DateTime'>
    readonly name: FieldRef<"AddOns", 'String'>
    readonly active: FieldRef<"AddOns", 'Boolean'>
    readonly priceId: FieldRef<"AddOns", 'String'>
    readonly agencyId: FieldRef<"AddOns", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AddOns findUnique
   */
  export type AddOnsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where: AddOnsWhereUniqueInput
  }

  /**
   * AddOns findUniqueOrThrow
   */
  export type AddOnsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where: AddOnsWhereUniqueInput
  }

  /**
   * AddOns findFirst
   */
  export type AddOnsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where?: AddOnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnsOrderByWithRelationInput | AddOnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddOns.
     */
    cursor?: AddOnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddOns.
     */
    distinct?: AddOnsScalarFieldEnum | AddOnsScalarFieldEnum[]
  }

  /**
   * AddOns findFirstOrThrow
   */
  export type AddOnsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where?: AddOnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnsOrderByWithRelationInput | AddOnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddOns.
     */
    cursor?: AddOnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddOns.
     */
    distinct?: AddOnsScalarFieldEnum | AddOnsScalarFieldEnum[]
  }

  /**
   * AddOns findMany
   */
  export type AddOnsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where?: AddOnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnsOrderByWithRelationInput | AddOnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddOns.
     */
    cursor?: AddOnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    distinct?: AddOnsScalarFieldEnum | AddOnsScalarFieldEnum[]
  }

  /**
   * AddOns create
   */
  export type AddOnsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * The data needed to create a AddOns.
     */
    data: XOR<AddOnsCreateInput, AddOnsUncheckedCreateInput>
  }

  /**
   * AddOns createMany
   */
  export type AddOnsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddOns.
     */
    data: AddOnsCreateManyInput | AddOnsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddOns update
   */
  export type AddOnsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * The data needed to update a AddOns.
     */
    data: XOR<AddOnsUpdateInput, AddOnsUncheckedUpdateInput>
    /**
     * Choose, which AddOns to update.
     */
    where: AddOnsWhereUniqueInput
  }

  /**
   * AddOns updateMany
   */
  export type AddOnsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddOns.
     */
    data: XOR<AddOnsUpdateManyMutationInput, AddOnsUncheckedUpdateManyInput>
    /**
     * Filter which AddOns to update
     */
    where?: AddOnsWhereInput
    /**
     * Limit how many AddOns to update.
     */
    limit?: number
  }

  /**
   * AddOns upsert
   */
  export type AddOnsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * The filter to search for the AddOns to update in case it exists.
     */
    where: AddOnsWhereUniqueInput
    /**
     * In case the AddOns found by the `where` argument doesn't exist, create a new AddOns with this data.
     */
    create: XOR<AddOnsCreateInput, AddOnsUncheckedCreateInput>
    /**
     * In case the AddOns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddOnsUpdateInput, AddOnsUncheckedUpdateInput>
  }

  /**
   * AddOns delete
   */
  export type AddOnsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter which AddOns to delete.
     */
    where: AddOnsWhereUniqueInput
  }

  /**
   * AddOns deleteMany
   */
  export type AddOnsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddOns to delete
     */
    where?: AddOnsWhereInput
    /**
     * Limit how many AddOns to delete.
     */
    limit?: number
  }

  /**
   * AddOns.Agency
   */
  export type AddOns$AgencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * AddOns without action
   */
  export type AddOnsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    avatarUrl: 'avatarUrl',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    role: 'role',
    agencyId: 'agencyId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AgencyScalarFieldEnum: {
    id: 'id',
    connectAccountId: 'connectAccountId',
    customerId: 'customerId',
    name: 'name',
    agencyLogo: 'agencyLogo',
    companyEmail: 'companyEmail',
    companyPhone: 'companyPhone',
    whiteLabel: 'whiteLabel',
    address: 'address',
    city: 'city',
    zipCode: 'zipCode',
    state: 'state',
    country: 'country',
    goal: 'goal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyScalarFieldEnum = (typeof AgencyScalarFieldEnum)[keyof typeof AgencyScalarFieldEnum]


  export const PermissionsScalarFieldEnum: {
    id: 'id',
    email: 'email',
    subAccountId: 'subAccountId',
    access: 'access'
  };

  export type PermissionsScalarFieldEnum = (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum]


  export const SubAccountScalarFieldEnum: {
    id: 'id',
    connectAccountId: 'connectAccountId',
    name: 'name',
    subAccountLogo: 'subAccountLogo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyEmail: 'companyEmail',
    companyPhone: 'companyPhone',
    goal: 'goal',
    address: 'address',
    city: 'city',
    zipCode: 'zipCode',
    state: 'state',
    country: 'country',
    agencyId: 'agencyId'
  };

  export type SubAccountScalarFieldEnum = (typeof SubAccountScalarFieldEnum)[keyof typeof SubAccountScalarFieldEnum]


  export const TagsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subAccountId: 'subAccountId',
    ticketsId: 'ticketsId'
  };

  export type TagsScalarFieldEnum = (typeof TagsScalarFieldEnum)[keyof typeof TagsScalarFieldEnum]


  export const PipelineScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subAccountId: 'subAccountId'
  };

  export type PipelineScalarFieldEnum = (typeof PipelineScalarFieldEnum)[keyof typeof PipelineScalarFieldEnum]


  export const LaneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    pipelineId: 'pipelineId',
    order: 'order'
  };

  export type LaneScalarFieldEnum = (typeof LaneScalarFieldEnum)[keyof typeof LaneScalarFieldEnum]


  export const TicketsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    laneId: 'laneId',
    order: 'order',
    value: 'value',
    description: 'description',
    customerId: 'customerId',
    assignedUserId: 'assignedUserId'
  };

  export type TicketsScalarFieldEnum = (typeof TicketsScalarFieldEnum)[keyof typeof TicketsScalarFieldEnum]


  export const TriggerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subAccountId: 'subAccountId'
  };

  export type TriggerScalarFieldEnum = (typeof TriggerScalarFieldEnum)[keyof typeof TriggerScalarFieldEnum]


  export const AutomationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    triggerId: 'triggerId',
    published: 'published',
    subAccountId: 'subAccountId'
  };

  export type AutomationScalarFieldEnum = (typeof AutomationScalarFieldEnum)[keyof typeof AutomationScalarFieldEnum]


  export const AutomationInstanceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    automationId: 'automationId',
    active: 'active'
  };

  export type AutomationInstanceScalarFieldEnum = (typeof AutomationInstanceScalarFieldEnum)[keyof typeof AutomationInstanceScalarFieldEnum]


  export const ActionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    automationId: 'automationId',
    order: 'order',
    laneId: 'laneId'
  };

  export type ActionScalarFieldEnum = (typeof ActionScalarFieldEnum)[keyof typeof ActionScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subAccountId: 'subAccountId'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    link: 'link',
    subAccountId: 'subAccountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const FunnelsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description',
    published: 'published',
    subDomainName: 'subDomainName',
    favicon: 'favicon',
    subAccountId: 'subAccountId',
    liveProducts: 'liveProducts'
  };

  export type FunnelsScalarFieldEnum = (typeof FunnelsScalarFieldEnum)[keyof typeof FunnelsScalarFieldEnum]


  export const FunnelPagesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    pathName: 'pathName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    visits: 'visits',
    content: 'content',
    order: 'order',
    previewImage: 'previewImage',
    funnelId: 'funnelId'
  };

  export type FunnelPagesScalarFieldEnum = (typeof FunnelPagesScalarFieldEnum)[keyof typeof FunnelPagesScalarFieldEnum]


  export const ClassNameScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    funnelId: 'funnelId',
    customDate: 'customDate'
  };

  export type ClassNameScalarFieldEnum = (typeof ClassNameScalarFieldEnum)[keyof typeof ClassNameScalarFieldEnum]


  export const AgencySidebarOptionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    link: 'link',
    icon: 'icon',
    agencyId: 'agencyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencySidebarOptionScalarFieldEnum = (typeof AgencySidebarOptionScalarFieldEnum)[keyof typeof AgencySidebarOptionScalarFieldEnum]


  export const SubAccountSidebarOptionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    link: 'link',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subAccountId: 'subAccountId'
  };

  export type SubAccountSidebarOptionScalarFieldEnum = (typeof SubAccountSidebarOptionScalarFieldEnum)[keyof typeof SubAccountSidebarOptionScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    id: 'id',
    email: 'email',
    agencyId: 'agencyId',
    status: 'status',
    role: 'role'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    notification: 'notification',
    agencyId: 'agencyId',
    subAccountId: 'subAccountId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    plan: 'plan',
    price: 'price',
    active: 'active',
    priceId: 'priceId',
    customerId: 'customerId',
    currentPeriodEndDate: 'currentPeriodEndDate',
    subscriptionId: 'subscriptionId',
    agencyId: 'agencyId'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const AddOnsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    active: 'active',
    priceId: 'priceId',
    agencyId: 'agencyId'
  };

  export type AddOnsScalarFieldEnum = (typeof AddOnsScalarFieldEnum)[keyof typeof AddOnsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    avatarUrl: 'avatarUrl',
    email: 'email',
    agencyId: 'agencyId'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const AgencyOrderByRelevanceFieldEnum: {
    id: 'id',
    connectAccountId: 'connectAccountId',
    customerId: 'customerId',
    name: 'name',
    agencyLogo: 'agencyLogo',
    companyEmail: 'companyEmail',
    companyPhone: 'companyPhone',
    address: 'address',
    city: 'city',
    zipCode: 'zipCode',
    state: 'state',
    country: 'country'
  };

  export type AgencyOrderByRelevanceFieldEnum = (typeof AgencyOrderByRelevanceFieldEnum)[keyof typeof AgencyOrderByRelevanceFieldEnum]


  export const PermissionsOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    subAccountId: 'subAccountId'
  };

  export type PermissionsOrderByRelevanceFieldEnum = (typeof PermissionsOrderByRelevanceFieldEnum)[keyof typeof PermissionsOrderByRelevanceFieldEnum]


  export const SubAccountOrderByRelevanceFieldEnum: {
    id: 'id',
    connectAccountId: 'connectAccountId',
    name: 'name',
    subAccountLogo: 'subAccountLogo',
    companyEmail: 'companyEmail',
    companyPhone: 'companyPhone',
    address: 'address',
    city: 'city',
    zipCode: 'zipCode',
    state: 'state',
    country: 'country',
    agencyId: 'agencyId'
  };

  export type SubAccountOrderByRelevanceFieldEnum = (typeof SubAccountOrderByRelevanceFieldEnum)[keyof typeof SubAccountOrderByRelevanceFieldEnum]


  export const TagsOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    subAccountId: 'subAccountId',
    ticketsId: 'ticketsId'
  };

  export type TagsOrderByRelevanceFieldEnum = (typeof TagsOrderByRelevanceFieldEnum)[keyof typeof TagsOrderByRelevanceFieldEnum]


  export const PipelineOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    subAccountId: 'subAccountId'
  };

  export type PipelineOrderByRelevanceFieldEnum = (typeof PipelineOrderByRelevanceFieldEnum)[keyof typeof PipelineOrderByRelevanceFieldEnum]


  export const LaneOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    pipelineId: 'pipelineId'
  };

  export type LaneOrderByRelevanceFieldEnum = (typeof LaneOrderByRelevanceFieldEnum)[keyof typeof LaneOrderByRelevanceFieldEnum]


  export const TicketsOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    laneId: 'laneId',
    description: 'description',
    customerId: 'customerId',
    assignedUserId: 'assignedUserId'
  };

  export type TicketsOrderByRelevanceFieldEnum = (typeof TicketsOrderByRelevanceFieldEnum)[keyof typeof TicketsOrderByRelevanceFieldEnum]


  export const TriggerOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    subAccountId: 'subAccountId'
  };

  export type TriggerOrderByRelevanceFieldEnum = (typeof TriggerOrderByRelevanceFieldEnum)[keyof typeof TriggerOrderByRelevanceFieldEnum]


  export const AutomationOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    triggerId: 'triggerId',
    subAccountId: 'subAccountId'
  };

  export type AutomationOrderByRelevanceFieldEnum = (typeof AutomationOrderByRelevanceFieldEnum)[keyof typeof AutomationOrderByRelevanceFieldEnum]


  export const AutomationInstanceOrderByRelevanceFieldEnum: {
    id: 'id',
    automationId: 'automationId'
  };

  export type AutomationInstanceOrderByRelevanceFieldEnum = (typeof AutomationInstanceOrderByRelevanceFieldEnum)[keyof typeof AutomationInstanceOrderByRelevanceFieldEnum]


  export const ActionOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    automationId: 'automationId',
    laneId: 'laneId'
  };

  export type ActionOrderByRelevanceFieldEnum = (typeof ActionOrderByRelevanceFieldEnum)[keyof typeof ActionOrderByRelevanceFieldEnum]


  export const ContactOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    subAccountId: 'subAccountId'
  };

  export type ContactOrderByRelevanceFieldEnum = (typeof ContactOrderByRelevanceFieldEnum)[keyof typeof ContactOrderByRelevanceFieldEnum]


  export const MediaOrderByRelevanceFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    link: 'link',
    subAccountId: 'subAccountId'
  };

  export type MediaOrderByRelevanceFieldEnum = (typeof MediaOrderByRelevanceFieldEnum)[keyof typeof MediaOrderByRelevanceFieldEnum]


  export const FunnelsOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    subDomainName: 'subDomainName',
    favicon: 'favicon',
    subAccountId: 'subAccountId',
    liveProducts: 'liveProducts'
  };

  export type FunnelsOrderByRelevanceFieldEnum = (typeof FunnelsOrderByRelevanceFieldEnum)[keyof typeof FunnelsOrderByRelevanceFieldEnum]


  export const FunnelPagesOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    pathName: 'pathName',
    content: 'content',
    previewImage: 'previewImage',
    funnelId: 'funnelId'
  };

  export type FunnelPagesOrderByRelevanceFieldEnum = (typeof FunnelPagesOrderByRelevanceFieldEnum)[keyof typeof FunnelPagesOrderByRelevanceFieldEnum]


  export const ClassNameOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    funnelId: 'funnelId',
    customDate: 'customDate'
  };

  export type ClassNameOrderByRelevanceFieldEnum = (typeof ClassNameOrderByRelevanceFieldEnum)[keyof typeof ClassNameOrderByRelevanceFieldEnum]


  export const AgencySidebarOptionOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    link: 'link',
    agencyId: 'agencyId'
  };

  export type AgencySidebarOptionOrderByRelevanceFieldEnum = (typeof AgencySidebarOptionOrderByRelevanceFieldEnum)[keyof typeof AgencySidebarOptionOrderByRelevanceFieldEnum]


  export const SubAccountSidebarOptionOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    link: 'link',
    subAccountId: 'subAccountId'
  };

  export type SubAccountSidebarOptionOrderByRelevanceFieldEnum = (typeof SubAccountSidebarOptionOrderByRelevanceFieldEnum)[keyof typeof SubAccountSidebarOptionOrderByRelevanceFieldEnum]


  export const InvitationOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    agencyId: 'agencyId'
  };

  export type InvitationOrderByRelevanceFieldEnum = (typeof InvitationOrderByRelevanceFieldEnum)[keyof typeof InvitationOrderByRelevanceFieldEnum]


  export const NotificationOrderByRelevanceFieldEnum: {
    id: 'id',
    notification: 'notification',
    agencyId: 'agencyId',
    subAccountId: 'subAccountId',
    userId: 'userId'
  };

  export type NotificationOrderByRelevanceFieldEnum = (typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum]


  export const SubscriptionOrderByRelevanceFieldEnum: {
    id: 'id',
    price: 'price',
    priceId: 'priceId',
    customerId: 'customerId',
    subscriptionId: 'subscriptionId',
    agencyId: 'agencyId'
  };

  export type SubscriptionOrderByRelevanceFieldEnum = (typeof SubscriptionOrderByRelevanceFieldEnum)[keyof typeof SubscriptionOrderByRelevanceFieldEnum]


  export const AddOnsOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    priceId: 'priceId',
    agencyId: 'agencyId'
  };

  export type AddOnsOrderByRelevanceFieldEnum = (typeof AddOnsOrderByRelevanceFieldEnum)[keyof typeof AddOnsOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'TriggerTypes'
   */
  export type EnumTriggerTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerTypes'>
    


  /**
   * Reference to a field of type 'ActionType'
   */
  export type EnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType'>
    


  /**
   * Reference to a field of type 'Icon'
   */
  export type EnumIconFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Icon'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'Plan'
   */
  export type EnumPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plan'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    avatarUrl?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    agencyId?: StringNullableFilter<"User"> | string | null
    Agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    Permissions?: PermissionsListRelationFilter
    Tickets?: TicketsListRelationFilter
    Notification?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    Agency?: AgencyOrderByWithRelationInput
    Permissions?: PermissionsOrderByRelationAggregateInput
    Tickets?: TicketsOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    avatarUrl?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    agencyId?: StringNullableFilter<"User"> | string | null
    Agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    Permissions?: PermissionsListRelationFilter
    Tickets?: TicketsListRelationFilter
    Notification?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    avatarUrl?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    agencyId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type AgencyWhereInput = {
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    id?: StringFilter<"Agency"> | string
    connectAccountId?: StringNullableFilter<"Agency"> | string | null
    customerId?: StringNullableFilter<"Agency"> | string | null
    name?: StringFilter<"Agency"> | string
    agencyLogo?: StringFilter<"Agency"> | string
    companyEmail?: StringFilter<"Agency"> | string
    companyPhone?: StringFilter<"Agency"> | string
    whiteLabel?: BoolFilter<"Agency"> | boolean
    address?: StringFilter<"Agency"> | string
    city?: StringFilter<"Agency"> | string
    zipCode?: StringFilter<"Agency"> | string
    state?: StringFilter<"Agency"> | string
    country?: StringFilter<"Agency"> | string
    goal?: IntFilter<"Agency"> | number
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    users?: UserListRelationFilter
    SubAccount?: SubAccountListRelationFilter
    SidebarOption?: AgencySidebarOptionListRelationFilter
    Invitation?: InvitationListRelationFilter
    Notification?: NotificationListRelationFilter
    Subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    AddOns?: AddOnsListRelationFilter
  }

  export type AgencyOrderByWithRelationInput = {
    id?: SortOrder
    connectAccountId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    name?: SortOrder
    agencyLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    whiteLabel?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    goal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    SubAccount?: SubAccountOrderByRelationAggregateInput
    SidebarOption?: AgencySidebarOptionOrderByRelationAggregateInput
    Invitation?: InvitationOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
    Subscription?: SubscriptionOrderByWithRelationInput
    AddOns?: AddOnsOrderByRelationAggregateInput
    _relevance?: AgencyOrderByRelevanceInput
  }

  export type AgencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    connectAccountId?: StringNullableFilter<"Agency"> | string | null
    customerId?: StringNullableFilter<"Agency"> | string | null
    name?: StringFilter<"Agency"> | string
    agencyLogo?: StringFilter<"Agency"> | string
    companyEmail?: StringFilter<"Agency"> | string
    companyPhone?: StringFilter<"Agency"> | string
    whiteLabel?: BoolFilter<"Agency"> | boolean
    address?: StringFilter<"Agency"> | string
    city?: StringFilter<"Agency"> | string
    zipCode?: StringFilter<"Agency"> | string
    state?: StringFilter<"Agency"> | string
    country?: StringFilter<"Agency"> | string
    goal?: IntFilter<"Agency"> | number
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    users?: UserListRelationFilter
    SubAccount?: SubAccountListRelationFilter
    SidebarOption?: AgencySidebarOptionListRelationFilter
    Invitation?: InvitationListRelationFilter
    Notification?: NotificationListRelationFilter
    Subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    AddOns?: AddOnsListRelationFilter
  }, "id">

  export type AgencyOrderByWithAggregationInput = {
    id?: SortOrder
    connectAccountId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    name?: SortOrder
    agencyLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    whiteLabel?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    goal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyCountOrderByAggregateInput
    _avg?: AgencyAvgOrderByAggregateInput
    _max?: AgencyMaxOrderByAggregateInput
    _min?: AgencyMinOrderByAggregateInput
    _sum?: AgencySumOrderByAggregateInput
  }

  export type AgencyScalarWhereWithAggregatesInput = {
    AND?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    OR?: AgencyScalarWhereWithAggregatesInput[]
    NOT?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agency"> | string
    connectAccountId?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    name?: StringWithAggregatesFilter<"Agency"> | string
    agencyLogo?: StringWithAggregatesFilter<"Agency"> | string
    companyEmail?: StringWithAggregatesFilter<"Agency"> | string
    companyPhone?: StringWithAggregatesFilter<"Agency"> | string
    whiteLabel?: BoolWithAggregatesFilter<"Agency"> | boolean
    address?: StringWithAggregatesFilter<"Agency"> | string
    city?: StringWithAggregatesFilter<"Agency"> | string
    zipCode?: StringWithAggregatesFilter<"Agency"> | string
    state?: StringWithAggregatesFilter<"Agency"> | string
    country?: StringWithAggregatesFilter<"Agency"> | string
    goal?: IntWithAggregatesFilter<"Agency"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
  }

  export type PermissionsWhereInput = {
    AND?: PermissionsWhereInput | PermissionsWhereInput[]
    OR?: PermissionsWhereInput[]
    NOT?: PermissionsWhereInput | PermissionsWhereInput[]
    id?: StringFilter<"Permissions"> | string
    email?: StringFilter<"Permissions"> | string
    subAccountId?: StringFilter<"Permissions"> | string
    access?: BoolFilter<"Permissions"> | boolean
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    subAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
  }

  export type PermissionsOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    subAccountId?: SortOrder
    access?: SortOrder
    User?: UserOrderByWithRelationInput
    subAccount?: SubAccountOrderByWithRelationInput
    _relevance?: PermissionsOrderByRelevanceInput
  }

  export type PermissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PermissionsWhereInput | PermissionsWhereInput[]
    OR?: PermissionsWhereInput[]
    NOT?: PermissionsWhereInput | PermissionsWhereInput[]
    email?: StringFilter<"Permissions"> | string
    subAccountId?: StringFilter<"Permissions"> | string
    access?: BoolFilter<"Permissions"> | boolean
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    subAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
  }, "id">

  export type PermissionsOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    subAccountId?: SortOrder
    access?: SortOrder
    _count?: PermissionsCountOrderByAggregateInput
    _max?: PermissionsMaxOrderByAggregateInput
    _min?: PermissionsMinOrderByAggregateInput
  }

  export type PermissionsScalarWhereWithAggregatesInput = {
    AND?: PermissionsScalarWhereWithAggregatesInput | PermissionsScalarWhereWithAggregatesInput[]
    OR?: PermissionsScalarWhereWithAggregatesInput[]
    NOT?: PermissionsScalarWhereWithAggregatesInput | PermissionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permissions"> | string
    email?: StringWithAggregatesFilter<"Permissions"> | string
    subAccountId?: StringWithAggregatesFilter<"Permissions"> | string
    access?: BoolWithAggregatesFilter<"Permissions"> | boolean
  }

  export type SubAccountWhereInput = {
    AND?: SubAccountWhereInput | SubAccountWhereInput[]
    OR?: SubAccountWhereInput[]
    NOT?: SubAccountWhereInput | SubAccountWhereInput[]
    id?: StringFilter<"SubAccount"> | string
    connectAccountId?: StringNullableFilter<"SubAccount"> | string | null
    name?: StringFilter<"SubAccount"> | string
    subAccountLogo?: StringFilter<"SubAccount"> | string
    createdAt?: DateTimeFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccount"> | Date | string
    companyEmail?: StringFilter<"SubAccount"> | string
    companyPhone?: StringFilter<"SubAccount"> | string
    goal?: IntFilter<"SubAccount"> | number
    address?: StringFilter<"SubAccount"> | string
    city?: StringFilter<"SubAccount"> | string
    zipCode?: StringFilter<"SubAccount"> | string
    state?: StringFilter<"SubAccount"> | string
    country?: StringFilter<"SubAccount"> | string
    agencyId?: StringFilter<"SubAccount"> | string
    Agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    SidebarOption?: SubAccountSidebarOptionListRelationFilter
    Permissions?: PermissionsListRelationFilter
    Funnels?: FunnelsListRelationFilter
    Media?: MediaListRelationFilter
    Contact?: ContactListRelationFilter
    Trigger?: TriggerListRelationFilter
    Automation?: AutomationListRelationFilter
    Pipeline?: PipelineListRelationFilter
    Tags?: TagsListRelationFilter
    Notification?: NotificationListRelationFilter
  }

  export type SubAccountOrderByWithRelationInput = {
    id?: SortOrder
    connectAccountId?: SortOrderInput | SortOrder
    name?: SortOrder
    subAccountLogo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    goal?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    agencyId?: SortOrder
    Agency?: AgencyOrderByWithRelationInput
    SidebarOption?: SubAccountSidebarOptionOrderByRelationAggregateInput
    Permissions?: PermissionsOrderByRelationAggregateInput
    Funnels?: FunnelsOrderByRelationAggregateInput
    Media?: MediaOrderByRelationAggregateInput
    Contact?: ContactOrderByRelationAggregateInput
    Trigger?: TriggerOrderByRelationAggregateInput
    Automation?: AutomationOrderByRelationAggregateInput
    Pipeline?: PipelineOrderByRelationAggregateInput
    Tags?: TagsOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
    _relevance?: SubAccountOrderByRelevanceInput
  }

  export type SubAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubAccountWhereInput | SubAccountWhereInput[]
    OR?: SubAccountWhereInput[]
    NOT?: SubAccountWhereInput | SubAccountWhereInput[]
    connectAccountId?: StringNullableFilter<"SubAccount"> | string | null
    name?: StringFilter<"SubAccount"> | string
    subAccountLogo?: StringFilter<"SubAccount"> | string
    createdAt?: DateTimeFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccount"> | Date | string
    companyEmail?: StringFilter<"SubAccount"> | string
    companyPhone?: StringFilter<"SubAccount"> | string
    goal?: IntFilter<"SubAccount"> | number
    address?: StringFilter<"SubAccount"> | string
    city?: StringFilter<"SubAccount"> | string
    zipCode?: StringFilter<"SubAccount"> | string
    state?: StringFilter<"SubAccount"> | string
    country?: StringFilter<"SubAccount"> | string
    agencyId?: StringFilter<"SubAccount"> | string
    Agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    SidebarOption?: SubAccountSidebarOptionListRelationFilter
    Permissions?: PermissionsListRelationFilter
    Funnels?: FunnelsListRelationFilter
    Media?: MediaListRelationFilter
    Contact?: ContactListRelationFilter
    Trigger?: TriggerListRelationFilter
    Automation?: AutomationListRelationFilter
    Pipeline?: PipelineListRelationFilter
    Tags?: TagsListRelationFilter
    Notification?: NotificationListRelationFilter
  }, "id">

  export type SubAccountOrderByWithAggregationInput = {
    id?: SortOrder
    connectAccountId?: SortOrderInput | SortOrder
    name?: SortOrder
    subAccountLogo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    goal?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    agencyId?: SortOrder
    _count?: SubAccountCountOrderByAggregateInput
    _avg?: SubAccountAvgOrderByAggregateInput
    _max?: SubAccountMaxOrderByAggregateInput
    _min?: SubAccountMinOrderByAggregateInput
    _sum?: SubAccountSumOrderByAggregateInput
  }

  export type SubAccountScalarWhereWithAggregatesInput = {
    AND?: SubAccountScalarWhereWithAggregatesInput | SubAccountScalarWhereWithAggregatesInput[]
    OR?: SubAccountScalarWhereWithAggregatesInput[]
    NOT?: SubAccountScalarWhereWithAggregatesInput | SubAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubAccount"> | string
    connectAccountId?: StringNullableWithAggregatesFilter<"SubAccount"> | string | null
    name?: StringWithAggregatesFilter<"SubAccount"> | string
    subAccountLogo?: StringWithAggregatesFilter<"SubAccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubAccount"> | Date | string
    companyEmail?: StringWithAggregatesFilter<"SubAccount"> | string
    companyPhone?: StringWithAggregatesFilter<"SubAccount"> | string
    goal?: IntWithAggregatesFilter<"SubAccount"> | number
    address?: StringWithAggregatesFilter<"SubAccount"> | string
    city?: StringWithAggregatesFilter<"SubAccount"> | string
    zipCode?: StringWithAggregatesFilter<"SubAccount"> | string
    state?: StringWithAggregatesFilter<"SubAccount"> | string
    country?: StringWithAggregatesFilter<"SubAccount"> | string
    agencyId?: StringWithAggregatesFilter<"SubAccount"> | string
  }

  export type TagsWhereInput = {
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
    id?: StringFilter<"Tags"> | string
    name?: StringFilter<"Tags"> | string
    color?: StringFilter<"Tags"> | string
    createdAt?: DateTimeFilter<"Tags"> | Date | string
    updatedAt?: DateTimeFilter<"Tags"> | Date | string
    subAccountId?: StringFilter<"Tags"> | string
    ticketsId?: StringNullableFilter<"Tags"> | string | null
    SubAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    Tickets?: XOR<TicketsNullableScalarRelationFilter, TicketsWhereInput> | null
  }

  export type TagsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    ticketsId?: SortOrderInput | SortOrder
    SubAccount?: SubAccountOrderByWithRelationInput
    Tickets?: TicketsOrderByWithRelationInput
    _relevance?: TagsOrderByRelevanceInput
  }

  export type TagsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
    name?: StringFilter<"Tags"> | string
    color?: StringFilter<"Tags"> | string
    createdAt?: DateTimeFilter<"Tags"> | Date | string
    updatedAt?: DateTimeFilter<"Tags"> | Date | string
    subAccountId?: StringFilter<"Tags"> | string
    ticketsId?: StringNullableFilter<"Tags"> | string | null
    SubAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    Tickets?: XOR<TicketsNullableScalarRelationFilter, TicketsWhereInput> | null
  }, "id">

  export type TagsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    ticketsId?: SortOrderInput | SortOrder
    _count?: TagsCountOrderByAggregateInput
    _max?: TagsMaxOrderByAggregateInput
    _min?: TagsMinOrderByAggregateInput
  }

  export type TagsScalarWhereWithAggregatesInput = {
    AND?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    OR?: TagsScalarWhereWithAggregatesInput[]
    NOT?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tags"> | string
    name?: StringWithAggregatesFilter<"Tags"> | string
    color?: StringWithAggregatesFilter<"Tags"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tags"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tags"> | Date | string
    subAccountId?: StringWithAggregatesFilter<"Tags"> | string
    ticketsId?: StringNullableWithAggregatesFilter<"Tags"> | string | null
  }

  export type PipelineWhereInput = {
    AND?: PipelineWhereInput | PipelineWhereInput[]
    OR?: PipelineWhereInput[]
    NOT?: PipelineWhereInput | PipelineWhereInput[]
    id?: StringFilter<"Pipeline"> | string
    name?: StringFilter<"Pipeline"> | string
    createdAt?: DateTimeFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeFilter<"Pipeline"> | Date | string
    subAccountId?: StringFilter<"Pipeline"> | string
    Lane?: LaneListRelationFilter
    SubAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
  }

  export type PipelineOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    Lane?: LaneOrderByRelationAggregateInput
    SubAccount?: SubAccountOrderByWithRelationInput
    _relevance?: PipelineOrderByRelevanceInput
  }

  export type PipelineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PipelineWhereInput | PipelineWhereInput[]
    OR?: PipelineWhereInput[]
    NOT?: PipelineWhereInput | PipelineWhereInput[]
    name?: StringFilter<"Pipeline"> | string
    createdAt?: DateTimeFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeFilter<"Pipeline"> | Date | string
    subAccountId?: StringFilter<"Pipeline"> | string
    Lane?: LaneListRelationFilter
    SubAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
  }, "id">

  export type PipelineOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    _count?: PipelineCountOrderByAggregateInput
    _max?: PipelineMaxOrderByAggregateInput
    _min?: PipelineMinOrderByAggregateInput
  }

  export type PipelineScalarWhereWithAggregatesInput = {
    AND?: PipelineScalarWhereWithAggregatesInput | PipelineScalarWhereWithAggregatesInput[]
    OR?: PipelineScalarWhereWithAggregatesInput[]
    NOT?: PipelineScalarWhereWithAggregatesInput | PipelineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pipeline"> | string
    name?: StringWithAggregatesFilter<"Pipeline"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pipeline"> | Date | string
    subAccountId?: StringWithAggregatesFilter<"Pipeline"> | string
  }

  export type LaneWhereInput = {
    AND?: LaneWhereInput | LaneWhereInput[]
    OR?: LaneWhereInput[]
    NOT?: LaneWhereInput | LaneWhereInput[]
    id?: StringFilter<"Lane"> | string
    name?: StringFilter<"Lane"> | string
    createdAt?: DateTimeFilter<"Lane"> | Date | string
    updatedAt?: DateTimeFilter<"Lane"> | Date | string
    pipelineId?: StringFilter<"Lane"> | string
    order?: IntFilter<"Lane"> | number
    Pipeline?: XOR<PipelineScalarRelationFilter, PipelineWhereInput>
    Tickets?: TicketsListRelationFilter
  }

  export type LaneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    order?: SortOrder
    Pipeline?: PipelineOrderByWithRelationInput
    Tickets?: TicketsOrderByRelationAggregateInput
    _relevance?: LaneOrderByRelevanceInput
  }

  export type LaneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LaneWhereInput | LaneWhereInput[]
    OR?: LaneWhereInput[]
    NOT?: LaneWhereInput | LaneWhereInput[]
    name?: StringFilter<"Lane"> | string
    createdAt?: DateTimeFilter<"Lane"> | Date | string
    updatedAt?: DateTimeFilter<"Lane"> | Date | string
    pipelineId?: StringFilter<"Lane"> | string
    order?: IntFilter<"Lane"> | number
    Pipeline?: XOR<PipelineScalarRelationFilter, PipelineWhereInput>
    Tickets?: TicketsListRelationFilter
  }, "id">

  export type LaneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    order?: SortOrder
    _count?: LaneCountOrderByAggregateInput
    _avg?: LaneAvgOrderByAggregateInput
    _max?: LaneMaxOrderByAggregateInput
    _min?: LaneMinOrderByAggregateInput
    _sum?: LaneSumOrderByAggregateInput
  }

  export type LaneScalarWhereWithAggregatesInput = {
    AND?: LaneScalarWhereWithAggregatesInput | LaneScalarWhereWithAggregatesInput[]
    OR?: LaneScalarWhereWithAggregatesInput[]
    NOT?: LaneScalarWhereWithAggregatesInput | LaneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lane"> | string
    name?: StringWithAggregatesFilter<"Lane"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Lane"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lane"> | Date | string
    pipelineId?: StringWithAggregatesFilter<"Lane"> | string
    order?: IntWithAggregatesFilter<"Lane"> | number
  }

  export type TicketsWhereInput = {
    AND?: TicketsWhereInput | TicketsWhereInput[]
    OR?: TicketsWhereInput[]
    NOT?: TicketsWhereInput | TicketsWhereInput[]
    id?: StringFilter<"Tickets"> | string
    name?: StringFilter<"Tickets"> | string
    createdAt?: DateTimeFilter<"Tickets"> | Date | string
    updatedAt?: DateTimeFilter<"Tickets"> | Date | string
    laneId?: StringFilter<"Tickets"> | string
    order?: IntFilter<"Tickets"> | number
    value?: DecimalNullableFilter<"Tickets"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"Tickets"> | string | null
    customerId?: StringNullableFilter<"Tickets"> | string | null
    assignedUserId?: StringNullableFilter<"Tickets"> | string | null
    Lane?: XOR<LaneScalarRelationFilter, LaneWhereInput>
    Tags?: TagsListRelationFilter
    Customer?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    Assigned?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TicketsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laneId?: SortOrder
    order?: SortOrder
    value?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    assignedUserId?: SortOrderInput | SortOrder
    Lane?: LaneOrderByWithRelationInput
    Tags?: TagsOrderByRelationAggregateInput
    Customer?: ContactOrderByWithRelationInput
    Assigned?: UserOrderByWithRelationInput
    _relevance?: TicketsOrderByRelevanceInput
  }

  export type TicketsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketsWhereInput | TicketsWhereInput[]
    OR?: TicketsWhereInput[]
    NOT?: TicketsWhereInput | TicketsWhereInput[]
    name?: StringFilter<"Tickets"> | string
    createdAt?: DateTimeFilter<"Tickets"> | Date | string
    updatedAt?: DateTimeFilter<"Tickets"> | Date | string
    laneId?: StringFilter<"Tickets"> | string
    order?: IntFilter<"Tickets"> | number
    value?: DecimalNullableFilter<"Tickets"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"Tickets"> | string | null
    customerId?: StringNullableFilter<"Tickets"> | string | null
    assignedUserId?: StringNullableFilter<"Tickets"> | string | null
    Lane?: XOR<LaneScalarRelationFilter, LaneWhereInput>
    Tags?: TagsListRelationFilter
    Customer?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    Assigned?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type TicketsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laneId?: SortOrder
    order?: SortOrder
    value?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    assignedUserId?: SortOrderInput | SortOrder
    _count?: TicketsCountOrderByAggregateInput
    _avg?: TicketsAvgOrderByAggregateInput
    _max?: TicketsMaxOrderByAggregateInput
    _min?: TicketsMinOrderByAggregateInput
    _sum?: TicketsSumOrderByAggregateInput
  }

  export type TicketsScalarWhereWithAggregatesInput = {
    AND?: TicketsScalarWhereWithAggregatesInput | TicketsScalarWhereWithAggregatesInput[]
    OR?: TicketsScalarWhereWithAggregatesInput[]
    NOT?: TicketsScalarWhereWithAggregatesInput | TicketsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tickets"> | string
    name?: StringWithAggregatesFilter<"Tickets"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tickets"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tickets"> | Date | string
    laneId?: StringWithAggregatesFilter<"Tickets"> | string
    order?: IntWithAggregatesFilter<"Tickets"> | number
    value?: DecimalNullableWithAggregatesFilter<"Tickets"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableWithAggregatesFilter<"Tickets"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"Tickets"> | string | null
    assignedUserId?: StringNullableWithAggregatesFilter<"Tickets"> | string | null
  }

  export type TriggerWhereInput = {
    AND?: TriggerWhereInput | TriggerWhereInput[]
    OR?: TriggerWhereInput[]
    NOT?: TriggerWhereInput | TriggerWhereInput[]
    id?: StringFilter<"Trigger"> | string
    name?: StringFilter<"Trigger"> | string
    type?: EnumTriggerTypesFilter<"Trigger"> | $Enums.TriggerTypes
    createdAt?: DateTimeFilter<"Trigger"> | Date | string
    updatedAt?: DateTimeFilter<"Trigger"> | Date | string
    subAccountId?: StringFilter<"Trigger"> | string
    SubAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    Automation?: AutomationListRelationFilter
  }

  export type TriggerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    SubAccount?: SubAccountOrderByWithRelationInput
    Automation?: AutomationOrderByRelationAggregateInput
    _relevance?: TriggerOrderByRelevanceInput
  }

  export type TriggerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TriggerWhereInput | TriggerWhereInput[]
    OR?: TriggerWhereInput[]
    NOT?: TriggerWhereInput | TriggerWhereInput[]
    name?: StringFilter<"Trigger"> | string
    type?: EnumTriggerTypesFilter<"Trigger"> | $Enums.TriggerTypes
    createdAt?: DateTimeFilter<"Trigger"> | Date | string
    updatedAt?: DateTimeFilter<"Trigger"> | Date | string
    subAccountId?: StringFilter<"Trigger"> | string
    SubAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    Automation?: AutomationListRelationFilter
  }, "id">

  export type TriggerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    _count?: TriggerCountOrderByAggregateInput
    _max?: TriggerMaxOrderByAggregateInput
    _min?: TriggerMinOrderByAggregateInput
  }

  export type TriggerScalarWhereWithAggregatesInput = {
    AND?: TriggerScalarWhereWithAggregatesInput | TriggerScalarWhereWithAggregatesInput[]
    OR?: TriggerScalarWhereWithAggregatesInput[]
    NOT?: TriggerScalarWhereWithAggregatesInput | TriggerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trigger"> | string
    name?: StringWithAggregatesFilter<"Trigger"> | string
    type?: EnumTriggerTypesWithAggregatesFilter<"Trigger"> | $Enums.TriggerTypes
    createdAt?: DateTimeWithAggregatesFilter<"Trigger"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Trigger"> | Date | string
    subAccountId?: StringWithAggregatesFilter<"Trigger"> | string
  }

  export type AutomationWhereInput = {
    AND?: AutomationWhereInput | AutomationWhereInput[]
    OR?: AutomationWhereInput[]
    NOT?: AutomationWhereInput | AutomationWhereInput[]
    id?: StringFilter<"Automation"> | string
    name?: StringFilter<"Automation"> | string
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    triggerId?: StringNullableFilter<"Automation"> | string | null
    published?: BoolFilter<"Automation"> | boolean
    subAccountId?: StringFilter<"Automation"> | string
    Trigger?: XOR<TriggerNullableScalarRelationFilter, TriggerWhereInput> | null
    SubAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    Action?: ActionListRelationFilter
    AutomationInstance?: AutomationInstanceListRelationFilter
  }

  export type AutomationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerId?: SortOrderInput | SortOrder
    published?: SortOrder
    subAccountId?: SortOrder
    Trigger?: TriggerOrderByWithRelationInput
    SubAccount?: SubAccountOrderByWithRelationInput
    Action?: ActionOrderByRelationAggregateInput
    AutomationInstance?: AutomationInstanceOrderByRelationAggregateInput
    _relevance?: AutomationOrderByRelevanceInput
  }

  export type AutomationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationWhereInput | AutomationWhereInput[]
    OR?: AutomationWhereInput[]
    NOT?: AutomationWhereInput | AutomationWhereInput[]
    name?: StringFilter<"Automation"> | string
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    triggerId?: StringNullableFilter<"Automation"> | string | null
    published?: BoolFilter<"Automation"> | boolean
    subAccountId?: StringFilter<"Automation"> | string
    Trigger?: XOR<TriggerNullableScalarRelationFilter, TriggerWhereInput> | null
    SubAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    Action?: ActionListRelationFilter
    AutomationInstance?: AutomationInstanceListRelationFilter
  }, "id">

  export type AutomationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerId?: SortOrderInput | SortOrder
    published?: SortOrder
    subAccountId?: SortOrder
    _count?: AutomationCountOrderByAggregateInput
    _max?: AutomationMaxOrderByAggregateInput
    _min?: AutomationMinOrderByAggregateInput
  }

  export type AutomationScalarWhereWithAggregatesInput = {
    AND?: AutomationScalarWhereWithAggregatesInput | AutomationScalarWhereWithAggregatesInput[]
    OR?: AutomationScalarWhereWithAggregatesInput[]
    NOT?: AutomationScalarWhereWithAggregatesInput | AutomationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Automation"> | string
    name?: StringWithAggregatesFilter<"Automation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Automation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Automation"> | Date | string
    triggerId?: StringNullableWithAggregatesFilter<"Automation"> | string | null
    published?: BoolWithAggregatesFilter<"Automation"> | boolean
    subAccountId?: StringWithAggregatesFilter<"Automation"> | string
  }

  export type AutomationInstanceWhereInput = {
    AND?: AutomationInstanceWhereInput | AutomationInstanceWhereInput[]
    OR?: AutomationInstanceWhereInput[]
    NOT?: AutomationInstanceWhereInput | AutomationInstanceWhereInput[]
    id?: StringFilter<"AutomationInstance"> | string
    createdAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    automationId?: StringFilter<"AutomationInstance"> | string
    active?: BoolFilter<"AutomationInstance"> | boolean
    Automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
  }

  export type AutomationInstanceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    active?: SortOrder
    Automation?: AutomationOrderByWithRelationInput
    _relevance?: AutomationInstanceOrderByRelevanceInput
  }

  export type AutomationInstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationInstanceWhereInput | AutomationInstanceWhereInput[]
    OR?: AutomationInstanceWhereInput[]
    NOT?: AutomationInstanceWhereInput | AutomationInstanceWhereInput[]
    createdAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    automationId?: StringFilter<"AutomationInstance"> | string
    active?: BoolFilter<"AutomationInstance"> | boolean
    Automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
  }, "id">

  export type AutomationInstanceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    active?: SortOrder
    _count?: AutomationInstanceCountOrderByAggregateInput
    _max?: AutomationInstanceMaxOrderByAggregateInput
    _min?: AutomationInstanceMinOrderByAggregateInput
  }

  export type AutomationInstanceScalarWhereWithAggregatesInput = {
    AND?: AutomationInstanceScalarWhereWithAggregatesInput | AutomationInstanceScalarWhereWithAggregatesInput[]
    OR?: AutomationInstanceScalarWhereWithAggregatesInput[]
    NOT?: AutomationInstanceScalarWhereWithAggregatesInput | AutomationInstanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationInstance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AutomationInstance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AutomationInstance"> | Date | string
    automationId?: StringWithAggregatesFilter<"AutomationInstance"> | string
    active?: BoolWithAggregatesFilter<"AutomationInstance"> | boolean
  }

  export type ActionWhereInput = {
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    id?: StringFilter<"Action"> | string
    name?: StringFilter<"Action"> | string
    type?: EnumActionTypeFilter<"Action"> | $Enums.ActionType
    createdAt?: DateTimeFilter<"Action"> | Date | string
    updatedAt?: DateTimeFilter<"Action"> | Date | string
    automationId?: StringFilter<"Action"> | string
    order?: IntFilter<"Action"> | number
    laneId?: StringFilter<"Action"> | string
    Automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
  }

  export type ActionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    order?: SortOrder
    laneId?: SortOrder
    Automation?: AutomationOrderByWithRelationInput
    _relevance?: ActionOrderByRelevanceInput
  }

  export type ActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    name?: StringFilter<"Action"> | string
    type?: EnumActionTypeFilter<"Action"> | $Enums.ActionType
    createdAt?: DateTimeFilter<"Action"> | Date | string
    updatedAt?: DateTimeFilter<"Action"> | Date | string
    automationId?: StringFilter<"Action"> | string
    order?: IntFilter<"Action"> | number
    laneId?: StringFilter<"Action"> | string
    Automation?: XOR<AutomationScalarRelationFilter, AutomationWhereInput>
  }, "id">

  export type ActionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    order?: SortOrder
    laneId?: SortOrder
    _count?: ActionCountOrderByAggregateInput
    _avg?: ActionAvgOrderByAggregateInput
    _max?: ActionMaxOrderByAggregateInput
    _min?: ActionMinOrderByAggregateInput
    _sum?: ActionSumOrderByAggregateInput
  }

  export type ActionScalarWhereWithAggregatesInput = {
    AND?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    OR?: ActionScalarWhereWithAggregatesInput[]
    NOT?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Action"> | string
    name?: StringWithAggregatesFilter<"Action"> | string
    type?: EnumActionTypeWithAggregatesFilter<"Action"> | $Enums.ActionType
    createdAt?: DateTimeWithAggregatesFilter<"Action"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Action"> | Date | string
    automationId?: StringWithAggregatesFilter<"Action"> | string
    order?: IntWithAggregatesFilter<"Action"> | number
    laneId?: StringWithAggregatesFilter<"Action"> | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    subAccountId?: StringFilter<"Contact"> | string
    SubAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    Tickets?: TicketsListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    SubAccount?: SubAccountOrderByWithRelationInput
    Tickets?: TicketsOrderByRelationAggregateInput
    _relevance?: ContactOrderByRelevanceInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    name?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    subAccountId?: StringFilter<"Contact"> | string
    SubAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    Tickets?: TicketsListRelationFilter
  }, "id" | "email">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    name?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringWithAggregatesFilter<"Contact"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    subAccountId?: StringWithAggregatesFilter<"Contact"> | string
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    type?: StringNullableFilter<"Media"> | string | null
    name?: StringFilter<"Media"> | string
    link?: StringFilter<"Media"> | string
    subAccountId?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    SubAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    SubAccount?: SubAccountOrderByWithRelationInput
    _relevance?: MediaOrderByRelevanceInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    link?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    type?: StringNullableFilter<"Media"> | string | null
    name?: StringFilter<"Media"> | string
    subAccountId?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    SubAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
  }, "id" | "link">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    type?: StringNullableWithAggregatesFilter<"Media"> | string | null
    name?: StringWithAggregatesFilter<"Media"> | string
    link?: StringWithAggregatesFilter<"Media"> | string
    subAccountId?: StringWithAggregatesFilter<"Media"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type FunnelsWhereInput = {
    AND?: FunnelsWhereInput | FunnelsWhereInput[]
    OR?: FunnelsWhereInput[]
    NOT?: FunnelsWhereInput | FunnelsWhereInput[]
    id?: StringFilter<"Funnels"> | string
    name?: StringFilter<"Funnels"> | string
    createdAt?: DateTimeFilter<"Funnels"> | Date | string
    updatedAt?: DateTimeFilter<"Funnels"> | Date | string
    description?: StringNullableFilter<"Funnels"> | string | null
    published?: BoolFilter<"Funnels"> | boolean
    subDomainName?: StringNullableFilter<"Funnels"> | string | null
    favicon?: StringNullableFilter<"Funnels"> | string | null
    subAccountId?: StringFilter<"Funnels"> | string
    liveProducts?: StringNullableFilter<"Funnels"> | string | null
    SubAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    FunnelPages?: FunnelPagesListRelationFilter
    ClassName?: ClassNameListRelationFilter
  }

  export type FunnelsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrderInput | SortOrder
    published?: SortOrder
    subDomainName?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    subAccountId?: SortOrder
    liveProducts?: SortOrderInput | SortOrder
    SubAccount?: SubAccountOrderByWithRelationInput
    FunnelPages?: FunnelPagesOrderByRelationAggregateInput
    ClassName?: ClassNameOrderByRelationAggregateInput
    _relevance?: FunnelsOrderByRelevanceInput
  }

  export type FunnelsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subDomainName?: string
    AND?: FunnelsWhereInput | FunnelsWhereInput[]
    OR?: FunnelsWhereInput[]
    NOT?: FunnelsWhereInput | FunnelsWhereInput[]
    name?: StringFilter<"Funnels"> | string
    createdAt?: DateTimeFilter<"Funnels"> | Date | string
    updatedAt?: DateTimeFilter<"Funnels"> | Date | string
    description?: StringNullableFilter<"Funnels"> | string | null
    published?: BoolFilter<"Funnels"> | boolean
    favicon?: StringNullableFilter<"Funnels"> | string | null
    subAccountId?: StringFilter<"Funnels"> | string
    liveProducts?: StringNullableFilter<"Funnels"> | string | null
    SubAccount?: XOR<SubAccountScalarRelationFilter, SubAccountWhereInput>
    FunnelPages?: FunnelPagesListRelationFilter
    ClassName?: ClassNameListRelationFilter
  }, "id" | "subDomainName">

  export type FunnelsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrderInput | SortOrder
    published?: SortOrder
    subDomainName?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    subAccountId?: SortOrder
    liveProducts?: SortOrderInput | SortOrder
    _count?: FunnelsCountOrderByAggregateInput
    _max?: FunnelsMaxOrderByAggregateInput
    _min?: FunnelsMinOrderByAggregateInput
  }

  export type FunnelsScalarWhereWithAggregatesInput = {
    AND?: FunnelsScalarWhereWithAggregatesInput | FunnelsScalarWhereWithAggregatesInput[]
    OR?: FunnelsScalarWhereWithAggregatesInput[]
    NOT?: FunnelsScalarWhereWithAggregatesInput | FunnelsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Funnels"> | string
    name?: StringWithAggregatesFilter<"Funnels"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Funnels"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Funnels"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Funnels"> | string | null
    published?: BoolWithAggregatesFilter<"Funnels"> | boolean
    subDomainName?: StringNullableWithAggregatesFilter<"Funnels"> | string | null
    favicon?: StringNullableWithAggregatesFilter<"Funnels"> | string | null
    subAccountId?: StringWithAggregatesFilter<"Funnels"> | string
    liveProducts?: StringNullableWithAggregatesFilter<"Funnels"> | string | null
  }

  export type FunnelPagesWhereInput = {
    AND?: FunnelPagesWhereInput | FunnelPagesWhereInput[]
    OR?: FunnelPagesWhereInput[]
    NOT?: FunnelPagesWhereInput | FunnelPagesWhereInput[]
    id?: StringFilter<"FunnelPages"> | string
    name?: StringFilter<"FunnelPages"> | string
    pathName?: StringFilter<"FunnelPages"> | string
    createdAt?: DateTimeFilter<"FunnelPages"> | Date | string
    updatedAt?: DateTimeFilter<"FunnelPages"> | Date | string
    visits?: IntFilter<"FunnelPages"> | number
    content?: StringNullableFilter<"FunnelPages"> | string | null
    order?: IntFilter<"FunnelPages"> | number
    previewImage?: StringNullableFilter<"FunnelPages"> | string | null
    funnelId?: StringFilter<"FunnelPages"> | string
    Funnels?: XOR<FunnelsScalarRelationFilter, FunnelsWhereInput>
  }

  export type FunnelPagesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    pathName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: SortOrder
    content?: SortOrderInput | SortOrder
    order?: SortOrder
    previewImage?: SortOrderInput | SortOrder
    funnelId?: SortOrder
    Funnels?: FunnelsOrderByWithRelationInput
    _relevance?: FunnelPagesOrderByRelevanceInput
  }

  export type FunnelPagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FunnelPagesWhereInput | FunnelPagesWhereInput[]
    OR?: FunnelPagesWhereInput[]
    NOT?: FunnelPagesWhereInput | FunnelPagesWhereInput[]
    name?: StringFilter<"FunnelPages"> | string
    pathName?: StringFilter<"FunnelPages"> | string
    createdAt?: DateTimeFilter<"FunnelPages"> | Date | string
    updatedAt?: DateTimeFilter<"FunnelPages"> | Date | string
    visits?: IntFilter<"FunnelPages"> | number
    content?: StringNullableFilter<"FunnelPages"> | string | null
    order?: IntFilter<"FunnelPages"> | number
    previewImage?: StringNullableFilter<"FunnelPages"> | string | null
    funnelId?: StringFilter<"FunnelPages"> | string
    Funnels?: XOR<FunnelsScalarRelationFilter, FunnelsWhereInput>
  }, "id">

  export type FunnelPagesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    pathName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: SortOrder
    content?: SortOrderInput | SortOrder
    order?: SortOrder
    previewImage?: SortOrderInput | SortOrder
    funnelId?: SortOrder
    _count?: FunnelPagesCountOrderByAggregateInput
    _avg?: FunnelPagesAvgOrderByAggregateInput
    _max?: FunnelPagesMaxOrderByAggregateInput
    _min?: FunnelPagesMinOrderByAggregateInput
    _sum?: FunnelPagesSumOrderByAggregateInput
  }

  export type FunnelPagesScalarWhereWithAggregatesInput = {
    AND?: FunnelPagesScalarWhereWithAggregatesInput | FunnelPagesScalarWhereWithAggregatesInput[]
    OR?: FunnelPagesScalarWhereWithAggregatesInput[]
    NOT?: FunnelPagesScalarWhereWithAggregatesInput | FunnelPagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FunnelPages"> | string
    name?: StringWithAggregatesFilter<"FunnelPages"> | string
    pathName?: StringWithAggregatesFilter<"FunnelPages"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FunnelPages"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FunnelPages"> | Date | string
    visits?: IntWithAggregatesFilter<"FunnelPages"> | number
    content?: StringNullableWithAggregatesFilter<"FunnelPages"> | string | null
    order?: IntWithAggregatesFilter<"FunnelPages"> | number
    previewImage?: StringNullableWithAggregatesFilter<"FunnelPages"> | string | null
    funnelId?: StringWithAggregatesFilter<"FunnelPages"> | string
  }

  export type ClassNameWhereInput = {
    AND?: ClassNameWhereInput | ClassNameWhereInput[]
    OR?: ClassNameWhereInput[]
    NOT?: ClassNameWhereInput | ClassNameWhereInput[]
    id?: StringFilter<"ClassName"> | string
    name?: StringFilter<"ClassName"> | string
    color?: StringFilter<"ClassName"> | string
    createdAt?: DateTimeFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeFilter<"ClassName"> | Date | string
    funnelId?: StringFilter<"ClassName"> | string
    customDate?: StringNullableFilter<"ClassName"> | string | null
    Funnels?: XOR<FunnelsScalarRelationFilter, FunnelsWhereInput>
  }

  export type ClassNameOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    funnelId?: SortOrder
    customDate?: SortOrderInput | SortOrder
    Funnels?: FunnelsOrderByWithRelationInput
    _relevance?: ClassNameOrderByRelevanceInput
  }

  export type ClassNameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassNameWhereInput | ClassNameWhereInput[]
    OR?: ClassNameWhereInput[]
    NOT?: ClassNameWhereInput | ClassNameWhereInput[]
    name?: StringFilter<"ClassName"> | string
    color?: StringFilter<"ClassName"> | string
    createdAt?: DateTimeFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeFilter<"ClassName"> | Date | string
    funnelId?: StringFilter<"ClassName"> | string
    customDate?: StringNullableFilter<"ClassName"> | string | null
    Funnels?: XOR<FunnelsScalarRelationFilter, FunnelsWhereInput>
  }, "id">

  export type ClassNameOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    funnelId?: SortOrder
    customDate?: SortOrderInput | SortOrder
    _count?: ClassNameCountOrderByAggregateInput
    _max?: ClassNameMaxOrderByAggregateInput
    _min?: ClassNameMinOrderByAggregateInput
  }

  export type ClassNameScalarWhereWithAggregatesInput = {
    AND?: ClassNameScalarWhereWithAggregatesInput | ClassNameScalarWhereWithAggregatesInput[]
    OR?: ClassNameScalarWhereWithAggregatesInput[]
    NOT?: ClassNameScalarWhereWithAggregatesInput | ClassNameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassName"> | string
    name?: StringWithAggregatesFilter<"ClassName"> | string
    color?: StringWithAggregatesFilter<"ClassName"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClassName"> | Date | string
    funnelId?: StringWithAggregatesFilter<"ClassName"> | string
    customDate?: StringNullableWithAggregatesFilter<"ClassName"> | string | null
  }

  export type AgencySidebarOptionWhereInput = {
    AND?: AgencySidebarOptionWhereInput | AgencySidebarOptionWhereInput[]
    OR?: AgencySidebarOptionWhereInput[]
    NOT?: AgencySidebarOptionWhereInput | AgencySidebarOptionWhereInput[]
    id?: StringFilter<"AgencySidebarOption"> | string
    name?: StringFilter<"AgencySidebarOption"> | string
    link?: StringFilter<"AgencySidebarOption"> | string
    icon?: EnumIconFilter<"AgencySidebarOption"> | $Enums.Icon
    agencyId?: StringFilter<"AgencySidebarOption"> | string
    createdAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    Agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }

  export type AgencySidebarOptionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Agency?: AgencyOrderByWithRelationInput
    _relevance?: AgencySidebarOptionOrderByRelevanceInput
  }

  export type AgencySidebarOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgencySidebarOptionWhereInput | AgencySidebarOptionWhereInput[]
    OR?: AgencySidebarOptionWhereInput[]
    NOT?: AgencySidebarOptionWhereInput | AgencySidebarOptionWhereInput[]
    name?: StringFilter<"AgencySidebarOption"> | string
    link?: StringFilter<"AgencySidebarOption"> | string
    icon?: EnumIconFilter<"AgencySidebarOption"> | $Enums.Icon
    agencyId?: StringFilter<"AgencySidebarOption"> | string
    createdAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    Agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }, "id">

  export type AgencySidebarOptionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencySidebarOptionCountOrderByAggregateInput
    _max?: AgencySidebarOptionMaxOrderByAggregateInput
    _min?: AgencySidebarOptionMinOrderByAggregateInput
  }

  export type AgencySidebarOptionScalarWhereWithAggregatesInput = {
    AND?: AgencySidebarOptionScalarWhereWithAggregatesInput | AgencySidebarOptionScalarWhereWithAggregatesInput[]
    OR?: AgencySidebarOptionScalarWhereWithAggregatesInput[]
    NOT?: AgencySidebarOptionScalarWhereWithAggregatesInput | AgencySidebarOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgencySidebarOption"> | string
    name?: StringWithAggregatesFilter<"AgencySidebarOption"> | string
    link?: StringWithAggregatesFilter<"AgencySidebarOption"> | string
    icon?: EnumIconWithAggregatesFilter<"AgencySidebarOption"> | $Enums.Icon
    agencyId?: StringWithAggregatesFilter<"AgencySidebarOption"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AgencySidebarOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgencySidebarOption"> | Date | string
  }

  export type SubAccountSidebarOptionWhereInput = {
    AND?: SubAccountSidebarOptionWhereInput | SubAccountSidebarOptionWhereInput[]
    OR?: SubAccountSidebarOptionWhereInput[]
    NOT?: SubAccountSidebarOptionWhereInput | SubAccountSidebarOptionWhereInput[]
    id?: StringFilter<"SubAccountSidebarOption"> | string
    name?: StringFilter<"SubAccountSidebarOption"> | string
    link?: StringFilter<"SubAccountSidebarOption"> | string
    icon?: EnumIconFilter<"SubAccountSidebarOption"> | $Enums.Icon
    createdAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    subAccountId?: StringNullableFilter<"SubAccountSidebarOption"> | string | null
    SubAccount?: XOR<SubAccountNullableScalarRelationFilter, SubAccountWhereInput> | null
  }

  export type SubAccountSidebarOptionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrderInput | SortOrder
    SubAccount?: SubAccountOrderByWithRelationInput
    _relevance?: SubAccountSidebarOptionOrderByRelevanceInput
  }

  export type SubAccountSidebarOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubAccountSidebarOptionWhereInput | SubAccountSidebarOptionWhereInput[]
    OR?: SubAccountSidebarOptionWhereInput[]
    NOT?: SubAccountSidebarOptionWhereInput | SubAccountSidebarOptionWhereInput[]
    name?: StringFilter<"SubAccountSidebarOption"> | string
    link?: StringFilter<"SubAccountSidebarOption"> | string
    icon?: EnumIconFilter<"SubAccountSidebarOption"> | $Enums.Icon
    createdAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    subAccountId?: StringNullableFilter<"SubAccountSidebarOption"> | string | null
    SubAccount?: XOR<SubAccountNullableScalarRelationFilter, SubAccountWhereInput> | null
  }, "id">

  export type SubAccountSidebarOptionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrderInput | SortOrder
    _count?: SubAccountSidebarOptionCountOrderByAggregateInput
    _max?: SubAccountSidebarOptionMaxOrderByAggregateInput
    _min?: SubAccountSidebarOptionMinOrderByAggregateInput
  }

  export type SubAccountSidebarOptionScalarWhereWithAggregatesInput = {
    AND?: SubAccountSidebarOptionScalarWhereWithAggregatesInput | SubAccountSidebarOptionScalarWhereWithAggregatesInput[]
    OR?: SubAccountSidebarOptionScalarWhereWithAggregatesInput[]
    NOT?: SubAccountSidebarOptionScalarWhereWithAggregatesInput | SubAccountSidebarOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubAccountSidebarOption"> | string
    name?: StringWithAggregatesFilter<"SubAccountSidebarOption"> | string
    link?: StringWithAggregatesFilter<"SubAccountSidebarOption"> | string
    icon?: EnumIconWithAggregatesFilter<"SubAccountSidebarOption"> | $Enums.Icon
    createdAt?: DateTimeWithAggregatesFilter<"SubAccountSidebarOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubAccountSidebarOption"> | Date | string
    subAccountId?: StringNullableWithAggregatesFilter<"SubAccountSidebarOption"> | string | null
  }

  export type InvitationWhereInput = {
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    id?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    agencyId?: StringFilter<"Invitation"> | string
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    role?: EnumRoleFilter<"Invitation"> | $Enums.Role
    Agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }

  export type InvitationOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
    Agency?: AgencyOrderByWithRelationInput
    _relevance?: InvitationOrderByRelevanceInput
  }

  export type InvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    agencyId?: StringFilter<"Invitation"> | string
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    role?: EnumRoleFilter<"Invitation"> | $Enums.Role
    Agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }, "id" | "email">

  export type InvitationOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
    _count?: InvitationCountOrderByAggregateInput
    _max?: InvitationMaxOrderByAggregateInput
    _min?: InvitationMinOrderByAggregateInput
  }

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    OR?: InvitationScalarWhereWithAggregatesInput[]
    NOT?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invitation"> | string
    email?: StringWithAggregatesFilter<"Invitation"> | string
    agencyId?: StringWithAggregatesFilter<"Invitation"> | string
    status?: EnumInvitationStatusWithAggregatesFilter<"Invitation"> | $Enums.InvitationStatus
    role?: EnumRoleWithAggregatesFilter<"Invitation"> | $Enums.Role
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    notification?: StringFilter<"Notification"> | string
    agencyId?: StringFilter<"Notification"> | string
    subAccountId?: StringNullableFilter<"Notification"> | string | null
    userId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    SubAccount?: XOR<SubAccountNullableScalarRelationFilter, SubAccountWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    notification?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Agency?: AgencyOrderByWithRelationInput
    SubAccount?: SubAccountOrderByWithRelationInput
    _relevance?: NotificationOrderByRelevanceInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    notification?: StringFilter<"Notification"> | string
    agencyId?: StringFilter<"Notification"> | string
    subAccountId?: StringNullableFilter<"Notification"> | string | null
    userId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    SubAccount?: XOR<SubAccountNullableScalarRelationFilter, SubAccountWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    notification?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    notification?: StringWithAggregatesFilter<"Notification"> | string
    agencyId?: StringWithAggregatesFilter<"Notification"> | string
    subAccountId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    userId?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    plan?: EnumPlanNullableFilter<"Subscription"> | $Enums.Plan | null
    price?: StringNullableFilter<"Subscription"> | string | null
    active?: BoolFilter<"Subscription"> | boolean
    priceId?: StringNullableFilter<"Subscription"> | string | null
    customerId?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodEndDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    subscriptionId?: StringFilter<"Subscription"> | string
    agencyId?: StringNullableFilter<"Subscription"> | string | null
    Agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    active?: SortOrder
    priceId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    currentPeriodEndDate?: SortOrderInput | SortOrder
    subscriptionId?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    Agency?: AgencyOrderByWithRelationInput
    _relevance?: SubscriptionOrderByRelevanceInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subscriptionId?: string
    agencyId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    plan?: EnumPlanNullableFilter<"Subscription"> | $Enums.Plan | null
    price?: StringNullableFilter<"Subscription"> | string | null
    active?: BoolFilter<"Subscription"> | boolean
    priceId?: StringNullableFilter<"Subscription"> | string | null
    customerId?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodEndDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    Agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }, "id" | "subscriptionId" | "agencyId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    active?: SortOrder
    priceId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    currentPeriodEndDate?: SortOrderInput | SortOrder
    subscriptionId?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    plan?: EnumPlanNullableWithAggregatesFilter<"Subscription"> | $Enums.Plan | null
    price?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    active?: BoolWithAggregatesFilter<"Subscription"> | boolean
    priceId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    currentPeriodEndDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    subscriptionId?: StringWithAggregatesFilter<"Subscription"> | string
    agencyId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
  }

  export type AddOnsWhereInput = {
    AND?: AddOnsWhereInput | AddOnsWhereInput[]
    OR?: AddOnsWhereInput[]
    NOT?: AddOnsWhereInput | AddOnsWhereInput[]
    id?: StringFilter<"AddOns"> | string
    createdAt?: DateTimeFilter<"AddOns"> | Date | string
    updatedAt?: DateTimeFilter<"AddOns"> | Date | string
    name?: StringFilter<"AddOns"> | string
    active?: BoolFilter<"AddOns"> | boolean
    priceId?: StringFilter<"AddOns"> | string
    agencyId?: StringNullableFilter<"AddOns"> | string | null
    Agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }

  export type AddOnsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    Agency?: AgencyOrderByWithRelationInput
    _relevance?: AddOnsOrderByRelevanceInput
  }

  export type AddOnsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    priceId?: string
    AND?: AddOnsWhereInput | AddOnsWhereInput[]
    OR?: AddOnsWhereInput[]
    NOT?: AddOnsWhereInput | AddOnsWhereInput[]
    createdAt?: DateTimeFilter<"AddOns"> | Date | string
    updatedAt?: DateTimeFilter<"AddOns"> | Date | string
    name?: StringFilter<"AddOns"> | string
    active?: BoolFilter<"AddOns"> | boolean
    agencyId?: StringNullableFilter<"AddOns"> | string | null
    Agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }, "id" | "priceId">

  export type AddOnsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    _count?: AddOnsCountOrderByAggregateInput
    _max?: AddOnsMaxOrderByAggregateInput
    _min?: AddOnsMinOrderByAggregateInput
  }

  export type AddOnsScalarWhereWithAggregatesInput = {
    AND?: AddOnsScalarWhereWithAggregatesInput | AddOnsScalarWhereWithAggregatesInput[]
    OR?: AddOnsScalarWhereWithAggregatesInput[]
    NOT?: AddOnsScalarWhereWithAggregatesInput | AddOnsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AddOns"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AddOns"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AddOns"> | Date | string
    name?: StringWithAggregatesFilter<"AddOns"> | string
    active?: BoolWithAggregatesFilter<"AddOns"> | boolean
    priceId?: StringWithAggregatesFilter<"AddOns"> | string
    agencyId?: StringNullableWithAggregatesFilter<"AddOns"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    Agency?: AgencyCreateNestedOneWithoutUsersInput
    Permissions?: PermissionsCreateNestedManyWithoutUserInput
    Tickets?: TicketsCreateNestedManyWithoutAssignedInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    agencyId?: string | null
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutUserInput
    Tickets?: TicketsUncheckedCreateNestedManyWithoutAssignedInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    Agency?: AgencyUpdateOneWithoutUsersNestedInput
    Permissions?: PermissionsUpdateManyWithoutUserNestedInput
    Tickets?: TicketsUpdateManyWithoutAssignedNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    Permissions?: PermissionsUncheckedUpdateManyWithoutUserNestedInput
    Tickets?: TicketsUncheckedUpdateManyWithoutAssignedNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    agencyId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgencyCreateInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationCreateNestedManyWithoutAgencyInput
    Notification?: NotificationCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountUncheckedCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationUncheckedCreateNestedManyWithoutAgencyInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionUncheckedCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountUncheckedUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationUncheckedUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyCreateManyInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionsCreateInput = {
    id?: string
    access: boolean
    User: UserCreateNestedOneWithoutPermissionsInput
    subAccount: SubAccountCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionsUncheckedCreateInput = {
    id?: string
    email: string
    subAccountId: string
    access: boolean
  }

  export type PermissionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutPermissionsNestedInput
    subAccount?: SubAccountUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type PermissionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionsCreateManyInput = {
    id?: string
    email: string
    subAccountId: string
    access: boolean
  }

  export type PermissionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubAccountCreateInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountInput
    Contact?: ContactCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    Contact?: ContactUncheckedCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerUncheckedCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationUncheckedCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUncheckedUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUncheckedUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountCreateManyInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
  }

  export type SubAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
  }

  export type SubAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
  }

  export type TagsCreateInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccount: SubAccountCreateNestedOneWithoutTagsInput
    Tickets?: TicketsCreateNestedOneWithoutTagsInput
  }

  export type TagsUncheckedCreateInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
    ticketsId?: string | null
  }

  export type TagsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccount?: SubAccountUpdateOneRequiredWithoutTagsNestedInput
    Tickets?: TicketsUpdateOneWithoutTagsNestedInput
  }

  export type TagsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    ticketsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagsCreateManyInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
    ticketsId?: string | null
  }

  export type TagsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    ticketsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PipelineCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Lane?: LaneCreateNestedManyWithoutPipelineInput
    SubAccount: SubAccountCreateNestedOneWithoutPipelineInput
  }

  export type PipelineUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
    Lane?: LaneUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type PipelineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lane?: LaneUpdateManyWithoutPipelineNestedInput
    SubAccount?: SubAccountUpdateOneRequiredWithoutPipelineNestedInput
  }

  export type PipelineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    Lane?: LaneUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type PipelineCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type PipelineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type LaneCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    Pipeline: PipelineCreateNestedOneWithoutLaneInput
    Tickets?: TicketsCreateNestedManyWithoutLaneInput
  }

  export type LaneUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
    order?: number
    Tickets?: TicketsUncheckedCreateNestedManyWithoutLaneInput
  }

  export type LaneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    Pipeline?: PipelineUpdateOneRequiredWithoutLaneNestedInput
    Tickets?: TicketsUpdateManyWithoutLaneNestedInput
  }

  export type LaneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    Tickets?: TicketsUncheckedUpdateManyWithoutLaneNestedInput
  }

  export type LaneCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
    order?: number
  }

  export type LaneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type LaneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TicketsCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    Lane: LaneCreateNestedOneWithoutTicketsInput
    Tags?: TagsCreateNestedManyWithoutTicketsInput
    Customer?: ContactCreateNestedOneWithoutTicketsInput
    Assigned?: UserCreateNestedOneWithoutTicketsInput
  }

  export type TicketsUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    laneId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    customerId?: string | null
    assignedUserId?: string | null
    Tags?: TagsUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Lane?: LaneUpdateOneRequiredWithoutTicketsNestedInput
    Tags?: TagsUpdateManyWithoutTicketsNestedInput
    Customer?: ContactUpdateOneWithoutTicketsNestedInput
    Assigned?: UserUpdateOneWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laneId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    Tags?: TagsUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketsCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    laneId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    customerId?: string | null
    assignedUserId?: string | null
  }

  export type TicketsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laneId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TriggerCreateInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccount: SubAccountCreateNestedOneWithoutTriggerInput
    Automation?: AutomationCreateNestedManyWithoutTriggerInput
  }

  export type TriggerUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
    Automation?: AutomationUncheckedCreateNestedManyWithoutTriggerInput
  }

  export type TriggerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccount?: SubAccountUpdateOneRequiredWithoutTriggerNestedInput
    Automation?: AutomationUpdateManyWithoutTriggerNestedInput
  }

  export type TriggerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    Automation?: AutomationUncheckedUpdateManyWithoutTriggerNestedInput
  }

  export type TriggerCreateManyInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type TriggerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriggerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type AutomationCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    Trigger?: TriggerCreateNestedOneWithoutAutomationInput
    SubAccount: SubAccountCreateNestedOneWithoutAutomationInput
    Action?: ActionCreateNestedManyWithoutAutomationInput
    AutomationInstance?: AutomationInstanceCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerId?: string | null
    published?: boolean
    subAccountId: string
    Action?: ActionUncheckedCreateNestedManyWithoutAutomationInput
    AutomationInstance?: AutomationInstanceUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    Trigger?: TriggerUpdateOneWithoutAutomationNestedInput
    SubAccount?: SubAccountUpdateOneRequiredWithoutAutomationNestedInput
    Action?: ActionUpdateManyWithoutAutomationNestedInput
    AutomationInstance?: AutomationInstanceUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
    Action?: ActionUncheckedUpdateManyWithoutAutomationNestedInput
    AutomationInstance?: AutomationInstanceUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerId?: string | null
    published?: boolean
    subAccountId: string
  }

  export type AutomationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type AutomationInstanceCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    Automation: AutomationCreateNestedOneWithoutAutomationInstanceInput
  }

  export type AutomationInstanceUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    automationId: string
    active?: boolean
  }

  export type AutomationInstanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    Automation?: AutomationUpdateOneRequiredWithoutAutomationInstanceNestedInput
  }

  export type AutomationInstanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    automationId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationInstanceCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    automationId: string
    active?: boolean
  }

  export type AutomationInstanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationInstanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    automationId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActionCreateInput = {
    id?: string
    name: string
    type: $Enums.ActionType
    createdAt?: Date | string
    updatedAt?: Date | string
    order: number
    laneId?: string
    Automation: AutomationCreateNestedOneWithoutActionInput
  }

  export type ActionUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.ActionType
    createdAt?: Date | string
    updatedAt?: Date | string
    automationId: string
    order: number
    laneId?: string
  }

  export type ActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
    Automation?: AutomationUpdateOneRequiredWithoutActionNestedInput
  }

  export type ActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    automationId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
  }

  export type ActionCreateManyInput = {
    id?: string
    name: string
    type: $Enums.ActionType
    createdAt?: Date | string
    updatedAt?: Date | string
    automationId: string
    order: number
    laneId?: string
  }

  export type ActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
  }

  export type ActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    automationId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactCreateInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccount: SubAccountCreateNestedOneWithoutContactInput
    Tickets?: TicketsCreateNestedManyWithoutCustomerInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
    Tickets?: TicketsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccount?: SubAccountUpdateOneRequiredWithoutContactNestedInput
    Tickets?: TicketsUpdateManyWithoutCustomerNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    Tickets?: TicketsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type MediaCreateInput = {
    id?: string
    type?: string | null
    name: string
    link: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccount: SubAccountCreateNestedOneWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    type?: string | null
    name: string
    link: string
    subAccountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccount?: SubAccountUpdateOneRequiredWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateManyInput = {
    id?: string
    type?: string | null
    name: string
    link: string
    subAccountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunnelsCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
    SubAccount: SubAccountCreateNestedOneWithoutFunnelsInput
    FunnelPages?: FunnelPagesCreateNestedManyWithoutFunnelsInput
    ClassName?: ClassNameCreateNestedManyWithoutFunnelsInput
  }

  export type FunnelsUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    subAccountId: string
    liveProducts?: string | null
    FunnelPages?: FunnelPagesUncheckedCreateNestedManyWithoutFunnelsInput
    ClassName?: ClassNameUncheckedCreateNestedManyWithoutFunnelsInput
  }

  export type FunnelsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    SubAccount?: SubAccountUpdateOneRequiredWithoutFunnelsNestedInput
    FunnelPages?: FunnelPagesUpdateManyWithoutFunnelsNestedInput
    ClassName?: ClassNameUpdateManyWithoutFunnelsNestedInput
  }

  export type FunnelsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    subAccountId?: StringFieldUpdateOperationsInput | string
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    FunnelPages?: FunnelPagesUncheckedUpdateManyWithoutFunnelsNestedInput
    ClassName?: ClassNameUncheckedUpdateManyWithoutFunnelsNestedInput
  }

  export type FunnelsCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    subAccountId: string
    liveProducts?: string | null
  }

  export type FunnelsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunnelsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    subAccountId?: StringFieldUpdateOperationsInput | string
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunnelPagesCreateInput = {
    id?: string
    name: string
    pathName?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: number
    content?: string | null
    order: number
    previewImage?: string | null
    Funnels: FunnelsCreateNestedOneWithoutFunnelPagesInput
  }

  export type FunnelPagesUncheckedCreateInput = {
    id?: string
    name: string
    pathName?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: number
    content?: string | null
    order: number
    previewImage?: string | null
    funnelId: string
  }

  export type FunnelPagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: NullableStringFieldUpdateOperationsInput | string | null
    Funnels?: FunnelsUpdateOneRequiredWithoutFunnelPagesNestedInput
  }

  export type FunnelPagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: NullableStringFieldUpdateOperationsInput | string | null
    funnelId?: StringFieldUpdateOperationsInput | string
  }

  export type FunnelPagesCreateManyInput = {
    id?: string
    name: string
    pathName?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: number
    content?: string | null
    order: number
    previewImage?: string | null
    funnelId: string
  }

  export type FunnelPagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunnelPagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: NullableStringFieldUpdateOperationsInput | string | null
    funnelId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassNameCreateInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customDate?: string | null
    Funnels: FunnelsCreateNestedOneWithoutClassNameInput
  }

  export type ClassNameUncheckedCreateInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    funnelId: string
    customDate?: string | null
  }

  export type ClassNameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customDate?: NullableStringFieldUpdateOperationsInput | string | null
    Funnels?: FunnelsUpdateOneRequiredWithoutClassNameNestedInput
  }

  export type ClassNameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    funnelId?: StringFieldUpdateOperationsInput | string
    customDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameCreateManyInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    funnelId: string
    customDate?: string | null
  }

  export type ClassNameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    funnelId?: StringFieldUpdateOperationsInput | string
    customDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgencySidebarOptionCreateInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    Agency?: AgencyCreateNestedOneWithoutSidebarOptionInput
  }

  export type AgencySidebarOptionUncheckedCreateInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    agencyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencySidebarOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Agency?: AgencyUpdateOneWithoutSidebarOptionNestedInput
  }

  export type AgencySidebarOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencySidebarOptionCreateManyInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    agencyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencySidebarOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencySidebarOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    agencyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubAccountSidebarOptionCreateInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccount?: SubAccountCreateNestedOneWithoutSidebarOptionInput
  }

  export type SubAccountSidebarOptionUncheckedCreateInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId?: string | null
  }

  export type SubAccountSidebarOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccount?: SubAccountUpdateOneWithoutSidebarOptionNestedInput
  }

  export type SubAccountSidebarOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubAccountSidebarOptionCreateManyInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId?: string | null
  }

  export type SubAccountSidebarOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubAccountSidebarOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvitationCreateInput = {
    id?: string
    email: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
    Agency: AgencyCreateNestedOneWithoutInvitationInput
  }

  export type InvitationUncheckedCreateInput = {
    id?: string
    email: string
    agencyId: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
  }

  export type InvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    Agency?: AgencyUpdateOneRequiredWithoutInvitationNestedInput
  }

  export type InvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type InvitationCreateManyInput = {
    id?: string
    email: string
    agencyId: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
  }

  export type InvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type InvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type NotificationCreateInput = {
    id?: string
    notification: string
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutNotificationInput
    Agency: AgencyCreateNestedOneWithoutNotificationInput
    SubAccount?: SubAccountCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    notification: string
    agencyId: string
    subAccountId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutNotificationNestedInput
    Agency?: AgencyUpdateOneRequiredWithoutNotificationNestedInput
    SubAccount?: SubAccountUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    notification: string
    agencyId: string
    subAccountId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: $Enums.Plan | null
    price?: string | null
    active?: boolean
    priceId?: string | null
    customerId?: string | null
    currentPeriodEndDate?: Date | string | null
    subscriptionId: string
    Agency?: AgencyCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: $Enums.Plan | null
    price?: string | null
    active?: boolean
    priceId?: string | null
    customerId?: string | null
    currentPeriodEndDate?: Date | string | null
    subscriptionId: string
    agencyId?: string | null
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: $Enums.Plan | null
    price?: string | null
    active?: boolean
    priceId?: string | null
    customerId?: string | null
    currentPeriodEndDate?: Date | string | null
    subscriptionId: string
    agencyId?: string | null
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddOnsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
    Agency?: AgencyCreateNestedOneWithoutAddOnsInput
  }

  export type AddOnsUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
    agencyId?: string | null
  }

  export type AddOnsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneWithoutAddOnsNestedInput
  }

  export type AddOnsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddOnsCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
    agencyId?: string | null
  }

  export type AddOnsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
  }

  export type AddOnsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type AgencyNullableScalarRelationFilter = {
    is?: AgencyWhereInput | null
    isNot?: AgencyWhereInput | null
  }

  export type PermissionsListRelationFilter = {
    every?: PermissionsWhereInput
    some?: PermissionsWhereInput
    none?: PermissionsWhereInput
  }

  export type TicketsListRelationFilter = {
    every?: TicketsWhereInput
    some?: TicketsWhereInput
    none?: TicketsWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PermissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    agencyId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    agencyId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    agencyId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SubAccountListRelationFilter = {
    every?: SubAccountWhereInput
    some?: SubAccountWhereInput
    none?: SubAccountWhereInput
  }

  export type AgencySidebarOptionListRelationFilter = {
    every?: AgencySidebarOptionWhereInput
    some?: AgencySidebarOptionWhereInput
    none?: AgencySidebarOptionWhereInput
  }

  export type InvitationListRelationFilter = {
    every?: InvitationWhereInput
    some?: InvitationWhereInput
    none?: InvitationWhereInput
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type AddOnsListRelationFilter = {
    every?: AddOnsWhereInput
    some?: AddOnsWhereInput
    none?: AddOnsWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencySidebarOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddOnsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyOrderByRelevanceInput = {
    fields: AgencyOrderByRelevanceFieldEnum | AgencyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AgencyCountOrderByAggregateInput = {
    id?: SortOrder
    connectAccountId?: SortOrder
    customerId?: SortOrder
    name?: SortOrder
    agencyLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    whiteLabel?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    goal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyAvgOrderByAggregateInput = {
    goal?: SortOrder
  }

  export type AgencyMaxOrderByAggregateInput = {
    id?: SortOrder
    connectAccountId?: SortOrder
    customerId?: SortOrder
    name?: SortOrder
    agencyLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    whiteLabel?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    goal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyMinOrderByAggregateInput = {
    id?: SortOrder
    connectAccountId?: SortOrder
    customerId?: SortOrder
    name?: SortOrder
    agencyLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    whiteLabel?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    goal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencySumOrderByAggregateInput = {
    goal?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SubAccountScalarRelationFilter = {
    is?: SubAccountWhereInput
    isNot?: SubAccountWhereInput
  }

  export type PermissionsOrderByRelevanceInput = {
    fields: PermissionsOrderByRelevanceFieldEnum | PermissionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PermissionsCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    subAccountId?: SortOrder
    access?: SortOrder
  }

  export type PermissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    subAccountId?: SortOrder
    access?: SortOrder
  }

  export type PermissionsMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    subAccountId?: SortOrder
    access?: SortOrder
  }

  export type AgencyScalarRelationFilter = {
    is?: AgencyWhereInput
    isNot?: AgencyWhereInput
  }

  export type SubAccountSidebarOptionListRelationFilter = {
    every?: SubAccountSidebarOptionWhereInput
    some?: SubAccountSidebarOptionWhereInput
    none?: SubAccountSidebarOptionWhereInput
  }

  export type FunnelsListRelationFilter = {
    every?: FunnelsWhereInput
    some?: FunnelsWhereInput
    none?: FunnelsWhereInput
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type TriggerListRelationFilter = {
    every?: TriggerWhereInput
    some?: TriggerWhereInput
    none?: TriggerWhereInput
  }

  export type AutomationListRelationFilter = {
    every?: AutomationWhereInput
    some?: AutomationWhereInput
    none?: AutomationWhereInput
  }

  export type PipelineListRelationFilter = {
    every?: PipelineWhereInput
    some?: PipelineWhereInput
    none?: PipelineWhereInput
  }

  export type TagsListRelationFilter = {
    every?: TagsWhereInput
    some?: TagsWhereInput
    none?: TagsWhereInput
  }

  export type SubAccountSidebarOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FunnelsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TriggerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PipelineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubAccountOrderByRelevanceInput = {
    fields: SubAccountOrderByRelevanceFieldEnum | SubAccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubAccountCountOrderByAggregateInput = {
    id?: SortOrder
    connectAccountId?: SortOrder
    name?: SortOrder
    subAccountLogo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    goal?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    agencyId?: SortOrder
  }

  export type SubAccountAvgOrderByAggregateInput = {
    goal?: SortOrder
  }

  export type SubAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    connectAccountId?: SortOrder
    name?: SortOrder
    subAccountLogo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    goal?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    agencyId?: SortOrder
  }

  export type SubAccountMinOrderByAggregateInput = {
    id?: SortOrder
    connectAccountId?: SortOrder
    name?: SortOrder
    subAccountLogo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    goal?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    agencyId?: SortOrder
  }

  export type SubAccountSumOrderByAggregateInput = {
    goal?: SortOrder
  }

  export type TicketsNullableScalarRelationFilter = {
    is?: TicketsWhereInput | null
    isNot?: TicketsWhereInput | null
  }

  export type TagsOrderByRelevanceInput = {
    fields: TagsOrderByRelevanceFieldEnum | TagsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TagsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    ticketsId?: SortOrder
  }

  export type TagsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    ticketsId?: SortOrder
  }

  export type TagsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    ticketsId?: SortOrder
  }

  export type LaneListRelationFilter = {
    every?: LaneWhereInput
    some?: LaneWhereInput
    none?: LaneWhereInput
  }

  export type LaneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PipelineOrderByRelevanceInput = {
    fields: PipelineOrderByRelevanceFieldEnum | PipelineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PipelineCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type PipelineMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type PipelineMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type PipelineScalarRelationFilter = {
    is?: PipelineWhereInput
    isNot?: PipelineWhereInput
  }

  export type LaneOrderByRelevanceInput = {
    fields: LaneOrderByRelevanceFieldEnum | LaneOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LaneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    order?: SortOrder
  }

  export type LaneAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type LaneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    order?: SortOrder
  }

  export type LaneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    order?: SortOrder
  }

  export type LaneSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type LaneScalarRelationFilter = {
    is?: LaneWhereInput
    isNot?: LaneWhereInput
  }

  export type ContactNullableScalarRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TicketsOrderByRelevanceInput = {
    fields: TicketsOrderByRelevanceFieldEnum | TicketsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TicketsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laneId?: SortOrder
    order?: SortOrder
    value?: SortOrder
    description?: SortOrder
    customerId?: SortOrder
    assignedUserId?: SortOrder
  }

  export type TicketsAvgOrderByAggregateInput = {
    order?: SortOrder
    value?: SortOrder
  }

  export type TicketsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laneId?: SortOrder
    order?: SortOrder
    value?: SortOrder
    description?: SortOrder
    customerId?: SortOrder
    assignedUserId?: SortOrder
  }

  export type TicketsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    laneId?: SortOrder
    order?: SortOrder
    value?: SortOrder
    description?: SortOrder
    customerId?: SortOrder
    assignedUserId?: SortOrder
  }

  export type TicketsSumOrderByAggregateInput = {
    order?: SortOrder
    value?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumTriggerTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerTypes | EnumTriggerTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerTypes[]
    notIn?: $Enums.TriggerTypes[]
    not?: NestedEnumTriggerTypesFilter<$PrismaModel> | $Enums.TriggerTypes
  }

  export type TriggerOrderByRelevanceInput = {
    fields: TriggerOrderByRelevanceFieldEnum | TriggerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TriggerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type TriggerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type TriggerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type EnumTriggerTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerTypes | EnumTriggerTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerTypes[]
    notIn?: $Enums.TriggerTypes[]
    not?: NestedEnumTriggerTypesWithAggregatesFilter<$PrismaModel> | $Enums.TriggerTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTriggerTypesFilter<$PrismaModel>
    _max?: NestedEnumTriggerTypesFilter<$PrismaModel>
  }

  export type TriggerNullableScalarRelationFilter = {
    is?: TriggerWhereInput | null
    isNot?: TriggerWhereInput | null
  }

  export type ActionListRelationFilter = {
    every?: ActionWhereInput
    some?: ActionWhereInput
    none?: ActionWhereInput
  }

  export type AutomationInstanceListRelationFilter = {
    every?: AutomationInstanceWhereInput
    some?: AutomationInstanceWhereInput
    none?: AutomationInstanceWhereInput
  }

  export type ActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationInstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationOrderByRelevanceInput = {
    fields: AutomationOrderByRelevanceFieldEnum | AutomationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AutomationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerId?: SortOrder
    published?: SortOrder
    subAccountId?: SortOrder
  }

  export type AutomationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerId?: SortOrder
    published?: SortOrder
    subAccountId?: SortOrder
  }

  export type AutomationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerId?: SortOrder
    published?: SortOrder
    subAccountId?: SortOrder
  }

  export type AutomationScalarRelationFilter = {
    is?: AutomationWhereInput
    isNot?: AutomationWhereInput
  }

  export type AutomationInstanceOrderByRelevanceInput = {
    fields: AutomationInstanceOrderByRelevanceFieldEnum | AutomationInstanceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AutomationInstanceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    active?: SortOrder
  }

  export type AutomationInstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    active?: SortOrder
  }

  export type AutomationInstanceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    active?: SortOrder
  }

  export type EnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[]
    notIn?: $Enums.ActionType[]
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type ActionOrderByRelevanceInput = {
    fields: ActionOrderByRelevanceFieldEnum | ActionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ActionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    order?: SortOrder
    laneId?: SortOrder
  }

  export type ActionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ActionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    order?: SortOrder
    laneId?: SortOrder
  }

  export type ActionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    order?: SortOrder
    laneId?: SortOrder
  }

  export type ActionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[]
    notIn?: $Enums.ActionType[]
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type ContactOrderByRelevanceInput = {
    fields: ContactOrderByRelevanceFieldEnum | ContactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type MediaOrderByRelevanceInput = {
    fields: MediaOrderByRelevanceFieldEnum | MediaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FunnelPagesListRelationFilter = {
    every?: FunnelPagesWhereInput
    some?: FunnelPagesWhereInput
    none?: FunnelPagesWhereInput
  }

  export type ClassNameListRelationFilter = {
    every?: ClassNameWhereInput
    some?: ClassNameWhereInput
    none?: ClassNameWhereInput
  }

  export type FunnelPagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassNameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FunnelsOrderByRelevanceInput = {
    fields: FunnelsOrderByRelevanceFieldEnum | FunnelsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FunnelsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    published?: SortOrder
    subDomainName?: SortOrder
    favicon?: SortOrder
    subAccountId?: SortOrder
    liveProducts?: SortOrder
  }

  export type FunnelsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    published?: SortOrder
    subDomainName?: SortOrder
    favicon?: SortOrder
    subAccountId?: SortOrder
    liveProducts?: SortOrder
  }

  export type FunnelsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    published?: SortOrder
    subDomainName?: SortOrder
    favicon?: SortOrder
    subAccountId?: SortOrder
    liveProducts?: SortOrder
  }

  export type FunnelsScalarRelationFilter = {
    is?: FunnelsWhereInput
    isNot?: FunnelsWhereInput
  }

  export type FunnelPagesOrderByRelevanceInput = {
    fields: FunnelPagesOrderByRelevanceFieldEnum | FunnelPagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FunnelPagesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pathName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: SortOrder
    content?: SortOrder
    order?: SortOrder
    previewImage?: SortOrder
    funnelId?: SortOrder
  }

  export type FunnelPagesAvgOrderByAggregateInput = {
    visits?: SortOrder
    order?: SortOrder
  }

  export type FunnelPagesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pathName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: SortOrder
    content?: SortOrder
    order?: SortOrder
    previewImage?: SortOrder
    funnelId?: SortOrder
  }

  export type FunnelPagesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pathName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: SortOrder
    content?: SortOrder
    order?: SortOrder
    previewImage?: SortOrder
    funnelId?: SortOrder
  }

  export type FunnelPagesSumOrderByAggregateInput = {
    visits?: SortOrder
    order?: SortOrder
  }

  export type ClassNameOrderByRelevanceInput = {
    fields: ClassNameOrderByRelevanceFieldEnum | ClassNameOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClassNameCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    funnelId?: SortOrder
    customDate?: SortOrder
  }

  export type ClassNameMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    funnelId?: SortOrder
    customDate?: SortOrder
  }

  export type ClassNameMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    funnelId?: SortOrder
    customDate?: SortOrder
  }

  export type EnumIconFilter<$PrismaModel = never> = {
    equals?: $Enums.Icon | EnumIconFieldRefInput<$PrismaModel>
    in?: $Enums.Icon[]
    notIn?: $Enums.Icon[]
    not?: NestedEnumIconFilter<$PrismaModel> | $Enums.Icon
  }

  export type AgencySidebarOptionOrderByRelevanceInput = {
    fields: AgencySidebarOptionOrderByRelevanceFieldEnum | AgencySidebarOptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AgencySidebarOptionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencySidebarOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencySidebarOptionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    agencyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIconWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Icon | EnumIconFieldRefInput<$PrismaModel>
    in?: $Enums.Icon[]
    notIn?: $Enums.Icon[]
    not?: NestedEnumIconWithAggregatesFilter<$PrismaModel> | $Enums.Icon
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIconFilter<$PrismaModel>
    _max?: NestedEnumIconFilter<$PrismaModel>
  }

  export type SubAccountNullableScalarRelationFilter = {
    is?: SubAccountWhereInput | null
    isNot?: SubAccountWhereInput | null
  }

  export type SubAccountSidebarOptionOrderByRelevanceInput = {
    fields: SubAccountSidebarOptionOrderByRelevanceFieldEnum | SubAccountSidebarOptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubAccountSidebarOptionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type SubAccountSidebarOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type SubAccountSidebarOptionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[]
    notIn?: $Enums.InvitationStatus[]
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type InvitationOrderByRelevanceInput = {
    fields: InvitationOrderByRelevanceFieldEnum | InvitationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InvitationCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
  }

  export type InvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
  }

  export type InvitationMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[]
    notIn?: $Enums.InvitationStatus[]
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NotificationOrderByRelevanceInput = {
    fields: NotificationOrderByRelevanceFieldEnum | NotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    notification?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    notification?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    notification?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | null
    notIn?: $Enums.Plan[] | null
    not?: NestedEnumPlanNullableFilter<$PrismaModel> | $Enums.Plan | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SubscriptionOrderByRelevanceInput = {
    fields: SubscriptionOrderByRelevanceFieldEnum | SubscriptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SortOrder
    price?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    customerId?: SortOrder
    currentPeriodEndDate?: SortOrder
    subscriptionId?: SortOrder
    agencyId?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SortOrder
    price?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    customerId?: SortOrder
    currentPeriodEndDate?: SortOrder
    subscriptionId?: SortOrder
    agencyId?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SortOrder
    price?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    customerId?: SortOrder
    currentPeriodEndDate?: SortOrder
    subscriptionId?: SortOrder
    agencyId?: SortOrder
  }

  export type EnumPlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | null
    notIn?: $Enums.Plan[] | null
    not?: NestedEnumPlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.Plan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlanNullableFilter<$PrismaModel>
    _max?: NestedEnumPlanNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AddOnsOrderByRelevanceInput = {
    fields: AddOnsOrderByRelevanceFieldEnum | AddOnsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AddOnsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    agencyId?: SortOrder
  }

  export type AddOnsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    agencyId?: SortOrder
  }

  export type AddOnsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    agencyId?: SortOrder
  }

  export type AgencyCreateNestedOneWithoutUsersInput = {
    create?: XOR<AgencyCreateWithoutUsersInput, AgencyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUsersInput
    connect?: AgencyWhereUniqueInput
  }

  export type PermissionsCreateNestedManyWithoutUserInput = {
    create?: XOR<PermissionsCreateWithoutUserInput, PermissionsUncheckedCreateWithoutUserInput> | PermissionsCreateWithoutUserInput[] | PermissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutUserInput | PermissionsCreateOrConnectWithoutUserInput[]
    createMany?: PermissionsCreateManyUserInputEnvelope
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
  }

  export type TicketsCreateNestedManyWithoutAssignedInput = {
    create?: XOR<TicketsCreateWithoutAssignedInput, TicketsUncheckedCreateWithoutAssignedInput> | TicketsCreateWithoutAssignedInput[] | TicketsUncheckedCreateWithoutAssignedInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutAssignedInput | TicketsCreateOrConnectWithoutAssignedInput[]
    createMany?: TicketsCreateManyAssignedInputEnvelope
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PermissionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PermissionsCreateWithoutUserInput, PermissionsUncheckedCreateWithoutUserInput> | PermissionsCreateWithoutUserInput[] | PermissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutUserInput | PermissionsCreateOrConnectWithoutUserInput[]
    createMany?: PermissionsCreateManyUserInputEnvelope
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
  }

  export type TicketsUncheckedCreateNestedManyWithoutAssignedInput = {
    create?: XOR<TicketsCreateWithoutAssignedInput, TicketsUncheckedCreateWithoutAssignedInput> | TicketsCreateWithoutAssignedInput[] | TicketsUncheckedCreateWithoutAssignedInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutAssignedInput | TicketsCreateOrConnectWithoutAssignedInput[]
    createMany?: TicketsCreateManyAssignedInputEnvelope
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type AgencyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<AgencyCreateWithoutUsersInput, AgencyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUsersInput
    upsert?: AgencyUpsertWithoutUsersInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutUsersInput, AgencyUpdateWithoutUsersInput>, AgencyUncheckedUpdateWithoutUsersInput>
  }

  export type PermissionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<PermissionsCreateWithoutUserInput, PermissionsUncheckedCreateWithoutUserInput> | PermissionsCreateWithoutUserInput[] | PermissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutUserInput | PermissionsCreateOrConnectWithoutUserInput[]
    upsert?: PermissionsUpsertWithWhereUniqueWithoutUserInput | PermissionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PermissionsCreateManyUserInputEnvelope
    set?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    disconnect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    delete?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    update?: PermissionsUpdateWithWhereUniqueWithoutUserInput | PermissionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PermissionsUpdateManyWithWhereWithoutUserInput | PermissionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
  }

  export type TicketsUpdateManyWithoutAssignedNestedInput = {
    create?: XOR<TicketsCreateWithoutAssignedInput, TicketsUncheckedCreateWithoutAssignedInput> | TicketsCreateWithoutAssignedInput[] | TicketsUncheckedCreateWithoutAssignedInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutAssignedInput | TicketsCreateOrConnectWithoutAssignedInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutAssignedInput | TicketsUpsertWithWhereUniqueWithoutAssignedInput[]
    createMany?: TicketsCreateManyAssignedInputEnvelope
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutAssignedInput | TicketsUpdateWithWhereUniqueWithoutAssignedInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutAssignedInput | TicketsUpdateManyWithWhereWithoutAssignedInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type PermissionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PermissionsCreateWithoutUserInput, PermissionsUncheckedCreateWithoutUserInput> | PermissionsCreateWithoutUserInput[] | PermissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutUserInput | PermissionsCreateOrConnectWithoutUserInput[]
    upsert?: PermissionsUpsertWithWhereUniqueWithoutUserInput | PermissionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PermissionsCreateManyUserInputEnvelope
    set?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    disconnect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    delete?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    update?: PermissionsUpdateWithWhereUniqueWithoutUserInput | PermissionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PermissionsUpdateManyWithWhereWithoutUserInput | PermissionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
  }

  export type TicketsUncheckedUpdateManyWithoutAssignedNestedInput = {
    create?: XOR<TicketsCreateWithoutAssignedInput, TicketsUncheckedCreateWithoutAssignedInput> | TicketsCreateWithoutAssignedInput[] | TicketsUncheckedCreateWithoutAssignedInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutAssignedInput | TicketsCreateOrConnectWithoutAssignedInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutAssignedInput | TicketsUpsertWithWhereUniqueWithoutAssignedInput[]
    createMany?: TicketsCreateManyAssignedInputEnvelope
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutAssignedInput | TicketsUpdateWithWhereUniqueWithoutAssignedInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutAssignedInput | TicketsUpdateManyWithWhereWithoutAssignedInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutAgencyInput = {
    create?: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput> | UserCreateWithoutAgencyInput[] | UserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAgencyInput | UserCreateOrConnectWithoutAgencyInput[]
    createMany?: UserCreateManyAgencyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SubAccountCreateNestedManyWithoutAgencyInput = {
    create?: XOR<SubAccountCreateWithoutAgencyInput, SubAccountUncheckedCreateWithoutAgencyInput> | SubAccountCreateWithoutAgencyInput[] | SubAccountUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutAgencyInput | SubAccountCreateOrConnectWithoutAgencyInput[]
    createMany?: SubAccountCreateManyAgencyInputEnvelope
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
  }

  export type AgencySidebarOptionCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput> | AgencySidebarOptionCreateWithoutAgencyInput[] | AgencySidebarOptionUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutAgencyInput | AgencySidebarOptionCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencySidebarOptionCreateManyAgencyInputEnvelope
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutAgencyInput = {
    create?: XOR<InvitationCreateWithoutAgencyInput, InvitationUncheckedCreateWithoutAgencyInput> | InvitationCreateWithoutAgencyInput[] | InvitationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutAgencyInput | InvitationCreateOrConnectWithoutAgencyInput[]
    createMany?: InvitationCreateManyAgencyInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutAgencyInput = {
    create?: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput> | NotificationCreateWithoutAgencyInput[] | NotificationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAgencyInput | NotificationCreateOrConnectWithoutAgencyInput[]
    createMany?: NotificationCreateManyAgencyInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutAgencyInput = {
    create?: XOR<SubscriptionCreateWithoutAgencyInput, SubscriptionUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutAgencyInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type AddOnsCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput> | AddOnsCreateWithoutAgencyInput[] | AddOnsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AddOnsCreateOrConnectWithoutAgencyInput | AddOnsCreateOrConnectWithoutAgencyInput[]
    createMany?: AddOnsCreateManyAgencyInputEnvelope
    connect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput> | UserCreateWithoutAgencyInput[] | UserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAgencyInput | UserCreateOrConnectWithoutAgencyInput[]
    createMany?: UserCreateManyAgencyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SubAccountUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<SubAccountCreateWithoutAgencyInput, SubAccountUncheckedCreateWithoutAgencyInput> | SubAccountCreateWithoutAgencyInput[] | SubAccountUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutAgencyInput | SubAccountCreateOrConnectWithoutAgencyInput[]
    createMany?: SubAccountCreateManyAgencyInputEnvelope
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
  }

  export type AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput> | AgencySidebarOptionCreateWithoutAgencyInput[] | AgencySidebarOptionUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutAgencyInput | AgencySidebarOptionCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencySidebarOptionCreateManyAgencyInputEnvelope
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<InvitationCreateWithoutAgencyInput, InvitationUncheckedCreateWithoutAgencyInput> | InvitationCreateWithoutAgencyInput[] | InvitationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutAgencyInput | InvitationCreateOrConnectWithoutAgencyInput[]
    createMany?: InvitationCreateManyAgencyInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput> | NotificationCreateWithoutAgencyInput[] | NotificationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAgencyInput | NotificationCreateOrConnectWithoutAgencyInput[]
    createMany?: NotificationCreateManyAgencyInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutAgencyInput = {
    create?: XOR<SubscriptionCreateWithoutAgencyInput, SubscriptionUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutAgencyInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type AddOnsUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput> | AddOnsCreateWithoutAgencyInput[] | AddOnsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AddOnsCreateOrConnectWithoutAgencyInput | AddOnsCreateOrConnectWithoutAgencyInput[]
    createMany?: AddOnsCreateManyAgencyInputEnvelope
    connect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput> | UserCreateWithoutAgencyInput[] | UserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAgencyInput | UserCreateOrConnectWithoutAgencyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAgencyInput | UserUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: UserCreateManyAgencyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAgencyInput | UserUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAgencyInput | UserUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SubAccountUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<SubAccountCreateWithoutAgencyInput, SubAccountUncheckedCreateWithoutAgencyInput> | SubAccountCreateWithoutAgencyInput[] | SubAccountUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutAgencyInput | SubAccountCreateOrConnectWithoutAgencyInput[]
    upsert?: SubAccountUpsertWithWhereUniqueWithoutAgencyInput | SubAccountUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: SubAccountCreateManyAgencyInputEnvelope
    set?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    disconnect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    delete?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    update?: SubAccountUpdateWithWhereUniqueWithoutAgencyInput | SubAccountUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: SubAccountUpdateManyWithWhereWithoutAgencyInput | SubAccountUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
  }

  export type AgencySidebarOptionUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput> | AgencySidebarOptionCreateWithoutAgencyInput[] | AgencySidebarOptionUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutAgencyInput | AgencySidebarOptionCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencySidebarOptionUpsertWithWhereUniqueWithoutAgencyInput | AgencySidebarOptionUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencySidebarOptionCreateManyAgencyInputEnvelope
    set?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    disconnect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    delete?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    update?: AgencySidebarOptionUpdateWithWhereUniqueWithoutAgencyInput | AgencySidebarOptionUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencySidebarOptionUpdateManyWithWhereWithoutAgencyInput | AgencySidebarOptionUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencySidebarOptionScalarWhereInput | AgencySidebarOptionScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<InvitationCreateWithoutAgencyInput, InvitationUncheckedCreateWithoutAgencyInput> | InvitationCreateWithoutAgencyInput[] | InvitationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutAgencyInput | InvitationCreateOrConnectWithoutAgencyInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutAgencyInput | InvitationUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: InvitationCreateManyAgencyInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutAgencyInput | InvitationUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutAgencyInput | InvitationUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput> | NotificationCreateWithoutAgencyInput[] | NotificationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAgencyInput | NotificationCreateOrConnectWithoutAgencyInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAgencyInput | NotificationUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: NotificationCreateManyAgencyInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAgencyInput | NotificationUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAgencyInput | NotificationUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutAgencyNestedInput = {
    create?: XOR<SubscriptionCreateWithoutAgencyInput, SubscriptionUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutAgencyInput
    upsert?: SubscriptionUpsertWithoutAgencyInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutAgencyInput, SubscriptionUpdateWithoutAgencyInput>, SubscriptionUncheckedUpdateWithoutAgencyInput>
  }

  export type AddOnsUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput> | AddOnsCreateWithoutAgencyInput[] | AddOnsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AddOnsCreateOrConnectWithoutAgencyInput | AddOnsCreateOrConnectWithoutAgencyInput[]
    upsert?: AddOnsUpsertWithWhereUniqueWithoutAgencyInput | AddOnsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AddOnsCreateManyAgencyInputEnvelope
    set?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    disconnect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    delete?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    connect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    update?: AddOnsUpdateWithWhereUniqueWithoutAgencyInput | AddOnsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AddOnsUpdateManyWithWhereWithoutAgencyInput | AddOnsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AddOnsScalarWhereInput | AddOnsScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput> | UserCreateWithoutAgencyInput[] | UserUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAgencyInput | UserCreateOrConnectWithoutAgencyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAgencyInput | UserUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: UserCreateManyAgencyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAgencyInput | UserUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAgencyInput | UserUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SubAccountUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<SubAccountCreateWithoutAgencyInput, SubAccountUncheckedCreateWithoutAgencyInput> | SubAccountCreateWithoutAgencyInput[] | SubAccountUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutAgencyInput | SubAccountCreateOrConnectWithoutAgencyInput[]
    upsert?: SubAccountUpsertWithWhereUniqueWithoutAgencyInput | SubAccountUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: SubAccountCreateManyAgencyInputEnvelope
    set?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    disconnect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    delete?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    update?: SubAccountUpdateWithWhereUniqueWithoutAgencyInput | SubAccountUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: SubAccountUpdateManyWithWhereWithoutAgencyInput | SubAccountUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
  }

  export type AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput> | AgencySidebarOptionCreateWithoutAgencyInput[] | AgencySidebarOptionUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutAgencyInput | AgencySidebarOptionCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencySidebarOptionUpsertWithWhereUniqueWithoutAgencyInput | AgencySidebarOptionUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencySidebarOptionCreateManyAgencyInputEnvelope
    set?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    disconnect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    delete?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    update?: AgencySidebarOptionUpdateWithWhereUniqueWithoutAgencyInput | AgencySidebarOptionUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencySidebarOptionUpdateManyWithWhereWithoutAgencyInput | AgencySidebarOptionUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencySidebarOptionScalarWhereInput | AgencySidebarOptionScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<InvitationCreateWithoutAgencyInput, InvitationUncheckedCreateWithoutAgencyInput> | InvitationCreateWithoutAgencyInput[] | InvitationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutAgencyInput | InvitationCreateOrConnectWithoutAgencyInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutAgencyInput | InvitationUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: InvitationCreateManyAgencyInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutAgencyInput | InvitationUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutAgencyInput | InvitationUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput> | NotificationCreateWithoutAgencyInput[] | NotificationUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAgencyInput | NotificationCreateOrConnectWithoutAgencyInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAgencyInput | NotificationUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: NotificationCreateManyAgencyInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAgencyInput | NotificationUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAgencyInput | NotificationUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput = {
    create?: XOR<SubscriptionCreateWithoutAgencyInput, SubscriptionUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutAgencyInput
    upsert?: SubscriptionUpsertWithoutAgencyInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutAgencyInput, SubscriptionUpdateWithoutAgencyInput>, SubscriptionUncheckedUpdateWithoutAgencyInput>
  }

  export type AddOnsUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput> | AddOnsCreateWithoutAgencyInput[] | AddOnsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AddOnsCreateOrConnectWithoutAgencyInput | AddOnsCreateOrConnectWithoutAgencyInput[]
    upsert?: AddOnsUpsertWithWhereUniqueWithoutAgencyInput | AddOnsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AddOnsCreateManyAgencyInputEnvelope
    set?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    disconnect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    delete?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    connect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    update?: AddOnsUpdateWithWhereUniqueWithoutAgencyInput | AddOnsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AddOnsUpdateManyWithWhereWithoutAgencyInput | AddOnsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AddOnsScalarWhereInput | AddOnsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type SubAccountCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<SubAccountCreateWithoutPermissionsInput, SubAccountUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutPermissionsInput
    connect?: SubAccountWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    upsert?: UserUpsertWithoutPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPermissionsInput, UserUpdateWithoutPermissionsInput>, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type SubAccountUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<SubAccountCreateWithoutPermissionsInput, SubAccountUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutPermissionsInput
    upsert?: SubAccountUpsertWithoutPermissionsInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutPermissionsInput, SubAccountUpdateWithoutPermissionsInput>, SubAccountUncheckedUpdateWithoutPermissionsInput>
  }

  export type AgencyCreateNestedOneWithoutSubAccountInput = {
    create?: XOR<AgencyCreateWithoutSubAccountInput, AgencyUncheckedCreateWithoutSubAccountInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSubAccountInput
    connect?: AgencyWhereUniqueInput
  }

  export type SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput> | SubAccountSidebarOptionCreateWithoutSubAccountInput[] | SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput | SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput[]
    createMany?: SubAccountSidebarOptionCreateManySubAccountInputEnvelope
    connect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
  }

  export type PermissionsCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<PermissionsCreateWithoutSubAccountInput, PermissionsUncheckedCreateWithoutSubAccountInput> | PermissionsCreateWithoutSubAccountInput[] | PermissionsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutSubAccountInput | PermissionsCreateOrConnectWithoutSubAccountInput[]
    createMany?: PermissionsCreateManySubAccountInputEnvelope
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
  }

  export type FunnelsCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<FunnelsCreateWithoutSubAccountInput, FunnelsUncheckedCreateWithoutSubAccountInput> | FunnelsCreateWithoutSubAccountInput[] | FunnelsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: FunnelsCreateOrConnectWithoutSubAccountInput | FunnelsCreateOrConnectWithoutSubAccountInput[]
    createMany?: FunnelsCreateManySubAccountInputEnvelope
    connect?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
  }

  export type MediaCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<MediaCreateWithoutSubAccountInput, MediaUncheckedCreateWithoutSubAccountInput> | MediaCreateWithoutSubAccountInput[] | MediaUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutSubAccountInput | MediaCreateOrConnectWithoutSubAccountInput[]
    createMany?: MediaCreateManySubAccountInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<ContactCreateWithoutSubAccountInput, ContactUncheckedCreateWithoutSubAccountInput> | ContactCreateWithoutSubAccountInput[] | ContactUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutSubAccountInput | ContactCreateOrConnectWithoutSubAccountInput[]
    createMany?: ContactCreateManySubAccountInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type TriggerCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<TriggerCreateWithoutSubAccountInput, TriggerUncheckedCreateWithoutSubAccountInput> | TriggerCreateWithoutSubAccountInput[] | TriggerUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutSubAccountInput | TriggerCreateOrConnectWithoutSubAccountInput[]
    createMany?: TriggerCreateManySubAccountInputEnvelope
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
  }

  export type AutomationCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<AutomationCreateWithoutSubAccountInput, AutomationUncheckedCreateWithoutSubAccountInput> | AutomationCreateWithoutSubAccountInput[] | AutomationUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutSubAccountInput | AutomationCreateOrConnectWithoutSubAccountInput[]
    createMany?: AutomationCreateManySubAccountInputEnvelope
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
  }

  export type PipelineCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<PipelineCreateWithoutSubAccountInput, PipelineUncheckedCreateWithoutSubAccountInput> | PipelineCreateWithoutSubAccountInput[] | PipelineUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutSubAccountInput | PipelineCreateOrConnectWithoutSubAccountInput[]
    createMany?: PipelineCreateManySubAccountInputEnvelope
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
  }

  export type TagsCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<TagsCreateWithoutSubAccountInput, TagsUncheckedCreateWithoutSubAccountInput> | TagsCreateWithoutSubAccountInput[] | TagsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutSubAccountInput | TagsCreateOrConnectWithoutSubAccountInput[]
    createMany?: TagsCreateManySubAccountInputEnvelope
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<NotificationCreateWithoutSubAccountInput, NotificationUncheckedCreateWithoutSubAccountInput> | NotificationCreateWithoutSubAccountInput[] | NotificationUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSubAccountInput | NotificationCreateOrConnectWithoutSubAccountInput[]
    createMany?: NotificationCreateManySubAccountInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput> | SubAccountSidebarOptionCreateWithoutSubAccountInput[] | SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput | SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput[]
    createMany?: SubAccountSidebarOptionCreateManySubAccountInputEnvelope
    connect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
  }

  export type PermissionsUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<PermissionsCreateWithoutSubAccountInput, PermissionsUncheckedCreateWithoutSubAccountInput> | PermissionsCreateWithoutSubAccountInput[] | PermissionsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutSubAccountInput | PermissionsCreateOrConnectWithoutSubAccountInput[]
    createMany?: PermissionsCreateManySubAccountInputEnvelope
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
  }

  export type FunnelsUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<FunnelsCreateWithoutSubAccountInput, FunnelsUncheckedCreateWithoutSubAccountInput> | FunnelsCreateWithoutSubAccountInput[] | FunnelsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: FunnelsCreateOrConnectWithoutSubAccountInput | FunnelsCreateOrConnectWithoutSubAccountInput[]
    createMany?: FunnelsCreateManySubAccountInputEnvelope
    connect?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<MediaCreateWithoutSubAccountInput, MediaUncheckedCreateWithoutSubAccountInput> | MediaCreateWithoutSubAccountInput[] | MediaUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutSubAccountInput | MediaCreateOrConnectWithoutSubAccountInput[]
    createMany?: MediaCreateManySubAccountInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<ContactCreateWithoutSubAccountInput, ContactUncheckedCreateWithoutSubAccountInput> | ContactCreateWithoutSubAccountInput[] | ContactUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutSubAccountInput | ContactCreateOrConnectWithoutSubAccountInput[]
    createMany?: ContactCreateManySubAccountInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type TriggerUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<TriggerCreateWithoutSubAccountInput, TriggerUncheckedCreateWithoutSubAccountInput> | TriggerCreateWithoutSubAccountInput[] | TriggerUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutSubAccountInput | TriggerCreateOrConnectWithoutSubAccountInput[]
    createMany?: TriggerCreateManySubAccountInputEnvelope
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
  }

  export type AutomationUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<AutomationCreateWithoutSubAccountInput, AutomationUncheckedCreateWithoutSubAccountInput> | AutomationCreateWithoutSubAccountInput[] | AutomationUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutSubAccountInput | AutomationCreateOrConnectWithoutSubAccountInput[]
    createMany?: AutomationCreateManySubAccountInputEnvelope
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
  }

  export type PipelineUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<PipelineCreateWithoutSubAccountInput, PipelineUncheckedCreateWithoutSubAccountInput> | PipelineCreateWithoutSubAccountInput[] | PipelineUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutSubAccountInput | PipelineCreateOrConnectWithoutSubAccountInput[]
    createMany?: PipelineCreateManySubAccountInputEnvelope
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
  }

  export type TagsUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<TagsCreateWithoutSubAccountInput, TagsUncheckedCreateWithoutSubAccountInput> | TagsCreateWithoutSubAccountInput[] | TagsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutSubAccountInput | TagsCreateOrConnectWithoutSubAccountInput[]
    createMany?: TagsCreateManySubAccountInputEnvelope
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<NotificationCreateWithoutSubAccountInput, NotificationUncheckedCreateWithoutSubAccountInput> | NotificationCreateWithoutSubAccountInput[] | NotificationUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSubAccountInput | NotificationCreateOrConnectWithoutSubAccountInput[]
    createMany?: NotificationCreateManySubAccountInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AgencyUpdateOneRequiredWithoutSubAccountNestedInput = {
    create?: XOR<AgencyCreateWithoutSubAccountInput, AgencyUncheckedCreateWithoutSubAccountInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSubAccountInput
    upsert?: AgencyUpsertWithoutSubAccountInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutSubAccountInput, AgencyUpdateWithoutSubAccountInput>, AgencyUncheckedUpdateWithoutSubAccountInput>
  }

  export type SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput> | SubAccountSidebarOptionCreateWithoutSubAccountInput[] | SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput | SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput[]
    upsert?: SubAccountSidebarOptionUpsertWithWhereUniqueWithoutSubAccountInput | SubAccountSidebarOptionUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: SubAccountSidebarOptionCreateManySubAccountInputEnvelope
    set?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    disconnect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    delete?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    connect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    update?: SubAccountSidebarOptionUpdateWithWhereUniqueWithoutSubAccountInput | SubAccountSidebarOptionUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: SubAccountSidebarOptionUpdateManyWithWhereWithoutSubAccountInput | SubAccountSidebarOptionUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: SubAccountSidebarOptionScalarWhereInput | SubAccountSidebarOptionScalarWhereInput[]
  }

  export type PermissionsUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<PermissionsCreateWithoutSubAccountInput, PermissionsUncheckedCreateWithoutSubAccountInput> | PermissionsCreateWithoutSubAccountInput[] | PermissionsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutSubAccountInput | PermissionsCreateOrConnectWithoutSubAccountInput[]
    upsert?: PermissionsUpsertWithWhereUniqueWithoutSubAccountInput | PermissionsUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: PermissionsCreateManySubAccountInputEnvelope
    set?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    disconnect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    delete?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    update?: PermissionsUpdateWithWhereUniqueWithoutSubAccountInput | PermissionsUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: PermissionsUpdateManyWithWhereWithoutSubAccountInput | PermissionsUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
  }

  export type FunnelsUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<FunnelsCreateWithoutSubAccountInput, FunnelsUncheckedCreateWithoutSubAccountInput> | FunnelsCreateWithoutSubAccountInput[] | FunnelsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: FunnelsCreateOrConnectWithoutSubAccountInput | FunnelsCreateOrConnectWithoutSubAccountInput[]
    upsert?: FunnelsUpsertWithWhereUniqueWithoutSubAccountInput | FunnelsUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: FunnelsCreateManySubAccountInputEnvelope
    set?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    disconnect?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    delete?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    connect?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    update?: FunnelsUpdateWithWhereUniqueWithoutSubAccountInput | FunnelsUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: FunnelsUpdateManyWithWhereWithoutSubAccountInput | FunnelsUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: FunnelsScalarWhereInput | FunnelsScalarWhereInput[]
  }

  export type MediaUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<MediaCreateWithoutSubAccountInput, MediaUncheckedCreateWithoutSubAccountInput> | MediaCreateWithoutSubAccountInput[] | MediaUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutSubAccountInput | MediaCreateOrConnectWithoutSubAccountInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutSubAccountInput | MediaUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: MediaCreateManySubAccountInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutSubAccountInput | MediaUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutSubAccountInput | MediaUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<ContactCreateWithoutSubAccountInput, ContactUncheckedCreateWithoutSubAccountInput> | ContactCreateWithoutSubAccountInput[] | ContactUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutSubAccountInput | ContactCreateOrConnectWithoutSubAccountInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutSubAccountInput | ContactUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: ContactCreateManySubAccountInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutSubAccountInput | ContactUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutSubAccountInput | ContactUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type TriggerUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<TriggerCreateWithoutSubAccountInput, TriggerUncheckedCreateWithoutSubAccountInput> | TriggerCreateWithoutSubAccountInput[] | TriggerUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutSubAccountInput | TriggerCreateOrConnectWithoutSubAccountInput[]
    upsert?: TriggerUpsertWithWhereUniqueWithoutSubAccountInput | TriggerUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: TriggerCreateManySubAccountInputEnvelope
    set?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    disconnect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    delete?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    update?: TriggerUpdateWithWhereUniqueWithoutSubAccountInput | TriggerUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: TriggerUpdateManyWithWhereWithoutSubAccountInput | TriggerUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
  }

  export type AutomationUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<AutomationCreateWithoutSubAccountInput, AutomationUncheckedCreateWithoutSubAccountInput> | AutomationCreateWithoutSubAccountInput[] | AutomationUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutSubAccountInput | AutomationCreateOrConnectWithoutSubAccountInput[]
    upsert?: AutomationUpsertWithWhereUniqueWithoutSubAccountInput | AutomationUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: AutomationCreateManySubAccountInputEnvelope
    set?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    disconnect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    delete?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    update?: AutomationUpdateWithWhereUniqueWithoutSubAccountInput | AutomationUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: AutomationUpdateManyWithWhereWithoutSubAccountInput | AutomationUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
  }

  export type PipelineUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<PipelineCreateWithoutSubAccountInput, PipelineUncheckedCreateWithoutSubAccountInput> | PipelineCreateWithoutSubAccountInput[] | PipelineUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutSubAccountInput | PipelineCreateOrConnectWithoutSubAccountInput[]
    upsert?: PipelineUpsertWithWhereUniqueWithoutSubAccountInput | PipelineUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: PipelineCreateManySubAccountInputEnvelope
    set?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    disconnect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    delete?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    update?: PipelineUpdateWithWhereUniqueWithoutSubAccountInput | PipelineUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: PipelineUpdateManyWithWhereWithoutSubAccountInput | PipelineUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
  }

  export type TagsUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<TagsCreateWithoutSubAccountInput, TagsUncheckedCreateWithoutSubAccountInput> | TagsCreateWithoutSubAccountInput[] | TagsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutSubAccountInput | TagsCreateOrConnectWithoutSubAccountInput[]
    upsert?: TagsUpsertWithWhereUniqueWithoutSubAccountInput | TagsUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: TagsCreateManySubAccountInputEnvelope
    set?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    disconnect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    delete?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    update?: TagsUpdateWithWhereUniqueWithoutSubAccountInput | TagsUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: TagsUpdateManyWithWhereWithoutSubAccountInput | TagsUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: TagsScalarWhereInput | TagsScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<NotificationCreateWithoutSubAccountInput, NotificationUncheckedCreateWithoutSubAccountInput> | NotificationCreateWithoutSubAccountInput[] | NotificationUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSubAccountInput | NotificationCreateOrConnectWithoutSubAccountInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSubAccountInput | NotificationUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: NotificationCreateManySubAccountInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSubAccountInput | NotificationUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSubAccountInput | NotificationUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput> | SubAccountSidebarOptionCreateWithoutSubAccountInput[] | SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput | SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput[]
    upsert?: SubAccountSidebarOptionUpsertWithWhereUniqueWithoutSubAccountInput | SubAccountSidebarOptionUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: SubAccountSidebarOptionCreateManySubAccountInputEnvelope
    set?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    disconnect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    delete?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    connect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    update?: SubAccountSidebarOptionUpdateWithWhereUniqueWithoutSubAccountInput | SubAccountSidebarOptionUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: SubAccountSidebarOptionUpdateManyWithWhereWithoutSubAccountInput | SubAccountSidebarOptionUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: SubAccountSidebarOptionScalarWhereInput | SubAccountSidebarOptionScalarWhereInput[]
  }

  export type PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<PermissionsCreateWithoutSubAccountInput, PermissionsUncheckedCreateWithoutSubAccountInput> | PermissionsCreateWithoutSubAccountInput[] | PermissionsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutSubAccountInput | PermissionsCreateOrConnectWithoutSubAccountInput[]
    upsert?: PermissionsUpsertWithWhereUniqueWithoutSubAccountInput | PermissionsUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: PermissionsCreateManySubAccountInputEnvelope
    set?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    disconnect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    delete?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    update?: PermissionsUpdateWithWhereUniqueWithoutSubAccountInput | PermissionsUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: PermissionsUpdateManyWithWhereWithoutSubAccountInput | PermissionsUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
  }

  export type FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<FunnelsCreateWithoutSubAccountInput, FunnelsUncheckedCreateWithoutSubAccountInput> | FunnelsCreateWithoutSubAccountInput[] | FunnelsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: FunnelsCreateOrConnectWithoutSubAccountInput | FunnelsCreateOrConnectWithoutSubAccountInput[]
    upsert?: FunnelsUpsertWithWhereUniqueWithoutSubAccountInput | FunnelsUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: FunnelsCreateManySubAccountInputEnvelope
    set?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    disconnect?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    delete?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    connect?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    update?: FunnelsUpdateWithWhereUniqueWithoutSubAccountInput | FunnelsUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: FunnelsUpdateManyWithWhereWithoutSubAccountInput | FunnelsUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: FunnelsScalarWhereInput | FunnelsScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<MediaCreateWithoutSubAccountInput, MediaUncheckedCreateWithoutSubAccountInput> | MediaCreateWithoutSubAccountInput[] | MediaUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutSubAccountInput | MediaCreateOrConnectWithoutSubAccountInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutSubAccountInput | MediaUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: MediaCreateManySubAccountInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutSubAccountInput | MediaUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutSubAccountInput | MediaUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<ContactCreateWithoutSubAccountInput, ContactUncheckedCreateWithoutSubAccountInput> | ContactCreateWithoutSubAccountInput[] | ContactUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutSubAccountInput | ContactCreateOrConnectWithoutSubAccountInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutSubAccountInput | ContactUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: ContactCreateManySubAccountInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutSubAccountInput | ContactUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutSubAccountInput | ContactUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type TriggerUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<TriggerCreateWithoutSubAccountInput, TriggerUncheckedCreateWithoutSubAccountInput> | TriggerCreateWithoutSubAccountInput[] | TriggerUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: TriggerCreateOrConnectWithoutSubAccountInput | TriggerCreateOrConnectWithoutSubAccountInput[]
    upsert?: TriggerUpsertWithWhereUniqueWithoutSubAccountInput | TriggerUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: TriggerCreateManySubAccountInputEnvelope
    set?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    disconnect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    delete?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    connect?: TriggerWhereUniqueInput | TriggerWhereUniqueInput[]
    update?: TriggerUpdateWithWhereUniqueWithoutSubAccountInput | TriggerUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: TriggerUpdateManyWithWhereWithoutSubAccountInput | TriggerUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
  }

  export type AutomationUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<AutomationCreateWithoutSubAccountInput, AutomationUncheckedCreateWithoutSubAccountInput> | AutomationCreateWithoutSubAccountInput[] | AutomationUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutSubAccountInput | AutomationCreateOrConnectWithoutSubAccountInput[]
    upsert?: AutomationUpsertWithWhereUniqueWithoutSubAccountInput | AutomationUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: AutomationCreateManySubAccountInputEnvelope
    set?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    disconnect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    delete?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    update?: AutomationUpdateWithWhereUniqueWithoutSubAccountInput | AutomationUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: AutomationUpdateManyWithWhereWithoutSubAccountInput | AutomationUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
  }

  export type PipelineUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<PipelineCreateWithoutSubAccountInput, PipelineUncheckedCreateWithoutSubAccountInput> | PipelineCreateWithoutSubAccountInput[] | PipelineUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutSubAccountInput | PipelineCreateOrConnectWithoutSubAccountInput[]
    upsert?: PipelineUpsertWithWhereUniqueWithoutSubAccountInput | PipelineUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: PipelineCreateManySubAccountInputEnvelope
    set?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    disconnect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    delete?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    update?: PipelineUpdateWithWhereUniqueWithoutSubAccountInput | PipelineUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: PipelineUpdateManyWithWhereWithoutSubAccountInput | PipelineUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
  }

  export type TagsUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<TagsCreateWithoutSubAccountInput, TagsUncheckedCreateWithoutSubAccountInput> | TagsCreateWithoutSubAccountInput[] | TagsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutSubAccountInput | TagsCreateOrConnectWithoutSubAccountInput[]
    upsert?: TagsUpsertWithWhereUniqueWithoutSubAccountInput | TagsUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: TagsCreateManySubAccountInputEnvelope
    set?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    disconnect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    delete?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    update?: TagsUpdateWithWhereUniqueWithoutSubAccountInput | TagsUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: TagsUpdateManyWithWhereWithoutSubAccountInput | TagsUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: TagsScalarWhereInput | TagsScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<NotificationCreateWithoutSubAccountInput, NotificationUncheckedCreateWithoutSubAccountInput> | NotificationCreateWithoutSubAccountInput[] | NotificationUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSubAccountInput | NotificationCreateOrConnectWithoutSubAccountInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSubAccountInput | NotificationUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: NotificationCreateManySubAccountInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSubAccountInput | NotificationUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSubAccountInput | NotificationUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SubAccountCreateNestedOneWithoutTagsInput = {
    create?: XOR<SubAccountCreateWithoutTagsInput, SubAccountUncheckedCreateWithoutTagsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutTagsInput
    connect?: SubAccountWhereUniqueInput
  }

  export type TicketsCreateNestedOneWithoutTagsInput = {
    create?: XOR<TicketsCreateWithoutTagsInput, TicketsUncheckedCreateWithoutTagsInput>
    connectOrCreate?: TicketsCreateOrConnectWithoutTagsInput
    connect?: TicketsWhereUniqueInput
  }

  export type SubAccountUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<SubAccountCreateWithoutTagsInput, SubAccountUncheckedCreateWithoutTagsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutTagsInput
    upsert?: SubAccountUpsertWithoutTagsInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutTagsInput, SubAccountUpdateWithoutTagsInput>, SubAccountUncheckedUpdateWithoutTagsInput>
  }

  export type TicketsUpdateOneWithoutTagsNestedInput = {
    create?: XOR<TicketsCreateWithoutTagsInput, TicketsUncheckedCreateWithoutTagsInput>
    connectOrCreate?: TicketsCreateOrConnectWithoutTagsInput
    upsert?: TicketsUpsertWithoutTagsInput
    disconnect?: TicketsWhereInput | boolean
    delete?: TicketsWhereInput | boolean
    connect?: TicketsWhereUniqueInput
    update?: XOR<XOR<TicketsUpdateToOneWithWhereWithoutTagsInput, TicketsUpdateWithoutTagsInput>, TicketsUncheckedUpdateWithoutTagsInput>
  }

  export type LaneCreateNestedManyWithoutPipelineInput = {
    create?: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput> | LaneCreateWithoutPipelineInput[] | LaneUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: LaneCreateOrConnectWithoutPipelineInput | LaneCreateOrConnectWithoutPipelineInput[]
    createMany?: LaneCreateManyPipelineInputEnvelope
    connect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
  }

  export type SubAccountCreateNestedOneWithoutPipelineInput = {
    create?: XOR<SubAccountCreateWithoutPipelineInput, SubAccountUncheckedCreateWithoutPipelineInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutPipelineInput
    connect?: SubAccountWhereUniqueInput
  }

  export type LaneUncheckedCreateNestedManyWithoutPipelineInput = {
    create?: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput> | LaneCreateWithoutPipelineInput[] | LaneUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: LaneCreateOrConnectWithoutPipelineInput | LaneCreateOrConnectWithoutPipelineInput[]
    createMany?: LaneCreateManyPipelineInputEnvelope
    connect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
  }

  export type LaneUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput> | LaneCreateWithoutPipelineInput[] | LaneUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: LaneCreateOrConnectWithoutPipelineInput | LaneCreateOrConnectWithoutPipelineInput[]
    upsert?: LaneUpsertWithWhereUniqueWithoutPipelineInput | LaneUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: LaneCreateManyPipelineInputEnvelope
    set?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    disconnect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    delete?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    connect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    update?: LaneUpdateWithWhereUniqueWithoutPipelineInput | LaneUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: LaneUpdateManyWithWhereWithoutPipelineInput | LaneUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: LaneScalarWhereInput | LaneScalarWhereInput[]
  }

  export type SubAccountUpdateOneRequiredWithoutPipelineNestedInput = {
    create?: XOR<SubAccountCreateWithoutPipelineInput, SubAccountUncheckedCreateWithoutPipelineInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutPipelineInput
    upsert?: SubAccountUpsertWithoutPipelineInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutPipelineInput, SubAccountUpdateWithoutPipelineInput>, SubAccountUncheckedUpdateWithoutPipelineInput>
  }

  export type LaneUncheckedUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput> | LaneCreateWithoutPipelineInput[] | LaneUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: LaneCreateOrConnectWithoutPipelineInput | LaneCreateOrConnectWithoutPipelineInput[]
    upsert?: LaneUpsertWithWhereUniqueWithoutPipelineInput | LaneUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: LaneCreateManyPipelineInputEnvelope
    set?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    disconnect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    delete?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    connect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    update?: LaneUpdateWithWhereUniqueWithoutPipelineInput | LaneUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: LaneUpdateManyWithWhereWithoutPipelineInput | LaneUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: LaneScalarWhereInput | LaneScalarWhereInput[]
  }

  export type PipelineCreateNestedOneWithoutLaneInput = {
    create?: XOR<PipelineCreateWithoutLaneInput, PipelineUncheckedCreateWithoutLaneInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutLaneInput
    connect?: PipelineWhereUniqueInput
  }

  export type TicketsCreateNestedManyWithoutLaneInput = {
    create?: XOR<TicketsCreateWithoutLaneInput, TicketsUncheckedCreateWithoutLaneInput> | TicketsCreateWithoutLaneInput[] | TicketsUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutLaneInput | TicketsCreateOrConnectWithoutLaneInput[]
    createMany?: TicketsCreateManyLaneInputEnvelope
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type TicketsUncheckedCreateNestedManyWithoutLaneInput = {
    create?: XOR<TicketsCreateWithoutLaneInput, TicketsUncheckedCreateWithoutLaneInput> | TicketsCreateWithoutLaneInput[] | TicketsUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutLaneInput | TicketsCreateOrConnectWithoutLaneInput[]
    createMany?: TicketsCreateManyLaneInputEnvelope
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type PipelineUpdateOneRequiredWithoutLaneNestedInput = {
    create?: XOR<PipelineCreateWithoutLaneInput, PipelineUncheckedCreateWithoutLaneInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutLaneInput
    upsert?: PipelineUpsertWithoutLaneInput
    connect?: PipelineWhereUniqueInput
    update?: XOR<XOR<PipelineUpdateToOneWithWhereWithoutLaneInput, PipelineUpdateWithoutLaneInput>, PipelineUncheckedUpdateWithoutLaneInput>
  }

  export type TicketsUpdateManyWithoutLaneNestedInput = {
    create?: XOR<TicketsCreateWithoutLaneInput, TicketsUncheckedCreateWithoutLaneInput> | TicketsCreateWithoutLaneInput[] | TicketsUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutLaneInput | TicketsCreateOrConnectWithoutLaneInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutLaneInput | TicketsUpsertWithWhereUniqueWithoutLaneInput[]
    createMany?: TicketsCreateManyLaneInputEnvelope
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutLaneInput | TicketsUpdateWithWhereUniqueWithoutLaneInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutLaneInput | TicketsUpdateManyWithWhereWithoutLaneInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type TicketsUncheckedUpdateManyWithoutLaneNestedInput = {
    create?: XOR<TicketsCreateWithoutLaneInput, TicketsUncheckedCreateWithoutLaneInput> | TicketsCreateWithoutLaneInput[] | TicketsUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutLaneInput | TicketsCreateOrConnectWithoutLaneInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutLaneInput | TicketsUpsertWithWhereUniqueWithoutLaneInput[]
    createMany?: TicketsCreateManyLaneInputEnvelope
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutLaneInput | TicketsUpdateWithWhereUniqueWithoutLaneInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutLaneInput | TicketsUpdateManyWithWhereWithoutLaneInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type LaneCreateNestedOneWithoutTicketsInput = {
    create?: XOR<LaneCreateWithoutTicketsInput, LaneUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: LaneCreateOrConnectWithoutTicketsInput
    connect?: LaneWhereUniqueInput
  }

  export type TagsCreateNestedManyWithoutTicketsInput = {
    create?: XOR<TagsCreateWithoutTicketsInput, TagsUncheckedCreateWithoutTicketsInput> | TagsCreateWithoutTicketsInput[] | TagsUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutTicketsInput | TagsCreateOrConnectWithoutTicketsInput[]
    createMany?: TagsCreateManyTicketsInputEnvelope
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
  }

  export type ContactCreateNestedOneWithoutTicketsInput = {
    create?: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTicketsInput
    connect?: ContactWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketsInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type TagsUncheckedCreateNestedManyWithoutTicketsInput = {
    create?: XOR<TagsCreateWithoutTicketsInput, TagsUncheckedCreateWithoutTicketsInput> | TagsCreateWithoutTicketsInput[] | TagsUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutTicketsInput | TagsCreateOrConnectWithoutTicketsInput[]
    createMany?: TagsCreateManyTicketsInputEnvelope
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type LaneUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<LaneCreateWithoutTicketsInput, LaneUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: LaneCreateOrConnectWithoutTicketsInput
    upsert?: LaneUpsertWithoutTicketsInput
    connect?: LaneWhereUniqueInput
    update?: XOR<XOR<LaneUpdateToOneWithWhereWithoutTicketsInput, LaneUpdateWithoutTicketsInput>, LaneUncheckedUpdateWithoutTicketsInput>
  }

  export type TagsUpdateManyWithoutTicketsNestedInput = {
    create?: XOR<TagsCreateWithoutTicketsInput, TagsUncheckedCreateWithoutTicketsInput> | TagsCreateWithoutTicketsInput[] | TagsUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutTicketsInput | TagsCreateOrConnectWithoutTicketsInput[]
    upsert?: TagsUpsertWithWhereUniqueWithoutTicketsInput | TagsUpsertWithWhereUniqueWithoutTicketsInput[]
    createMany?: TagsCreateManyTicketsInputEnvelope
    set?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    disconnect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    delete?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    update?: TagsUpdateWithWhereUniqueWithoutTicketsInput | TagsUpdateWithWhereUniqueWithoutTicketsInput[]
    updateMany?: TagsUpdateManyWithWhereWithoutTicketsInput | TagsUpdateManyWithWhereWithoutTicketsInput[]
    deleteMany?: TagsScalarWhereInput | TagsScalarWhereInput[]
  }

  export type ContactUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTicketsInput
    upsert?: ContactUpsertWithoutTicketsInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutTicketsInput, ContactUpdateWithoutTicketsInput>, ContactUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    upsert?: UserUpsertWithoutTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketsInput, UserUpdateWithoutTicketsInput>, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type TagsUncheckedUpdateManyWithoutTicketsNestedInput = {
    create?: XOR<TagsCreateWithoutTicketsInput, TagsUncheckedCreateWithoutTicketsInput> | TagsCreateWithoutTicketsInput[] | TagsUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutTicketsInput | TagsCreateOrConnectWithoutTicketsInput[]
    upsert?: TagsUpsertWithWhereUniqueWithoutTicketsInput | TagsUpsertWithWhereUniqueWithoutTicketsInput[]
    createMany?: TagsCreateManyTicketsInputEnvelope
    set?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    disconnect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    delete?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    update?: TagsUpdateWithWhereUniqueWithoutTicketsInput | TagsUpdateWithWhereUniqueWithoutTicketsInput[]
    updateMany?: TagsUpdateManyWithWhereWithoutTicketsInput | TagsUpdateManyWithWhereWithoutTicketsInput[]
    deleteMany?: TagsScalarWhereInput | TagsScalarWhereInput[]
  }

  export type SubAccountCreateNestedOneWithoutTriggerInput = {
    create?: XOR<SubAccountCreateWithoutTriggerInput, SubAccountUncheckedCreateWithoutTriggerInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutTriggerInput
    connect?: SubAccountWhereUniqueInput
  }

  export type AutomationCreateNestedManyWithoutTriggerInput = {
    create?: XOR<AutomationCreateWithoutTriggerInput, AutomationUncheckedCreateWithoutTriggerInput> | AutomationCreateWithoutTriggerInput[] | AutomationUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutTriggerInput | AutomationCreateOrConnectWithoutTriggerInput[]
    createMany?: AutomationCreateManyTriggerInputEnvelope
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
  }

  export type AutomationUncheckedCreateNestedManyWithoutTriggerInput = {
    create?: XOR<AutomationCreateWithoutTriggerInput, AutomationUncheckedCreateWithoutTriggerInput> | AutomationCreateWithoutTriggerInput[] | AutomationUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutTriggerInput | AutomationCreateOrConnectWithoutTriggerInput[]
    createMany?: AutomationCreateManyTriggerInputEnvelope
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
  }

  export type EnumTriggerTypesFieldUpdateOperationsInput = {
    set?: $Enums.TriggerTypes
  }

  export type SubAccountUpdateOneRequiredWithoutTriggerNestedInput = {
    create?: XOR<SubAccountCreateWithoutTriggerInput, SubAccountUncheckedCreateWithoutTriggerInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutTriggerInput
    upsert?: SubAccountUpsertWithoutTriggerInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutTriggerInput, SubAccountUpdateWithoutTriggerInput>, SubAccountUncheckedUpdateWithoutTriggerInput>
  }

  export type AutomationUpdateManyWithoutTriggerNestedInput = {
    create?: XOR<AutomationCreateWithoutTriggerInput, AutomationUncheckedCreateWithoutTriggerInput> | AutomationCreateWithoutTriggerInput[] | AutomationUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutTriggerInput | AutomationCreateOrConnectWithoutTriggerInput[]
    upsert?: AutomationUpsertWithWhereUniqueWithoutTriggerInput | AutomationUpsertWithWhereUniqueWithoutTriggerInput[]
    createMany?: AutomationCreateManyTriggerInputEnvelope
    set?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    disconnect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    delete?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    update?: AutomationUpdateWithWhereUniqueWithoutTriggerInput | AutomationUpdateWithWhereUniqueWithoutTriggerInput[]
    updateMany?: AutomationUpdateManyWithWhereWithoutTriggerInput | AutomationUpdateManyWithWhereWithoutTriggerInput[]
    deleteMany?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
  }

  export type AutomationUncheckedUpdateManyWithoutTriggerNestedInput = {
    create?: XOR<AutomationCreateWithoutTriggerInput, AutomationUncheckedCreateWithoutTriggerInput> | AutomationCreateWithoutTriggerInput[] | AutomationUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: AutomationCreateOrConnectWithoutTriggerInput | AutomationCreateOrConnectWithoutTriggerInput[]
    upsert?: AutomationUpsertWithWhereUniqueWithoutTriggerInput | AutomationUpsertWithWhereUniqueWithoutTriggerInput[]
    createMany?: AutomationCreateManyTriggerInputEnvelope
    set?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    disconnect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    delete?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    connect?: AutomationWhereUniqueInput | AutomationWhereUniqueInput[]
    update?: AutomationUpdateWithWhereUniqueWithoutTriggerInput | AutomationUpdateWithWhereUniqueWithoutTriggerInput[]
    updateMany?: AutomationUpdateManyWithWhereWithoutTriggerInput | AutomationUpdateManyWithWhereWithoutTriggerInput[]
    deleteMany?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
  }

  export type TriggerCreateNestedOneWithoutAutomationInput = {
    create?: XOR<TriggerCreateWithoutAutomationInput, TriggerUncheckedCreateWithoutAutomationInput>
    connectOrCreate?: TriggerCreateOrConnectWithoutAutomationInput
    connect?: TriggerWhereUniqueInput
  }

  export type SubAccountCreateNestedOneWithoutAutomationInput = {
    create?: XOR<SubAccountCreateWithoutAutomationInput, SubAccountUncheckedCreateWithoutAutomationInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutAutomationInput
    connect?: SubAccountWhereUniqueInput
  }

  export type ActionCreateNestedManyWithoutAutomationInput = {
    create?: XOR<ActionCreateWithoutAutomationInput, ActionUncheckedCreateWithoutAutomationInput> | ActionCreateWithoutAutomationInput[] | ActionUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutAutomationInput | ActionCreateOrConnectWithoutAutomationInput[]
    createMany?: ActionCreateManyAutomationInputEnvelope
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
  }

  export type AutomationInstanceCreateNestedManyWithoutAutomationInput = {
    create?: XOR<AutomationInstanceCreateWithoutAutomationInput, AutomationInstanceUncheckedCreateWithoutAutomationInput> | AutomationInstanceCreateWithoutAutomationInput[] | AutomationInstanceUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationInstanceCreateOrConnectWithoutAutomationInput | AutomationInstanceCreateOrConnectWithoutAutomationInput[]
    createMany?: AutomationInstanceCreateManyAutomationInputEnvelope
    connect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
  }

  export type ActionUncheckedCreateNestedManyWithoutAutomationInput = {
    create?: XOR<ActionCreateWithoutAutomationInput, ActionUncheckedCreateWithoutAutomationInput> | ActionCreateWithoutAutomationInput[] | ActionUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutAutomationInput | ActionCreateOrConnectWithoutAutomationInput[]
    createMany?: ActionCreateManyAutomationInputEnvelope
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
  }

  export type AutomationInstanceUncheckedCreateNestedManyWithoutAutomationInput = {
    create?: XOR<AutomationInstanceCreateWithoutAutomationInput, AutomationInstanceUncheckedCreateWithoutAutomationInput> | AutomationInstanceCreateWithoutAutomationInput[] | AutomationInstanceUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationInstanceCreateOrConnectWithoutAutomationInput | AutomationInstanceCreateOrConnectWithoutAutomationInput[]
    createMany?: AutomationInstanceCreateManyAutomationInputEnvelope
    connect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
  }

  export type TriggerUpdateOneWithoutAutomationNestedInput = {
    create?: XOR<TriggerCreateWithoutAutomationInput, TriggerUncheckedCreateWithoutAutomationInput>
    connectOrCreate?: TriggerCreateOrConnectWithoutAutomationInput
    upsert?: TriggerUpsertWithoutAutomationInput
    disconnect?: TriggerWhereInput | boolean
    delete?: TriggerWhereInput | boolean
    connect?: TriggerWhereUniqueInput
    update?: XOR<XOR<TriggerUpdateToOneWithWhereWithoutAutomationInput, TriggerUpdateWithoutAutomationInput>, TriggerUncheckedUpdateWithoutAutomationInput>
  }

  export type SubAccountUpdateOneRequiredWithoutAutomationNestedInput = {
    create?: XOR<SubAccountCreateWithoutAutomationInput, SubAccountUncheckedCreateWithoutAutomationInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutAutomationInput
    upsert?: SubAccountUpsertWithoutAutomationInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutAutomationInput, SubAccountUpdateWithoutAutomationInput>, SubAccountUncheckedUpdateWithoutAutomationInput>
  }

  export type ActionUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<ActionCreateWithoutAutomationInput, ActionUncheckedCreateWithoutAutomationInput> | ActionCreateWithoutAutomationInput[] | ActionUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutAutomationInput | ActionCreateOrConnectWithoutAutomationInput[]
    upsert?: ActionUpsertWithWhereUniqueWithoutAutomationInput | ActionUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: ActionCreateManyAutomationInputEnvelope
    set?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    disconnect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    delete?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    update?: ActionUpdateWithWhereUniqueWithoutAutomationInput | ActionUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: ActionUpdateManyWithWhereWithoutAutomationInput | ActionUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: ActionScalarWhereInput | ActionScalarWhereInput[]
  }

  export type AutomationInstanceUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<AutomationInstanceCreateWithoutAutomationInput, AutomationInstanceUncheckedCreateWithoutAutomationInput> | AutomationInstanceCreateWithoutAutomationInput[] | AutomationInstanceUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationInstanceCreateOrConnectWithoutAutomationInput | AutomationInstanceCreateOrConnectWithoutAutomationInput[]
    upsert?: AutomationInstanceUpsertWithWhereUniqueWithoutAutomationInput | AutomationInstanceUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: AutomationInstanceCreateManyAutomationInputEnvelope
    set?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    disconnect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    delete?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    connect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    update?: AutomationInstanceUpdateWithWhereUniqueWithoutAutomationInput | AutomationInstanceUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: AutomationInstanceUpdateManyWithWhereWithoutAutomationInput | AutomationInstanceUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: AutomationInstanceScalarWhereInput | AutomationInstanceScalarWhereInput[]
  }

  export type ActionUncheckedUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<ActionCreateWithoutAutomationInput, ActionUncheckedCreateWithoutAutomationInput> | ActionCreateWithoutAutomationInput[] | ActionUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutAutomationInput | ActionCreateOrConnectWithoutAutomationInput[]
    upsert?: ActionUpsertWithWhereUniqueWithoutAutomationInput | ActionUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: ActionCreateManyAutomationInputEnvelope
    set?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    disconnect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    delete?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    update?: ActionUpdateWithWhereUniqueWithoutAutomationInput | ActionUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: ActionUpdateManyWithWhereWithoutAutomationInput | ActionUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: ActionScalarWhereInput | ActionScalarWhereInput[]
  }

  export type AutomationInstanceUncheckedUpdateManyWithoutAutomationNestedInput = {
    create?: XOR<AutomationInstanceCreateWithoutAutomationInput, AutomationInstanceUncheckedCreateWithoutAutomationInput> | AutomationInstanceCreateWithoutAutomationInput[] | AutomationInstanceUncheckedCreateWithoutAutomationInput[]
    connectOrCreate?: AutomationInstanceCreateOrConnectWithoutAutomationInput | AutomationInstanceCreateOrConnectWithoutAutomationInput[]
    upsert?: AutomationInstanceUpsertWithWhereUniqueWithoutAutomationInput | AutomationInstanceUpsertWithWhereUniqueWithoutAutomationInput[]
    createMany?: AutomationInstanceCreateManyAutomationInputEnvelope
    set?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    disconnect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    delete?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    connect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    update?: AutomationInstanceUpdateWithWhereUniqueWithoutAutomationInput | AutomationInstanceUpdateWithWhereUniqueWithoutAutomationInput[]
    updateMany?: AutomationInstanceUpdateManyWithWhereWithoutAutomationInput | AutomationInstanceUpdateManyWithWhereWithoutAutomationInput[]
    deleteMany?: AutomationInstanceScalarWhereInput | AutomationInstanceScalarWhereInput[]
  }

  export type AutomationCreateNestedOneWithoutAutomationInstanceInput = {
    create?: XOR<AutomationCreateWithoutAutomationInstanceInput, AutomationUncheckedCreateWithoutAutomationInstanceInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutAutomationInstanceInput
    connect?: AutomationWhereUniqueInput
  }

  export type AutomationUpdateOneRequiredWithoutAutomationInstanceNestedInput = {
    create?: XOR<AutomationCreateWithoutAutomationInstanceInput, AutomationUncheckedCreateWithoutAutomationInstanceInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutAutomationInstanceInput
    upsert?: AutomationUpsertWithoutAutomationInstanceInput
    connect?: AutomationWhereUniqueInput
    update?: XOR<XOR<AutomationUpdateToOneWithWhereWithoutAutomationInstanceInput, AutomationUpdateWithoutAutomationInstanceInput>, AutomationUncheckedUpdateWithoutAutomationInstanceInput>
  }

  export type AutomationCreateNestedOneWithoutActionInput = {
    create?: XOR<AutomationCreateWithoutActionInput, AutomationUncheckedCreateWithoutActionInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutActionInput
    connect?: AutomationWhereUniqueInput
  }

  export type EnumActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActionType
  }

  export type AutomationUpdateOneRequiredWithoutActionNestedInput = {
    create?: XOR<AutomationCreateWithoutActionInput, AutomationUncheckedCreateWithoutActionInput>
    connectOrCreate?: AutomationCreateOrConnectWithoutActionInput
    upsert?: AutomationUpsertWithoutActionInput
    connect?: AutomationWhereUniqueInput
    update?: XOR<XOR<AutomationUpdateToOneWithWhereWithoutActionInput, AutomationUpdateWithoutActionInput>, AutomationUncheckedUpdateWithoutActionInput>
  }

  export type SubAccountCreateNestedOneWithoutContactInput = {
    create?: XOR<SubAccountCreateWithoutContactInput, SubAccountUncheckedCreateWithoutContactInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutContactInput
    connect?: SubAccountWhereUniqueInput
  }

  export type TicketsCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TicketsCreateWithoutCustomerInput, TicketsUncheckedCreateWithoutCustomerInput> | TicketsCreateWithoutCustomerInput[] | TicketsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutCustomerInput | TicketsCreateOrConnectWithoutCustomerInput[]
    createMany?: TicketsCreateManyCustomerInputEnvelope
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type TicketsUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TicketsCreateWithoutCustomerInput, TicketsUncheckedCreateWithoutCustomerInput> | TicketsCreateWithoutCustomerInput[] | TicketsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutCustomerInput | TicketsCreateOrConnectWithoutCustomerInput[]
    createMany?: TicketsCreateManyCustomerInputEnvelope
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type SubAccountUpdateOneRequiredWithoutContactNestedInput = {
    create?: XOR<SubAccountCreateWithoutContactInput, SubAccountUncheckedCreateWithoutContactInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutContactInput
    upsert?: SubAccountUpsertWithoutContactInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutContactInput, SubAccountUpdateWithoutContactInput>, SubAccountUncheckedUpdateWithoutContactInput>
  }

  export type TicketsUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TicketsCreateWithoutCustomerInput, TicketsUncheckedCreateWithoutCustomerInput> | TicketsCreateWithoutCustomerInput[] | TicketsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutCustomerInput | TicketsCreateOrConnectWithoutCustomerInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutCustomerInput | TicketsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TicketsCreateManyCustomerInputEnvelope
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutCustomerInput | TicketsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutCustomerInput | TicketsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type TicketsUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TicketsCreateWithoutCustomerInput, TicketsUncheckedCreateWithoutCustomerInput> | TicketsCreateWithoutCustomerInput[] | TicketsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutCustomerInput | TicketsCreateOrConnectWithoutCustomerInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutCustomerInput | TicketsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TicketsCreateManyCustomerInputEnvelope
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutCustomerInput | TicketsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutCustomerInput | TicketsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type SubAccountCreateNestedOneWithoutMediaInput = {
    create?: XOR<SubAccountCreateWithoutMediaInput, SubAccountUncheckedCreateWithoutMediaInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutMediaInput
    connect?: SubAccountWhereUniqueInput
  }

  export type SubAccountUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<SubAccountCreateWithoutMediaInput, SubAccountUncheckedCreateWithoutMediaInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutMediaInput
    upsert?: SubAccountUpsertWithoutMediaInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutMediaInput, SubAccountUpdateWithoutMediaInput>, SubAccountUncheckedUpdateWithoutMediaInput>
  }

  export type SubAccountCreateNestedOneWithoutFunnelsInput = {
    create?: XOR<SubAccountCreateWithoutFunnelsInput, SubAccountUncheckedCreateWithoutFunnelsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutFunnelsInput
    connect?: SubAccountWhereUniqueInput
  }

  export type FunnelPagesCreateNestedManyWithoutFunnelsInput = {
    create?: XOR<FunnelPagesCreateWithoutFunnelsInput, FunnelPagesUncheckedCreateWithoutFunnelsInput> | FunnelPagesCreateWithoutFunnelsInput[] | FunnelPagesUncheckedCreateWithoutFunnelsInput[]
    connectOrCreate?: FunnelPagesCreateOrConnectWithoutFunnelsInput | FunnelPagesCreateOrConnectWithoutFunnelsInput[]
    createMany?: FunnelPagesCreateManyFunnelsInputEnvelope
    connect?: FunnelPagesWhereUniqueInput | FunnelPagesWhereUniqueInput[]
  }

  export type ClassNameCreateNestedManyWithoutFunnelsInput = {
    create?: XOR<ClassNameCreateWithoutFunnelsInput, ClassNameUncheckedCreateWithoutFunnelsInput> | ClassNameCreateWithoutFunnelsInput[] | ClassNameUncheckedCreateWithoutFunnelsInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutFunnelsInput | ClassNameCreateOrConnectWithoutFunnelsInput[]
    createMany?: ClassNameCreateManyFunnelsInputEnvelope
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
  }

  export type FunnelPagesUncheckedCreateNestedManyWithoutFunnelsInput = {
    create?: XOR<FunnelPagesCreateWithoutFunnelsInput, FunnelPagesUncheckedCreateWithoutFunnelsInput> | FunnelPagesCreateWithoutFunnelsInput[] | FunnelPagesUncheckedCreateWithoutFunnelsInput[]
    connectOrCreate?: FunnelPagesCreateOrConnectWithoutFunnelsInput | FunnelPagesCreateOrConnectWithoutFunnelsInput[]
    createMany?: FunnelPagesCreateManyFunnelsInputEnvelope
    connect?: FunnelPagesWhereUniqueInput | FunnelPagesWhereUniqueInput[]
  }

  export type ClassNameUncheckedCreateNestedManyWithoutFunnelsInput = {
    create?: XOR<ClassNameCreateWithoutFunnelsInput, ClassNameUncheckedCreateWithoutFunnelsInput> | ClassNameCreateWithoutFunnelsInput[] | ClassNameUncheckedCreateWithoutFunnelsInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutFunnelsInput | ClassNameCreateOrConnectWithoutFunnelsInput[]
    createMany?: ClassNameCreateManyFunnelsInputEnvelope
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
  }

  export type SubAccountUpdateOneRequiredWithoutFunnelsNestedInput = {
    create?: XOR<SubAccountCreateWithoutFunnelsInput, SubAccountUncheckedCreateWithoutFunnelsInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutFunnelsInput
    upsert?: SubAccountUpsertWithoutFunnelsInput
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutFunnelsInput, SubAccountUpdateWithoutFunnelsInput>, SubAccountUncheckedUpdateWithoutFunnelsInput>
  }

  export type FunnelPagesUpdateManyWithoutFunnelsNestedInput = {
    create?: XOR<FunnelPagesCreateWithoutFunnelsInput, FunnelPagesUncheckedCreateWithoutFunnelsInput> | FunnelPagesCreateWithoutFunnelsInput[] | FunnelPagesUncheckedCreateWithoutFunnelsInput[]
    connectOrCreate?: FunnelPagesCreateOrConnectWithoutFunnelsInput | FunnelPagesCreateOrConnectWithoutFunnelsInput[]
    upsert?: FunnelPagesUpsertWithWhereUniqueWithoutFunnelsInput | FunnelPagesUpsertWithWhereUniqueWithoutFunnelsInput[]
    createMany?: FunnelPagesCreateManyFunnelsInputEnvelope
    set?: FunnelPagesWhereUniqueInput | FunnelPagesWhereUniqueInput[]
    disconnect?: FunnelPagesWhereUniqueInput | FunnelPagesWhereUniqueInput[]
    delete?: FunnelPagesWhereUniqueInput | FunnelPagesWhereUniqueInput[]
    connect?: FunnelPagesWhereUniqueInput | FunnelPagesWhereUniqueInput[]
    update?: FunnelPagesUpdateWithWhereUniqueWithoutFunnelsInput | FunnelPagesUpdateWithWhereUniqueWithoutFunnelsInput[]
    updateMany?: FunnelPagesUpdateManyWithWhereWithoutFunnelsInput | FunnelPagesUpdateManyWithWhereWithoutFunnelsInput[]
    deleteMany?: FunnelPagesScalarWhereInput | FunnelPagesScalarWhereInput[]
  }

  export type ClassNameUpdateManyWithoutFunnelsNestedInput = {
    create?: XOR<ClassNameCreateWithoutFunnelsInput, ClassNameUncheckedCreateWithoutFunnelsInput> | ClassNameCreateWithoutFunnelsInput[] | ClassNameUncheckedCreateWithoutFunnelsInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutFunnelsInput | ClassNameCreateOrConnectWithoutFunnelsInput[]
    upsert?: ClassNameUpsertWithWhereUniqueWithoutFunnelsInput | ClassNameUpsertWithWhereUniqueWithoutFunnelsInput[]
    createMany?: ClassNameCreateManyFunnelsInputEnvelope
    set?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    disconnect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    delete?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    update?: ClassNameUpdateWithWhereUniqueWithoutFunnelsInput | ClassNameUpdateWithWhereUniqueWithoutFunnelsInput[]
    updateMany?: ClassNameUpdateManyWithWhereWithoutFunnelsInput | ClassNameUpdateManyWithWhereWithoutFunnelsInput[]
    deleteMany?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
  }

  export type FunnelPagesUncheckedUpdateManyWithoutFunnelsNestedInput = {
    create?: XOR<FunnelPagesCreateWithoutFunnelsInput, FunnelPagesUncheckedCreateWithoutFunnelsInput> | FunnelPagesCreateWithoutFunnelsInput[] | FunnelPagesUncheckedCreateWithoutFunnelsInput[]
    connectOrCreate?: FunnelPagesCreateOrConnectWithoutFunnelsInput | FunnelPagesCreateOrConnectWithoutFunnelsInput[]
    upsert?: FunnelPagesUpsertWithWhereUniqueWithoutFunnelsInput | FunnelPagesUpsertWithWhereUniqueWithoutFunnelsInput[]
    createMany?: FunnelPagesCreateManyFunnelsInputEnvelope
    set?: FunnelPagesWhereUniqueInput | FunnelPagesWhereUniqueInput[]
    disconnect?: FunnelPagesWhereUniqueInput | FunnelPagesWhereUniqueInput[]
    delete?: FunnelPagesWhereUniqueInput | FunnelPagesWhereUniqueInput[]
    connect?: FunnelPagesWhereUniqueInput | FunnelPagesWhereUniqueInput[]
    update?: FunnelPagesUpdateWithWhereUniqueWithoutFunnelsInput | FunnelPagesUpdateWithWhereUniqueWithoutFunnelsInput[]
    updateMany?: FunnelPagesUpdateManyWithWhereWithoutFunnelsInput | FunnelPagesUpdateManyWithWhereWithoutFunnelsInput[]
    deleteMany?: FunnelPagesScalarWhereInput | FunnelPagesScalarWhereInput[]
  }

  export type ClassNameUncheckedUpdateManyWithoutFunnelsNestedInput = {
    create?: XOR<ClassNameCreateWithoutFunnelsInput, ClassNameUncheckedCreateWithoutFunnelsInput> | ClassNameCreateWithoutFunnelsInput[] | ClassNameUncheckedCreateWithoutFunnelsInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutFunnelsInput | ClassNameCreateOrConnectWithoutFunnelsInput[]
    upsert?: ClassNameUpsertWithWhereUniqueWithoutFunnelsInput | ClassNameUpsertWithWhereUniqueWithoutFunnelsInput[]
    createMany?: ClassNameCreateManyFunnelsInputEnvelope
    set?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    disconnect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    delete?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    update?: ClassNameUpdateWithWhereUniqueWithoutFunnelsInput | ClassNameUpdateWithWhereUniqueWithoutFunnelsInput[]
    updateMany?: ClassNameUpdateManyWithWhereWithoutFunnelsInput | ClassNameUpdateManyWithWhereWithoutFunnelsInput[]
    deleteMany?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
  }

  export type FunnelsCreateNestedOneWithoutFunnelPagesInput = {
    create?: XOR<FunnelsCreateWithoutFunnelPagesInput, FunnelsUncheckedCreateWithoutFunnelPagesInput>
    connectOrCreate?: FunnelsCreateOrConnectWithoutFunnelPagesInput
    connect?: FunnelsWhereUniqueInput
  }

  export type FunnelsUpdateOneRequiredWithoutFunnelPagesNestedInput = {
    create?: XOR<FunnelsCreateWithoutFunnelPagesInput, FunnelsUncheckedCreateWithoutFunnelPagesInput>
    connectOrCreate?: FunnelsCreateOrConnectWithoutFunnelPagesInput
    upsert?: FunnelsUpsertWithoutFunnelPagesInput
    connect?: FunnelsWhereUniqueInput
    update?: XOR<XOR<FunnelsUpdateToOneWithWhereWithoutFunnelPagesInput, FunnelsUpdateWithoutFunnelPagesInput>, FunnelsUncheckedUpdateWithoutFunnelPagesInput>
  }

  export type FunnelsCreateNestedOneWithoutClassNameInput = {
    create?: XOR<FunnelsCreateWithoutClassNameInput, FunnelsUncheckedCreateWithoutClassNameInput>
    connectOrCreate?: FunnelsCreateOrConnectWithoutClassNameInput
    connect?: FunnelsWhereUniqueInput
  }

  export type FunnelsUpdateOneRequiredWithoutClassNameNestedInput = {
    create?: XOR<FunnelsCreateWithoutClassNameInput, FunnelsUncheckedCreateWithoutClassNameInput>
    connectOrCreate?: FunnelsCreateOrConnectWithoutClassNameInput
    upsert?: FunnelsUpsertWithoutClassNameInput
    connect?: FunnelsWhereUniqueInput
    update?: XOR<XOR<FunnelsUpdateToOneWithWhereWithoutClassNameInput, FunnelsUpdateWithoutClassNameInput>, FunnelsUncheckedUpdateWithoutClassNameInput>
  }

  export type AgencyCreateNestedOneWithoutSidebarOptionInput = {
    create?: XOR<AgencyCreateWithoutSidebarOptionInput, AgencyUncheckedCreateWithoutSidebarOptionInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSidebarOptionInput
    connect?: AgencyWhereUniqueInput
  }

  export type EnumIconFieldUpdateOperationsInput = {
    set?: $Enums.Icon
  }

  export type AgencyUpdateOneWithoutSidebarOptionNestedInput = {
    create?: XOR<AgencyCreateWithoutSidebarOptionInput, AgencyUncheckedCreateWithoutSidebarOptionInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSidebarOptionInput
    upsert?: AgencyUpsertWithoutSidebarOptionInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutSidebarOptionInput, AgencyUpdateWithoutSidebarOptionInput>, AgencyUncheckedUpdateWithoutSidebarOptionInput>
  }

  export type SubAccountCreateNestedOneWithoutSidebarOptionInput = {
    create?: XOR<SubAccountCreateWithoutSidebarOptionInput, SubAccountUncheckedCreateWithoutSidebarOptionInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutSidebarOptionInput
    connect?: SubAccountWhereUniqueInput
  }

  export type SubAccountUpdateOneWithoutSidebarOptionNestedInput = {
    create?: XOR<SubAccountCreateWithoutSidebarOptionInput, SubAccountUncheckedCreateWithoutSidebarOptionInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutSidebarOptionInput
    upsert?: SubAccountUpsertWithoutSidebarOptionInput
    disconnect?: SubAccountWhereInput | boolean
    delete?: SubAccountWhereInput | boolean
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutSidebarOptionInput, SubAccountUpdateWithoutSidebarOptionInput>, SubAccountUncheckedUpdateWithoutSidebarOptionInput>
  }

  export type AgencyCreateNestedOneWithoutInvitationInput = {
    create?: XOR<AgencyCreateWithoutInvitationInput, AgencyUncheckedCreateWithoutInvitationInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutInvitationInput
    connect?: AgencyWhereUniqueInput
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type AgencyUpdateOneRequiredWithoutInvitationNestedInput = {
    create?: XOR<AgencyCreateWithoutInvitationInput, AgencyUncheckedCreateWithoutInvitationInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutInvitationInput
    upsert?: AgencyUpsertWithoutInvitationInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutInvitationInput, AgencyUpdateWithoutInvitationInput>, AgencyUncheckedUpdateWithoutInvitationInput>
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutNotificationInput = {
    create?: XOR<AgencyCreateWithoutNotificationInput, AgencyUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutNotificationInput
    connect?: AgencyWhereUniqueInput
  }

  export type SubAccountCreateNestedOneWithoutNotificationInput = {
    create?: XOR<SubAccountCreateWithoutNotificationInput, SubAccountUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutNotificationInput
    connect?: SubAccountWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type AgencyUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<AgencyCreateWithoutNotificationInput, AgencyUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutNotificationInput
    upsert?: AgencyUpsertWithoutNotificationInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutNotificationInput, AgencyUpdateWithoutNotificationInput>, AgencyUncheckedUpdateWithoutNotificationInput>
  }

  export type SubAccountUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<SubAccountCreateWithoutNotificationInput, SubAccountUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: SubAccountCreateOrConnectWithoutNotificationInput
    upsert?: SubAccountUpsertWithoutNotificationInput
    disconnect?: SubAccountWhereInput | boolean
    delete?: SubAccountWhereInput | boolean
    connect?: SubAccountWhereUniqueInput
    update?: XOR<XOR<SubAccountUpdateToOneWithWhereWithoutNotificationInput, SubAccountUpdateWithoutNotificationInput>, SubAccountUncheckedUpdateWithoutNotificationInput>
  }

  export type AgencyCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<AgencyCreateWithoutSubscriptionInput, AgencyUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSubscriptionInput
    connect?: AgencyWhereUniqueInput
  }

  export type NullableEnumPlanFieldUpdateOperationsInput = {
    set?: $Enums.Plan | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AgencyUpdateOneWithoutSubscriptionNestedInput = {
    create?: XOR<AgencyCreateWithoutSubscriptionInput, AgencyUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSubscriptionInput
    upsert?: AgencyUpsertWithoutSubscriptionInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutSubscriptionInput, AgencyUpdateWithoutSubscriptionInput>, AgencyUncheckedUpdateWithoutSubscriptionInput>
  }

  export type AgencyCreateNestedOneWithoutAddOnsInput = {
    create?: XOR<AgencyCreateWithoutAddOnsInput, AgencyUncheckedCreateWithoutAddOnsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAddOnsInput
    connect?: AgencyWhereUniqueInput
  }

  export type AgencyUpdateOneWithoutAddOnsNestedInput = {
    create?: XOR<AgencyCreateWithoutAddOnsInput, AgencyUncheckedCreateWithoutAddOnsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAddOnsInput
    upsert?: AgencyUpsertWithoutAddOnsInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAddOnsInput, AgencyUpdateWithoutAddOnsInput>, AgencyUncheckedUpdateWithoutAddOnsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumTriggerTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerTypes | EnumTriggerTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerTypes[]
    notIn?: $Enums.TriggerTypes[]
    not?: NestedEnumTriggerTypesFilter<$PrismaModel> | $Enums.TriggerTypes
  }

  export type NestedEnumTriggerTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerTypes | EnumTriggerTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerTypes[]
    notIn?: $Enums.TriggerTypes[]
    not?: NestedEnumTriggerTypesWithAggregatesFilter<$PrismaModel> | $Enums.TriggerTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTriggerTypesFilter<$PrismaModel>
    _max?: NestedEnumTriggerTypesFilter<$PrismaModel>
  }

  export type NestedEnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[]
    notIn?: $Enums.ActionType[]
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type NestedEnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[]
    notIn?: $Enums.ActionType[]
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type NestedEnumIconFilter<$PrismaModel = never> = {
    equals?: $Enums.Icon | EnumIconFieldRefInput<$PrismaModel>
    in?: $Enums.Icon[]
    notIn?: $Enums.Icon[]
    not?: NestedEnumIconFilter<$PrismaModel> | $Enums.Icon
  }

  export type NestedEnumIconWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Icon | EnumIconFieldRefInput<$PrismaModel>
    in?: $Enums.Icon[]
    notIn?: $Enums.Icon[]
    not?: NestedEnumIconWithAggregatesFilter<$PrismaModel> | $Enums.Icon
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIconFilter<$PrismaModel>
    _max?: NestedEnumIconFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[]
    notIn?: $Enums.InvitationStatus[]
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[]
    notIn?: $Enums.InvitationStatus[]
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedEnumPlanNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | null
    notIn?: $Enums.Plan[] | null
    not?: NestedEnumPlanNullableFilter<$PrismaModel> | $Enums.Plan | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPlanNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plan | EnumPlanFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plan[] | null
    notIn?: $Enums.Plan[] | null
    not?: NestedEnumPlanNullableWithAggregatesFilter<$PrismaModel> | $Enums.Plan | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlanNullableFilter<$PrismaModel>
    _max?: NestedEnumPlanNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AgencyCreateWithoutUsersInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccount?: SubAccountCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationCreateNestedManyWithoutAgencyInput
    Notification?: NotificationCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutUsersInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccount?: SubAccountUncheckedCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationUncheckedCreateNestedManyWithoutAgencyInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionUncheckedCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutUsersInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutUsersInput, AgencyUncheckedCreateWithoutUsersInput>
  }

  export type PermissionsCreateWithoutUserInput = {
    id?: string
    access: boolean
    subAccount: SubAccountCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionsUncheckedCreateWithoutUserInput = {
    id?: string
    subAccountId: string
    access: boolean
  }

  export type PermissionsCreateOrConnectWithoutUserInput = {
    where: PermissionsWhereUniqueInput
    create: XOR<PermissionsCreateWithoutUserInput, PermissionsUncheckedCreateWithoutUserInput>
  }

  export type PermissionsCreateManyUserInputEnvelope = {
    data: PermissionsCreateManyUserInput | PermissionsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketsCreateWithoutAssignedInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    Lane: LaneCreateNestedOneWithoutTicketsInput
    Tags?: TagsCreateNestedManyWithoutTicketsInput
    Customer?: ContactCreateNestedOneWithoutTicketsInput
  }

  export type TicketsUncheckedCreateWithoutAssignedInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    laneId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    customerId?: string | null
    Tags?: TagsUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketsCreateOrConnectWithoutAssignedInput = {
    where: TicketsWhereUniqueInput
    create: XOR<TicketsCreateWithoutAssignedInput, TicketsUncheckedCreateWithoutAssignedInput>
  }

  export type TicketsCreateManyAssignedInputEnvelope = {
    data: TicketsCreateManyAssignedInput | TicketsCreateManyAssignedInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    notification: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Agency: AgencyCreateNestedOneWithoutNotificationInput
    SubAccount?: SubAccountCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    notification: string
    agencyId: string
    subAccountId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AgencyUpsertWithoutUsersInput = {
    update: XOR<AgencyUpdateWithoutUsersInput, AgencyUncheckedUpdateWithoutUsersInput>
    create: XOR<AgencyCreateWithoutUsersInput, AgencyUncheckedCreateWithoutUsersInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutUsersInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutUsersInput, AgencyUncheckedUpdateWithoutUsersInput>
  }

  export type AgencyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccount?: SubAccountUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccount?: SubAccountUncheckedUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationUncheckedUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type PermissionsUpsertWithWhereUniqueWithoutUserInput = {
    where: PermissionsWhereUniqueInput
    update: XOR<PermissionsUpdateWithoutUserInput, PermissionsUncheckedUpdateWithoutUserInput>
    create: XOR<PermissionsCreateWithoutUserInput, PermissionsUncheckedCreateWithoutUserInput>
  }

  export type PermissionsUpdateWithWhereUniqueWithoutUserInput = {
    where: PermissionsWhereUniqueInput
    data: XOR<PermissionsUpdateWithoutUserInput, PermissionsUncheckedUpdateWithoutUserInput>
  }

  export type PermissionsUpdateManyWithWhereWithoutUserInput = {
    where: PermissionsScalarWhereInput
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyWithoutUserInput>
  }

  export type PermissionsScalarWhereInput = {
    AND?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
    OR?: PermissionsScalarWhereInput[]
    NOT?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
    id?: StringFilter<"Permissions"> | string
    email?: StringFilter<"Permissions"> | string
    subAccountId?: StringFilter<"Permissions"> | string
    access?: BoolFilter<"Permissions"> | boolean
  }

  export type TicketsUpsertWithWhereUniqueWithoutAssignedInput = {
    where: TicketsWhereUniqueInput
    update: XOR<TicketsUpdateWithoutAssignedInput, TicketsUncheckedUpdateWithoutAssignedInput>
    create: XOR<TicketsCreateWithoutAssignedInput, TicketsUncheckedCreateWithoutAssignedInput>
  }

  export type TicketsUpdateWithWhereUniqueWithoutAssignedInput = {
    where: TicketsWhereUniqueInput
    data: XOR<TicketsUpdateWithoutAssignedInput, TicketsUncheckedUpdateWithoutAssignedInput>
  }

  export type TicketsUpdateManyWithWhereWithoutAssignedInput = {
    where: TicketsScalarWhereInput
    data: XOR<TicketsUpdateManyMutationInput, TicketsUncheckedUpdateManyWithoutAssignedInput>
  }

  export type TicketsScalarWhereInput = {
    AND?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
    OR?: TicketsScalarWhereInput[]
    NOT?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
    id?: StringFilter<"Tickets"> | string
    name?: StringFilter<"Tickets"> | string
    createdAt?: DateTimeFilter<"Tickets"> | Date | string
    updatedAt?: DateTimeFilter<"Tickets"> | Date | string
    laneId?: StringFilter<"Tickets"> | string
    order?: IntFilter<"Tickets"> | number
    value?: DecimalNullableFilter<"Tickets"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"Tickets"> | string | null
    customerId?: StringNullableFilter<"Tickets"> | string | null
    assignedUserId?: StringNullableFilter<"Tickets"> | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    notification?: StringFilter<"Notification"> | string
    agencyId?: StringFilter<"Notification"> | string
    subAccountId?: StringNullableFilter<"Notification"> | string | null
    userId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type UserCreateWithoutAgencyInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    Permissions?: PermissionsCreateNestedManyWithoutUserInput
    Tickets?: TicketsCreateNestedManyWithoutAssignedInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgencyInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutUserInput
    Tickets?: TicketsUncheckedCreateNestedManyWithoutAssignedInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgencyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput>
  }

  export type UserCreateManyAgencyInputEnvelope = {
    data: UserCreateManyAgencyInput | UserCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountCreateWithoutAgencyInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    SidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountInput
    Contact?: ContactCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutAgencyInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    SidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    Contact?: ContactUncheckedCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerUncheckedCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationUncheckedCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutAgencyInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutAgencyInput, SubAccountUncheckedCreateWithoutAgencyInput>
  }

  export type SubAccountCreateManyAgencyInputEnvelope = {
    data: SubAccountCreateManyAgencyInput | SubAccountCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencySidebarOptionCreateWithoutAgencyInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencySidebarOptionUncheckedCreateWithoutAgencyInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencySidebarOptionCreateOrConnectWithoutAgencyInput = {
    where: AgencySidebarOptionWhereUniqueInput
    create: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput>
  }

  export type AgencySidebarOptionCreateManyAgencyInputEnvelope = {
    data: AgencySidebarOptionCreateManyAgencyInput | AgencySidebarOptionCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutAgencyInput = {
    id?: string
    email: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
  }

  export type InvitationUncheckedCreateWithoutAgencyInput = {
    id?: string
    email: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
  }

  export type InvitationCreateOrConnectWithoutAgencyInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutAgencyInput, InvitationUncheckedCreateWithoutAgencyInput>
  }

  export type InvitationCreateManyAgencyInputEnvelope = {
    data: InvitationCreateManyAgencyInput | InvitationCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutAgencyInput = {
    id?: string
    notification: string
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutNotificationInput
    SubAccount?: SubAccountCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutAgencyInput = {
    id?: string
    notification: string
    subAccountId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutAgencyInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput>
  }

  export type NotificationCreateManyAgencyInputEnvelope = {
    data: NotificationCreateManyAgencyInput | NotificationCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: $Enums.Plan | null
    price?: string | null
    active?: boolean
    priceId?: string | null
    customerId?: string | null
    currentPeriodEndDate?: Date | string | null
    subscriptionId: string
  }

  export type SubscriptionUncheckedCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: $Enums.Plan | null
    price?: string | null
    active?: boolean
    priceId?: string | null
    customerId?: string | null
    currentPeriodEndDate?: Date | string | null
    subscriptionId: string
  }

  export type SubscriptionCreateOrConnectWithoutAgencyInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutAgencyInput, SubscriptionUncheckedCreateWithoutAgencyInput>
  }

  export type AddOnsCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
  }

  export type AddOnsUncheckedCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
  }

  export type AddOnsCreateOrConnectWithoutAgencyInput = {
    where: AddOnsWhereUniqueInput
    create: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput>
  }

  export type AddOnsCreateManyAgencyInputEnvelope = {
    data: AddOnsCreateManyAgencyInput | AddOnsCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutAgencyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAgencyInput, UserUncheckedUpdateWithoutAgencyInput>
    create: XOR<UserCreateWithoutAgencyInput, UserUncheckedCreateWithoutAgencyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAgencyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAgencyInput, UserUncheckedUpdateWithoutAgencyInput>
  }

  export type UserUpdateManyWithWhereWithoutAgencyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAgencyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    avatarUrl?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    agencyId?: StringNullableFilter<"User"> | string | null
  }

  export type SubAccountUpsertWithWhereUniqueWithoutAgencyInput = {
    where: SubAccountWhereUniqueInput
    update: XOR<SubAccountUpdateWithoutAgencyInput, SubAccountUncheckedUpdateWithoutAgencyInput>
    create: XOR<SubAccountCreateWithoutAgencyInput, SubAccountUncheckedCreateWithoutAgencyInput>
  }

  export type SubAccountUpdateWithWhereUniqueWithoutAgencyInput = {
    where: SubAccountWhereUniqueInput
    data: XOR<SubAccountUpdateWithoutAgencyInput, SubAccountUncheckedUpdateWithoutAgencyInput>
  }

  export type SubAccountUpdateManyWithWhereWithoutAgencyInput = {
    where: SubAccountScalarWhereInput
    data: XOR<SubAccountUpdateManyMutationInput, SubAccountUncheckedUpdateManyWithoutAgencyInput>
  }

  export type SubAccountScalarWhereInput = {
    AND?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
    OR?: SubAccountScalarWhereInput[]
    NOT?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
    id?: StringFilter<"SubAccount"> | string
    connectAccountId?: StringNullableFilter<"SubAccount"> | string | null
    name?: StringFilter<"SubAccount"> | string
    subAccountLogo?: StringFilter<"SubAccount"> | string
    createdAt?: DateTimeFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccount"> | Date | string
    companyEmail?: StringFilter<"SubAccount"> | string
    companyPhone?: StringFilter<"SubAccount"> | string
    goal?: IntFilter<"SubAccount"> | number
    address?: StringFilter<"SubAccount"> | string
    city?: StringFilter<"SubAccount"> | string
    zipCode?: StringFilter<"SubAccount"> | string
    state?: StringFilter<"SubAccount"> | string
    country?: StringFilter<"SubAccount"> | string
    agencyId?: StringFilter<"SubAccount"> | string
  }

  export type AgencySidebarOptionUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencySidebarOptionWhereUniqueInput
    update: XOR<AgencySidebarOptionUpdateWithoutAgencyInput, AgencySidebarOptionUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput>
  }

  export type AgencySidebarOptionUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencySidebarOptionWhereUniqueInput
    data: XOR<AgencySidebarOptionUpdateWithoutAgencyInput, AgencySidebarOptionUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencySidebarOptionUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencySidebarOptionScalarWhereInput
    data: XOR<AgencySidebarOptionUpdateManyMutationInput, AgencySidebarOptionUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencySidebarOptionScalarWhereInput = {
    AND?: AgencySidebarOptionScalarWhereInput | AgencySidebarOptionScalarWhereInput[]
    OR?: AgencySidebarOptionScalarWhereInput[]
    NOT?: AgencySidebarOptionScalarWhereInput | AgencySidebarOptionScalarWhereInput[]
    id?: StringFilter<"AgencySidebarOption"> | string
    name?: StringFilter<"AgencySidebarOption"> | string
    link?: StringFilter<"AgencySidebarOption"> | string
    icon?: EnumIconFilter<"AgencySidebarOption"> | $Enums.Icon
    agencyId?: StringFilter<"AgencySidebarOption"> | string
    createdAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
  }

  export type InvitationUpsertWithWhereUniqueWithoutAgencyInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutAgencyInput, InvitationUncheckedUpdateWithoutAgencyInput>
    create: XOR<InvitationCreateWithoutAgencyInput, InvitationUncheckedCreateWithoutAgencyInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutAgencyInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutAgencyInput, InvitationUncheckedUpdateWithoutAgencyInput>
  }

  export type InvitationUpdateManyWithWhereWithoutAgencyInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutAgencyInput>
  }

  export type InvitationScalarWhereInput = {
    AND?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    OR?: InvitationScalarWhereInput[]
    NOT?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    id?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    agencyId?: StringFilter<"Invitation"> | string
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    role?: EnumRoleFilter<"Invitation"> | $Enums.Role
  }

  export type NotificationUpsertWithWhereUniqueWithoutAgencyInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutAgencyInput, NotificationUncheckedUpdateWithoutAgencyInput>
    create: XOR<NotificationCreateWithoutAgencyInput, NotificationUncheckedCreateWithoutAgencyInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutAgencyInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutAgencyInput, NotificationUncheckedUpdateWithoutAgencyInput>
  }

  export type NotificationUpdateManyWithWhereWithoutAgencyInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutAgencyInput>
  }

  export type SubscriptionUpsertWithoutAgencyInput = {
    update: XOR<SubscriptionUpdateWithoutAgencyInput, SubscriptionUncheckedUpdateWithoutAgencyInput>
    create: XOR<SubscriptionCreateWithoutAgencyInput, SubscriptionUncheckedCreateWithoutAgencyInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutAgencyInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutAgencyInput, SubscriptionUncheckedUpdateWithoutAgencyInput>
  }

  export type SubscriptionUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlanFieldUpdateOperationsInput | $Enums.Plan | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionId?: StringFieldUpdateOperationsInput | string
  }

  export type AddOnsUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AddOnsWhereUniqueInput
    update: XOR<AddOnsUpdateWithoutAgencyInput, AddOnsUncheckedUpdateWithoutAgencyInput>
    create: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput>
  }

  export type AddOnsUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AddOnsWhereUniqueInput
    data: XOR<AddOnsUpdateWithoutAgencyInput, AddOnsUncheckedUpdateWithoutAgencyInput>
  }

  export type AddOnsUpdateManyWithWhereWithoutAgencyInput = {
    where: AddOnsScalarWhereInput
    data: XOR<AddOnsUpdateManyMutationInput, AddOnsUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AddOnsScalarWhereInput = {
    AND?: AddOnsScalarWhereInput | AddOnsScalarWhereInput[]
    OR?: AddOnsScalarWhereInput[]
    NOT?: AddOnsScalarWhereInput | AddOnsScalarWhereInput[]
    id?: StringFilter<"AddOns"> | string
    createdAt?: DateTimeFilter<"AddOns"> | Date | string
    updatedAt?: DateTimeFilter<"AddOns"> | Date | string
    name?: StringFilter<"AddOns"> | string
    active?: BoolFilter<"AddOns"> | boolean
    priceId?: StringFilter<"AddOns"> | string
    agencyId?: StringNullableFilter<"AddOns"> | string | null
  }

  export type UserCreateWithoutPermissionsInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    Agency?: AgencyCreateNestedOneWithoutUsersInput
    Tickets?: TicketsCreateNestedManyWithoutAssignedInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    agencyId?: string | null
    Tickets?: TicketsUncheckedCreateNestedManyWithoutAssignedInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
  }

  export type SubAccountCreateWithoutPermissionsInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountInput
    Contact?: ContactCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutPermissionsInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    Contact?: ContactUncheckedCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerUncheckedCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationUncheckedCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutPermissionsInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutPermissionsInput, SubAccountUncheckedCreateWithoutPermissionsInput>
  }

  export type UserUpsertWithoutPermissionsInput = {
    update: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    Agency?: AgencyUpdateOneWithoutUsersNestedInput
    Tickets?: TicketsUpdateManyWithoutAssignedNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    Tickets?: TicketsUncheckedUpdateManyWithoutAssignedNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubAccountUpsertWithoutPermissionsInput = {
    update: XOR<SubAccountUpdateWithoutPermissionsInput, SubAccountUncheckedUpdateWithoutPermissionsInput>
    create: XOR<SubAccountCreateWithoutPermissionsInput, SubAccountUncheckedCreateWithoutPermissionsInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutPermissionsInput, SubAccountUncheckedUpdateWithoutPermissionsInput>
  }

  export type SubAccountUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUncheckedUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUncheckedUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type AgencyCreateWithoutSubAccountInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationCreateNestedManyWithoutAgencyInput
    Notification?: NotificationCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutSubAccountInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationUncheckedCreateNestedManyWithoutAgencyInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionUncheckedCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutSubAccountInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutSubAccountInput, AgencyUncheckedCreateWithoutSubAccountInput>
  }

  export type SubAccountSidebarOptionCreateWithoutSubAccountInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput = {
    where: SubAccountSidebarOptionWhereUniqueInput
    create: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput>
  }

  export type SubAccountSidebarOptionCreateManySubAccountInputEnvelope = {
    data: SubAccountSidebarOptionCreateManySubAccountInput | SubAccountSidebarOptionCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type PermissionsCreateWithoutSubAccountInput = {
    id?: string
    access: boolean
    User: UserCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionsUncheckedCreateWithoutSubAccountInput = {
    id?: string
    email: string
    access: boolean
  }

  export type PermissionsCreateOrConnectWithoutSubAccountInput = {
    where: PermissionsWhereUniqueInput
    create: XOR<PermissionsCreateWithoutSubAccountInput, PermissionsUncheckedCreateWithoutSubAccountInput>
  }

  export type PermissionsCreateManySubAccountInputEnvelope = {
    data: PermissionsCreateManySubAccountInput | PermissionsCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type FunnelsCreateWithoutSubAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
    FunnelPages?: FunnelPagesCreateNestedManyWithoutFunnelsInput
    ClassName?: ClassNameCreateNestedManyWithoutFunnelsInput
  }

  export type FunnelsUncheckedCreateWithoutSubAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
    FunnelPages?: FunnelPagesUncheckedCreateNestedManyWithoutFunnelsInput
    ClassName?: ClassNameUncheckedCreateNestedManyWithoutFunnelsInput
  }

  export type FunnelsCreateOrConnectWithoutSubAccountInput = {
    where: FunnelsWhereUniqueInput
    create: XOR<FunnelsCreateWithoutSubAccountInput, FunnelsUncheckedCreateWithoutSubAccountInput>
  }

  export type FunnelsCreateManySubAccountInputEnvelope = {
    data: FunnelsCreateManySubAccountInput | FunnelsCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutSubAccountInput = {
    id?: string
    type?: string | null
    name: string
    link: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUncheckedCreateWithoutSubAccountInput = {
    id?: string
    type?: string | null
    name: string
    link: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaCreateOrConnectWithoutSubAccountInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutSubAccountInput, MediaUncheckedCreateWithoutSubAccountInput>
  }

  export type MediaCreateManySubAccountInputEnvelope = {
    data: MediaCreateManySubAccountInput | MediaCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutSubAccountInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Tickets?: TicketsCreateNestedManyWithoutCustomerInput
  }

  export type ContactUncheckedCreateWithoutSubAccountInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Tickets?: TicketsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type ContactCreateOrConnectWithoutSubAccountInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutSubAccountInput, ContactUncheckedCreateWithoutSubAccountInput>
  }

  export type ContactCreateManySubAccountInputEnvelope = {
    data: ContactCreateManySubAccountInput | ContactCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type TriggerCreateWithoutSubAccountInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    Automation?: AutomationCreateNestedManyWithoutTriggerInput
  }

  export type TriggerUncheckedCreateWithoutSubAccountInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    Automation?: AutomationUncheckedCreateNestedManyWithoutTriggerInput
  }

  export type TriggerCreateOrConnectWithoutSubAccountInput = {
    where: TriggerWhereUniqueInput
    create: XOR<TriggerCreateWithoutSubAccountInput, TriggerUncheckedCreateWithoutSubAccountInput>
  }

  export type TriggerCreateManySubAccountInputEnvelope = {
    data: TriggerCreateManySubAccountInput | TriggerCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type AutomationCreateWithoutSubAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    Trigger?: TriggerCreateNestedOneWithoutAutomationInput
    Action?: ActionCreateNestedManyWithoutAutomationInput
    AutomationInstance?: AutomationInstanceCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateWithoutSubAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerId?: string | null
    published?: boolean
    Action?: ActionUncheckedCreateNestedManyWithoutAutomationInput
    AutomationInstance?: AutomationInstanceUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationCreateOrConnectWithoutSubAccountInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutSubAccountInput, AutomationUncheckedCreateWithoutSubAccountInput>
  }

  export type AutomationCreateManySubAccountInputEnvelope = {
    data: AutomationCreateManySubAccountInput | AutomationCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type PipelineCreateWithoutSubAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Lane?: LaneCreateNestedManyWithoutPipelineInput
  }

  export type PipelineUncheckedCreateWithoutSubAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Lane?: LaneUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type PipelineCreateOrConnectWithoutSubAccountInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutSubAccountInput, PipelineUncheckedCreateWithoutSubAccountInput>
  }

  export type PipelineCreateManySubAccountInputEnvelope = {
    data: PipelineCreateManySubAccountInput | PipelineCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type TagsCreateWithoutSubAccountInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Tickets?: TicketsCreateNestedOneWithoutTagsInput
  }

  export type TagsUncheckedCreateWithoutSubAccountInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketsId?: string | null
  }

  export type TagsCreateOrConnectWithoutSubAccountInput = {
    where: TagsWhereUniqueInput
    create: XOR<TagsCreateWithoutSubAccountInput, TagsUncheckedCreateWithoutSubAccountInput>
  }

  export type TagsCreateManySubAccountInputEnvelope = {
    data: TagsCreateManySubAccountInput | TagsCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutSubAccountInput = {
    id?: string
    notification: string
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutNotificationInput
    Agency: AgencyCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutSubAccountInput = {
    id?: string
    notification: string
    agencyId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutSubAccountInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutSubAccountInput, NotificationUncheckedCreateWithoutSubAccountInput>
  }

  export type NotificationCreateManySubAccountInputEnvelope = {
    data: NotificationCreateManySubAccountInput | NotificationCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type AgencyUpsertWithoutSubAccountInput = {
    update: XOR<AgencyUpdateWithoutSubAccountInput, AgencyUncheckedUpdateWithoutSubAccountInput>
    create: XOR<AgencyCreateWithoutSubAccountInput, AgencyUncheckedCreateWithoutSubAccountInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutSubAccountInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutSubAccountInput, AgencyUncheckedUpdateWithoutSubAccountInput>
  }

  export type AgencyUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationUncheckedUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type SubAccountSidebarOptionUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: SubAccountSidebarOptionWhereUniqueInput
    update: XOR<SubAccountSidebarOptionUpdateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedUpdateWithoutSubAccountInput>
    create: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput>
  }

  export type SubAccountSidebarOptionUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: SubAccountSidebarOptionWhereUniqueInput
    data: XOR<SubAccountSidebarOptionUpdateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedUpdateWithoutSubAccountInput>
  }

  export type SubAccountSidebarOptionUpdateManyWithWhereWithoutSubAccountInput = {
    where: SubAccountSidebarOptionScalarWhereInput
    data: XOR<SubAccountSidebarOptionUpdateManyMutationInput, SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type SubAccountSidebarOptionScalarWhereInput = {
    AND?: SubAccountSidebarOptionScalarWhereInput | SubAccountSidebarOptionScalarWhereInput[]
    OR?: SubAccountSidebarOptionScalarWhereInput[]
    NOT?: SubAccountSidebarOptionScalarWhereInput | SubAccountSidebarOptionScalarWhereInput[]
    id?: StringFilter<"SubAccountSidebarOption"> | string
    name?: StringFilter<"SubAccountSidebarOption"> | string
    link?: StringFilter<"SubAccountSidebarOption"> | string
    icon?: EnumIconFilter<"SubAccountSidebarOption"> | $Enums.Icon
    createdAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    subAccountId?: StringNullableFilter<"SubAccountSidebarOption"> | string | null
  }

  export type PermissionsUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: PermissionsWhereUniqueInput
    update: XOR<PermissionsUpdateWithoutSubAccountInput, PermissionsUncheckedUpdateWithoutSubAccountInput>
    create: XOR<PermissionsCreateWithoutSubAccountInput, PermissionsUncheckedCreateWithoutSubAccountInput>
  }

  export type PermissionsUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: PermissionsWhereUniqueInput
    data: XOR<PermissionsUpdateWithoutSubAccountInput, PermissionsUncheckedUpdateWithoutSubAccountInput>
  }

  export type PermissionsUpdateManyWithWhereWithoutSubAccountInput = {
    where: PermissionsScalarWhereInput
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type FunnelsUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: FunnelsWhereUniqueInput
    update: XOR<FunnelsUpdateWithoutSubAccountInput, FunnelsUncheckedUpdateWithoutSubAccountInput>
    create: XOR<FunnelsCreateWithoutSubAccountInput, FunnelsUncheckedCreateWithoutSubAccountInput>
  }

  export type FunnelsUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: FunnelsWhereUniqueInput
    data: XOR<FunnelsUpdateWithoutSubAccountInput, FunnelsUncheckedUpdateWithoutSubAccountInput>
  }

  export type FunnelsUpdateManyWithWhereWithoutSubAccountInput = {
    where: FunnelsScalarWhereInput
    data: XOR<FunnelsUpdateManyMutationInput, FunnelsUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type FunnelsScalarWhereInput = {
    AND?: FunnelsScalarWhereInput | FunnelsScalarWhereInput[]
    OR?: FunnelsScalarWhereInput[]
    NOT?: FunnelsScalarWhereInput | FunnelsScalarWhereInput[]
    id?: StringFilter<"Funnels"> | string
    name?: StringFilter<"Funnels"> | string
    createdAt?: DateTimeFilter<"Funnels"> | Date | string
    updatedAt?: DateTimeFilter<"Funnels"> | Date | string
    description?: StringNullableFilter<"Funnels"> | string | null
    published?: BoolFilter<"Funnels"> | boolean
    subDomainName?: StringNullableFilter<"Funnels"> | string | null
    favicon?: StringNullableFilter<"Funnels"> | string | null
    subAccountId?: StringFilter<"Funnels"> | string
    liveProducts?: StringNullableFilter<"Funnels"> | string | null
  }

  export type MediaUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutSubAccountInput, MediaUncheckedUpdateWithoutSubAccountInput>
    create: XOR<MediaCreateWithoutSubAccountInput, MediaUncheckedCreateWithoutSubAccountInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutSubAccountInput, MediaUncheckedUpdateWithoutSubAccountInput>
  }

  export type MediaUpdateManyWithWhereWithoutSubAccountInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: StringFilter<"Media"> | string
    type?: StringNullableFilter<"Media"> | string | null
    name?: StringFilter<"Media"> | string
    link?: StringFilter<"Media"> | string
    subAccountId?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutSubAccountInput, ContactUncheckedUpdateWithoutSubAccountInput>
    create: XOR<ContactCreateWithoutSubAccountInput, ContactUncheckedCreateWithoutSubAccountInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutSubAccountInput, ContactUncheckedUpdateWithoutSubAccountInput>
  }

  export type ContactUpdateManyWithWhereWithoutSubAccountInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    subAccountId?: StringFilter<"Contact"> | string
  }

  export type TriggerUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: TriggerWhereUniqueInput
    update: XOR<TriggerUpdateWithoutSubAccountInput, TriggerUncheckedUpdateWithoutSubAccountInput>
    create: XOR<TriggerCreateWithoutSubAccountInput, TriggerUncheckedCreateWithoutSubAccountInput>
  }

  export type TriggerUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: TriggerWhereUniqueInput
    data: XOR<TriggerUpdateWithoutSubAccountInput, TriggerUncheckedUpdateWithoutSubAccountInput>
  }

  export type TriggerUpdateManyWithWhereWithoutSubAccountInput = {
    where: TriggerScalarWhereInput
    data: XOR<TriggerUpdateManyMutationInput, TriggerUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type TriggerScalarWhereInput = {
    AND?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
    OR?: TriggerScalarWhereInput[]
    NOT?: TriggerScalarWhereInput | TriggerScalarWhereInput[]
    id?: StringFilter<"Trigger"> | string
    name?: StringFilter<"Trigger"> | string
    type?: EnumTriggerTypesFilter<"Trigger"> | $Enums.TriggerTypes
    createdAt?: DateTimeFilter<"Trigger"> | Date | string
    updatedAt?: DateTimeFilter<"Trigger"> | Date | string
    subAccountId?: StringFilter<"Trigger"> | string
  }

  export type AutomationUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: AutomationWhereUniqueInput
    update: XOR<AutomationUpdateWithoutSubAccountInput, AutomationUncheckedUpdateWithoutSubAccountInput>
    create: XOR<AutomationCreateWithoutSubAccountInput, AutomationUncheckedCreateWithoutSubAccountInput>
  }

  export type AutomationUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: AutomationWhereUniqueInput
    data: XOR<AutomationUpdateWithoutSubAccountInput, AutomationUncheckedUpdateWithoutSubAccountInput>
  }

  export type AutomationUpdateManyWithWhereWithoutSubAccountInput = {
    where: AutomationScalarWhereInput
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type AutomationScalarWhereInput = {
    AND?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
    OR?: AutomationScalarWhereInput[]
    NOT?: AutomationScalarWhereInput | AutomationScalarWhereInput[]
    id?: StringFilter<"Automation"> | string
    name?: StringFilter<"Automation"> | string
    createdAt?: DateTimeFilter<"Automation"> | Date | string
    updatedAt?: DateTimeFilter<"Automation"> | Date | string
    triggerId?: StringNullableFilter<"Automation"> | string | null
    published?: BoolFilter<"Automation"> | boolean
    subAccountId?: StringFilter<"Automation"> | string
  }

  export type PipelineUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: PipelineWhereUniqueInput
    update: XOR<PipelineUpdateWithoutSubAccountInput, PipelineUncheckedUpdateWithoutSubAccountInput>
    create: XOR<PipelineCreateWithoutSubAccountInput, PipelineUncheckedCreateWithoutSubAccountInput>
  }

  export type PipelineUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: PipelineWhereUniqueInput
    data: XOR<PipelineUpdateWithoutSubAccountInput, PipelineUncheckedUpdateWithoutSubAccountInput>
  }

  export type PipelineUpdateManyWithWhereWithoutSubAccountInput = {
    where: PipelineScalarWhereInput
    data: XOR<PipelineUpdateManyMutationInput, PipelineUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type PipelineScalarWhereInput = {
    AND?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
    OR?: PipelineScalarWhereInput[]
    NOT?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
    id?: StringFilter<"Pipeline"> | string
    name?: StringFilter<"Pipeline"> | string
    createdAt?: DateTimeFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeFilter<"Pipeline"> | Date | string
    subAccountId?: StringFilter<"Pipeline"> | string
  }

  export type TagsUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: TagsWhereUniqueInput
    update: XOR<TagsUpdateWithoutSubAccountInput, TagsUncheckedUpdateWithoutSubAccountInput>
    create: XOR<TagsCreateWithoutSubAccountInput, TagsUncheckedCreateWithoutSubAccountInput>
  }

  export type TagsUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: TagsWhereUniqueInput
    data: XOR<TagsUpdateWithoutSubAccountInput, TagsUncheckedUpdateWithoutSubAccountInput>
  }

  export type TagsUpdateManyWithWhereWithoutSubAccountInput = {
    where: TagsScalarWhereInput
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type TagsScalarWhereInput = {
    AND?: TagsScalarWhereInput | TagsScalarWhereInput[]
    OR?: TagsScalarWhereInput[]
    NOT?: TagsScalarWhereInput | TagsScalarWhereInput[]
    id?: StringFilter<"Tags"> | string
    name?: StringFilter<"Tags"> | string
    color?: StringFilter<"Tags"> | string
    createdAt?: DateTimeFilter<"Tags"> | Date | string
    updatedAt?: DateTimeFilter<"Tags"> | Date | string
    subAccountId?: StringFilter<"Tags"> | string
    ticketsId?: StringNullableFilter<"Tags"> | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutSubAccountInput, NotificationUncheckedUpdateWithoutSubAccountInput>
    create: XOR<NotificationCreateWithoutSubAccountInput, NotificationUncheckedCreateWithoutSubAccountInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutSubAccountInput, NotificationUncheckedUpdateWithoutSubAccountInput>
  }

  export type NotificationUpdateManyWithWhereWithoutSubAccountInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type SubAccountCreateWithoutTagsInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountInput
    Contact?: ContactCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutTagsInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    Contact?: ContactUncheckedCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerUncheckedCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationUncheckedCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutTagsInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutTagsInput, SubAccountUncheckedCreateWithoutTagsInput>
  }

  export type TicketsCreateWithoutTagsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    Lane: LaneCreateNestedOneWithoutTicketsInput
    Customer?: ContactCreateNestedOneWithoutTicketsInput
    Assigned?: UserCreateNestedOneWithoutTicketsInput
  }

  export type TicketsUncheckedCreateWithoutTagsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    laneId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    customerId?: string | null
    assignedUserId?: string | null
  }

  export type TicketsCreateOrConnectWithoutTagsInput = {
    where: TicketsWhereUniqueInput
    create: XOR<TicketsCreateWithoutTagsInput, TicketsUncheckedCreateWithoutTagsInput>
  }

  export type SubAccountUpsertWithoutTagsInput = {
    update: XOR<SubAccountUpdateWithoutTagsInput, SubAccountUncheckedUpdateWithoutTagsInput>
    create: XOR<SubAccountCreateWithoutTagsInput, SubAccountUncheckedCreateWithoutTagsInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutTagsInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutTagsInput, SubAccountUncheckedUpdateWithoutTagsInput>
  }

  export type SubAccountUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUncheckedUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUncheckedUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type TicketsUpsertWithoutTagsInput = {
    update: XOR<TicketsUpdateWithoutTagsInput, TicketsUncheckedUpdateWithoutTagsInput>
    create: XOR<TicketsCreateWithoutTagsInput, TicketsUncheckedCreateWithoutTagsInput>
    where?: TicketsWhereInput
  }

  export type TicketsUpdateToOneWithWhereWithoutTagsInput = {
    where?: TicketsWhereInput
    data: XOR<TicketsUpdateWithoutTagsInput, TicketsUncheckedUpdateWithoutTagsInput>
  }

  export type TicketsUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Lane?: LaneUpdateOneRequiredWithoutTicketsNestedInput
    Customer?: ContactUpdateOneWithoutTicketsNestedInput
    Assigned?: UserUpdateOneWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laneId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LaneCreateWithoutPipelineInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    Tickets?: TicketsCreateNestedManyWithoutLaneInput
  }

  export type LaneUncheckedCreateWithoutPipelineInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    Tickets?: TicketsUncheckedCreateNestedManyWithoutLaneInput
  }

  export type LaneCreateOrConnectWithoutPipelineInput = {
    where: LaneWhereUniqueInput
    create: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput>
  }

  export type LaneCreateManyPipelineInputEnvelope = {
    data: LaneCreateManyPipelineInput | LaneCreateManyPipelineInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountCreateWithoutPipelineInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountInput
    Contact?: ContactCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutPipelineInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    Contact?: ContactUncheckedCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerUncheckedCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutPipelineInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutPipelineInput, SubAccountUncheckedCreateWithoutPipelineInput>
  }

  export type LaneUpsertWithWhereUniqueWithoutPipelineInput = {
    where: LaneWhereUniqueInput
    update: XOR<LaneUpdateWithoutPipelineInput, LaneUncheckedUpdateWithoutPipelineInput>
    create: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput>
  }

  export type LaneUpdateWithWhereUniqueWithoutPipelineInput = {
    where: LaneWhereUniqueInput
    data: XOR<LaneUpdateWithoutPipelineInput, LaneUncheckedUpdateWithoutPipelineInput>
  }

  export type LaneUpdateManyWithWhereWithoutPipelineInput = {
    where: LaneScalarWhereInput
    data: XOR<LaneUpdateManyMutationInput, LaneUncheckedUpdateManyWithoutPipelineInput>
  }

  export type LaneScalarWhereInput = {
    AND?: LaneScalarWhereInput | LaneScalarWhereInput[]
    OR?: LaneScalarWhereInput[]
    NOT?: LaneScalarWhereInput | LaneScalarWhereInput[]
    id?: StringFilter<"Lane"> | string
    name?: StringFilter<"Lane"> | string
    createdAt?: DateTimeFilter<"Lane"> | Date | string
    updatedAt?: DateTimeFilter<"Lane"> | Date | string
    pipelineId?: StringFilter<"Lane"> | string
    order?: IntFilter<"Lane"> | number
  }

  export type SubAccountUpsertWithoutPipelineInput = {
    update: XOR<SubAccountUpdateWithoutPipelineInput, SubAccountUncheckedUpdateWithoutPipelineInput>
    create: XOR<SubAccountCreateWithoutPipelineInput, SubAccountUncheckedCreateWithoutPipelineInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutPipelineInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutPipelineInput, SubAccountUncheckedUpdateWithoutPipelineInput>
  }

  export type SubAccountUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUncheckedUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type PipelineCreateWithoutLaneInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccount: SubAccountCreateNestedOneWithoutPipelineInput
  }

  export type PipelineUncheckedCreateWithoutLaneInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type PipelineCreateOrConnectWithoutLaneInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutLaneInput, PipelineUncheckedCreateWithoutLaneInput>
  }

  export type TicketsCreateWithoutLaneInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    Tags?: TagsCreateNestedManyWithoutTicketsInput
    Customer?: ContactCreateNestedOneWithoutTicketsInput
    Assigned?: UserCreateNestedOneWithoutTicketsInput
  }

  export type TicketsUncheckedCreateWithoutLaneInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    customerId?: string | null
    assignedUserId?: string | null
    Tags?: TagsUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketsCreateOrConnectWithoutLaneInput = {
    where: TicketsWhereUniqueInput
    create: XOR<TicketsCreateWithoutLaneInput, TicketsUncheckedCreateWithoutLaneInput>
  }

  export type TicketsCreateManyLaneInputEnvelope = {
    data: TicketsCreateManyLaneInput | TicketsCreateManyLaneInput[]
    skipDuplicates?: boolean
  }

  export type PipelineUpsertWithoutLaneInput = {
    update: XOR<PipelineUpdateWithoutLaneInput, PipelineUncheckedUpdateWithoutLaneInput>
    create: XOR<PipelineCreateWithoutLaneInput, PipelineUncheckedCreateWithoutLaneInput>
    where?: PipelineWhereInput
  }

  export type PipelineUpdateToOneWithWhereWithoutLaneInput = {
    where?: PipelineWhereInput
    data: XOR<PipelineUpdateWithoutLaneInput, PipelineUncheckedUpdateWithoutLaneInput>
  }

  export type PipelineUpdateWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccount?: SubAccountUpdateOneRequiredWithoutPipelineNestedInput
  }

  export type PipelineUncheckedUpdateWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketsUpsertWithWhereUniqueWithoutLaneInput = {
    where: TicketsWhereUniqueInput
    update: XOR<TicketsUpdateWithoutLaneInput, TicketsUncheckedUpdateWithoutLaneInput>
    create: XOR<TicketsCreateWithoutLaneInput, TicketsUncheckedCreateWithoutLaneInput>
  }

  export type TicketsUpdateWithWhereUniqueWithoutLaneInput = {
    where: TicketsWhereUniqueInput
    data: XOR<TicketsUpdateWithoutLaneInput, TicketsUncheckedUpdateWithoutLaneInput>
  }

  export type TicketsUpdateManyWithWhereWithoutLaneInput = {
    where: TicketsScalarWhereInput
    data: XOR<TicketsUpdateManyMutationInput, TicketsUncheckedUpdateManyWithoutLaneInput>
  }

  export type LaneCreateWithoutTicketsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    Pipeline: PipelineCreateNestedOneWithoutLaneInput
  }

  export type LaneUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
    order?: number
  }

  export type LaneCreateOrConnectWithoutTicketsInput = {
    where: LaneWhereUniqueInput
    create: XOR<LaneCreateWithoutTicketsInput, LaneUncheckedCreateWithoutTicketsInput>
  }

  export type TagsCreateWithoutTicketsInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccount: SubAccountCreateNestedOneWithoutTagsInput
  }

  export type TagsUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type TagsCreateOrConnectWithoutTicketsInput = {
    where: TagsWhereUniqueInput
    create: XOR<TagsCreateWithoutTicketsInput, TagsUncheckedCreateWithoutTicketsInput>
  }

  export type TagsCreateManyTicketsInputEnvelope = {
    data: TagsCreateManyTicketsInput | TagsCreateManyTicketsInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutTicketsInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccount: SubAccountCreateNestedOneWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type ContactCreateOrConnectWithoutTicketsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
  }

  export type UserCreateWithoutTicketsInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    Agency?: AgencyCreateNestedOneWithoutUsersInput
    Permissions?: PermissionsCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    agencyId?: string | null
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
  }

  export type LaneUpsertWithoutTicketsInput = {
    update: XOR<LaneUpdateWithoutTicketsInput, LaneUncheckedUpdateWithoutTicketsInput>
    create: XOR<LaneCreateWithoutTicketsInput, LaneUncheckedCreateWithoutTicketsInput>
    where?: LaneWhereInput
  }

  export type LaneUpdateToOneWithWhereWithoutTicketsInput = {
    where?: LaneWhereInput
    data: XOR<LaneUpdateWithoutTicketsInput, LaneUncheckedUpdateWithoutTicketsInput>
  }

  export type LaneUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    Pipeline?: PipelineUpdateOneRequiredWithoutLaneNestedInput
  }

  export type LaneUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TagsUpsertWithWhereUniqueWithoutTicketsInput = {
    where: TagsWhereUniqueInput
    update: XOR<TagsUpdateWithoutTicketsInput, TagsUncheckedUpdateWithoutTicketsInput>
    create: XOR<TagsCreateWithoutTicketsInput, TagsUncheckedCreateWithoutTicketsInput>
  }

  export type TagsUpdateWithWhereUniqueWithoutTicketsInput = {
    where: TagsWhereUniqueInput
    data: XOR<TagsUpdateWithoutTicketsInput, TagsUncheckedUpdateWithoutTicketsInput>
  }

  export type TagsUpdateManyWithWhereWithoutTicketsInput = {
    where: TagsScalarWhereInput
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyWithoutTicketsInput>
  }

  export type ContactUpsertWithoutTicketsInput = {
    update: XOR<ContactUpdateWithoutTicketsInput, ContactUncheckedUpdateWithoutTicketsInput>
    create: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutTicketsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutTicketsInput, ContactUncheckedUpdateWithoutTicketsInput>
  }

  export type ContactUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccount?: SubAccountUpdateOneRequiredWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutTicketsInput = {
    update: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    Agency?: AgencyUpdateOneWithoutUsersNestedInput
    Permissions?: PermissionsUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    Permissions?: PermissionsUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubAccountCreateWithoutTriggerInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountInput
    Contact?: ContactCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutTriggerInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    Contact?: ContactUncheckedCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationUncheckedCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutTriggerInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutTriggerInput, SubAccountUncheckedCreateWithoutTriggerInput>
  }

  export type AutomationCreateWithoutTriggerInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    SubAccount: SubAccountCreateNestedOneWithoutAutomationInput
    Action?: ActionCreateNestedManyWithoutAutomationInput
    AutomationInstance?: AutomationInstanceCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateWithoutTriggerInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    subAccountId: string
    Action?: ActionUncheckedCreateNestedManyWithoutAutomationInput
    AutomationInstance?: AutomationInstanceUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationCreateOrConnectWithoutTriggerInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutTriggerInput, AutomationUncheckedCreateWithoutTriggerInput>
  }

  export type AutomationCreateManyTriggerInputEnvelope = {
    data: AutomationCreateManyTriggerInput | AutomationCreateManyTriggerInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountUpsertWithoutTriggerInput = {
    update: XOR<SubAccountUpdateWithoutTriggerInput, SubAccountUncheckedUpdateWithoutTriggerInput>
    create: XOR<SubAccountCreateWithoutTriggerInput, SubAccountUncheckedCreateWithoutTriggerInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutTriggerInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutTriggerInput, SubAccountUncheckedUpdateWithoutTriggerInput>
  }

  export type SubAccountUpdateWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUncheckedUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type AutomationUpsertWithWhereUniqueWithoutTriggerInput = {
    where: AutomationWhereUniqueInput
    update: XOR<AutomationUpdateWithoutTriggerInput, AutomationUncheckedUpdateWithoutTriggerInput>
    create: XOR<AutomationCreateWithoutTriggerInput, AutomationUncheckedCreateWithoutTriggerInput>
  }

  export type AutomationUpdateWithWhereUniqueWithoutTriggerInput = {
    where: AutomationWhereUniqueInput
    data: XOR<AutomationUpdateWithoutTriggerInput, AutomationUncheckedUpdateWithoutTriggerInput>
  }

  export type AutomationUpdateManyWithWhereWithoutTriggerInput = {
    where: AutomationScalarWhereInput
    data: XOR<AutomationUpdateManyMutationInput, AutomationUncheckedUpdateManyWithoutTriggerInput>
  }

  export type TriggerCreateWithoutAutomationInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccount: SubAccountCreateNestedOneWithoutTriggerInput
  }

  export type TriggerUncheckedCreateWithoutAutomationInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type TriggerCreateOrConnectWithoutAutomationInput = {
    where: TriggerWhereUniqueInput
    create: XOR<TriggerCreateWithoutAutomationInput, TriggerUncheckedCreateWithoutAutomationInput>
  }

  export type SubAccountCreateWithoutAutomationInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountInput
    Contact?: ContactCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutAutomationInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    Contact?: ContactUncheckedCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerUncheckedCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutAutomationInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutAutomationInput, SubAccountUncheckedCreateWithoutAutomationInput>
  }

  export type ActionCreateWithoutAutomationInput = {
    id?: string
    name: string
    type: $Enums.ActionType
    createdAt?: Date | string
    updatedAt?: Date | string
    order: number
    laneId?: string
  }

  export type ActionUncheckedCreateWithoutAutomationInput = {
    id?: string
    name: string
    type: $Enums.ActionType
    createdAt?: Date | string
    updatedAt?: Date | string
    order: number
    laneId?: string
  }

  export type ActionCreateOrConnectWithoutAutomationInput = {
    where: ActionWhereUniqueInput
    create: XOR<ActionCreateWithoutAutomationInput, ActionUncheckedCreateWithoutAutomationInput>
  }

  export type ActionCreateManyAutomationInputEnvelope = {
    data: ActionCreateManyAutomationInput | ActionCreateManyAutomationInput[]
    skipDuplicates?: boolean
  }

  export type AutomationInstanceCreateWithoutAutomationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
  }

  export type AutomationInstanceUncheckedCreateWithoutAutomationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
  }

  export type AutomationInstanceCreateOrConnectWithoutAutomationInput = {
    where: AutomationInstanceWhereUniqueInput
    create: XOR<AutomationInstanceCreateWithoutAutomationInput, AutomationInstanceUncheckedCreateWithoutAutomationInput>
  }

  export type AutomationInstanceCreateManyAutomationInputEnvelope = {
    data: AutomationInstanceCreateManyAutomationInput | AutomationInstanceCreateManyAutomationInput[]
    skipDuplicates?: boolean
  }

  export type TriggerUpsertWithoutAutomationInput = {
    update: XOR<TriggerUpdateWithoutAutomationInput, TriggerUncheckedUpdateWithoutAutomationInput>
    create: XOR<TriggerCreateWithoutAutomationInput, TriggerUncheckedCreateWithoutAutomationInput>
    where?: TriggerWhereInput
  }

  export type TriggerUpdateToOneWithWhereWithoutAutomationInput = {
    where?: TriggerWhereInput
    data: XOR<TriggerUpdateWithoutAutomationInput, TriggerUncheckedUpdateWithoutAutomationInput>
  }

  export type TriggerUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccount?: SubAccountUpdateOneRequiredWithoutTriggerNestedInput
  }

  export type TriggerUncheckedUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type SubAccountUpsertWithoutAutomationInput = {
    update: XOR<SubAccountUpdateWithoutAutomationInput, SubAccountUncheckedUpdateWithoutAutomationInput>
    create: XOR<SubAccountCreateWithoutAutomationInput, SubAccountUncheckedCreateWithoutAutomationInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutAutomationInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutAutomationInput, SubAccountUncheckedUpdateWithoutAutomationInput>
  }

  export type SubAccountUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUncheckedUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type ActionUpsertWithWhereUniqueWithoutAutomationInput = {
    where: ActionWhereUniqueInput
    update: XOR<ActionUpdateWithoutAutomationInput, ActionUncheckedUpdateWithoutAutomationInput>
    create: XOR<ActionCreateWithoutAutomationInput, ActionUncheckedCreateWithoutAutomationInput>
  }

  export type ActionUpdateWithWhereUniqueWithoutAutomationInput = {
    where: ActionWhereUniqueInput
    data: XOR<ActionUpdateWithoutAutomationInput, ActionUncheckedUpdateWithoutAutomationInput>
  }

  export type ActionUpdateManyWithWhereWithoutAutomationInput = {
    where: ActionScalarWhereInput
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyWithoutAutomationInput>
  }

  export type ActionScalarWhereInput = {
    AND?: ActionScalarWhereInput | ActionScalarWhereInput[]
    OR?: ActionScalarWhereInput[]
    NOT?: ActionScalarWhereInput | ActionScalarWhereInput[]
    id?: StringFilter<"Action"> | string
    name?: StringFilter<"Action"> | string
    type?: EnumActionTypeFilter<"Action"> | $Enums.ActionType
    createdAt?: DateTimeFilter<"Action"> | Date | string
    updatedAt?: DateTimeFilter<"Action"> | Date | string
    automationId?: StringFilter<"Action"> | string
    order?: IntFilter<"Action"> | number
    laneId?: StringFilter<"Action"> | string
  }

  export type AutomationInstanceUpsertWithWhereUniqueWithoutAutomationInput = {
    where: AutomationInstanceWhereUniqueInput
    update: XOR<AutomationInstanceUpdateWithoutAutomationInput, AutomationInstanceUncheckedUpdateWithoutAutomationInput>
    create: XOR<AutomationInstanceCreateWithoutAutomationInput, AutomationInstanceUncheckedCreateWithoutAutomationInput>
  }

  export type AutomationInstanceUpdateWithWhereUniqueWithoutAutomationInput = {
    where: AutomationInstanceWhereUniqueInput
    data: XOR<AutomationInstanceUpdateWithoutAutomationInput, AutomationInstanceUncheckedUpdateWithoutAutomationInput>
  }

  export type AutomationInstanceUpdateManyWithWhereWithoutAutomationInput = {
    where: AutomationInstanceScalarWhereInput
    data: XOR<AutomationInstanceUpdateManyMutationInput, AutomationInstanceUncheckedUpdateManyWithoutAutomationInput>
  }

  export type AutomationInstanceScalarWhereInput = {
    AND?: AutomationInstanceScalarWhereInput | AutomationInstanceScalarWhereInput[]
    OR?: AutomationInstanceScalarWhereInput[]
    NOT?: AutomationInstanceScalarWhereInput | AutomationInstanceScalarWhereInput[]
    id?: StringFilter<"AutomationInstance"> | string
    createdAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    automationId?: StringFilter<"AutomationInstance"> | string
    active?: BoolFilter<"AutomationInstance"> | boolean
  }

  export type AutomationCreateWithoutAutomationInstanceInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    Trigger?: TriggerCreateNestedOneWithoutAutomationInput
    SubAccount: SubAccountCreateNestedOneWithoutAutomationInput
    Action?: ActionCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateWithoutAutomationInstanceInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerId?: string | null
    published?: boolean
    subAccountId: string
    Action?: ActionUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationCreateOrConnectWithoutAutomationInstanceInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutAutomationInstanceInput, AutomationUncheckedCreateWithoutAutomationInstanceInput>
  }

  export type AutomationUpsertWithoutAutomationInstanceInput = {
    update: XOR<AutomationUpdateWithoutAutomationInstanceInput, AutomationUncheckedUpdateWithoutAutomationInstanceInput>
    create: XOR<AutomationCreateWithoutAutomationInstanceInput, AutomationUncheckedCreateWithoutAutomationInstanceInput>
    where?: AutomationWhereInput
  }

  export type AutomationUpdateToOneWithWhereWithoutAutomationInstanceInput = {
    where?: AutomationWhereInput
    data: XOR<AutomationUpdateWithoutAutomationInstanceInput, AutomationUncheckedUpdateWithoutAutomationInstanceInput>
  }

  export type AutomationUpdateWithoutAutomationInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    Trigger?: TriggerUpdateOneWithoutAutomationNestedInput
    SubAccount?: SubAccountUpdateOneRequiredWithoutAutomationNestedInput
    Action?: ActionUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateWithoutAutomationInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
    Action?: ActionUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationCreateWithoutActionInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    Trigger?: TriggerCreateNestedOneWithoutAutomationInput
    SubAccount: SubAccountCreateNestedOneWithoutAutomationInput
    AutomationInstance?: AutomationInstanceCreateNestedManyWithoutAutomationInput
  }

  export type AutomationUncheckedCreateWithoutActionInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerId?: string | null
    published?: boolean
    subAccountId: string
    AutomationInstance?: AutomationInstanceUncheckedCreateNestedManyWithoutAutomationInput
  }

  export type AutomationCreateOrConnectWithoutActionInput = {
    where: AutomationWhereUniqueInput
    create: XOR<AutomationCreateWithoutActionInput, AutomationUncheckedCreateWithoutActionInput>
  }

  export type AutomationUpsertWithoutActionInput = {
    update: XOR<AutomationUpdateWithoutActionInput, AutomationUncheckedUpdateWithoutActionInput>
    create: XOR<AutomationCreateWithoutActionInput, AutomationUncheckedCreateWithoutActionInput>
    where?: AutomationWhereInput
  }

  export type AutomationUpdateToOneWithWhereWithoutActionInput = {
    where?: AutomationWhereInput
    data: XOR<AutomationUpdateWithoutActionInput, AutomationUncheckedUpdateWithoutActionInput>
  }

  export type AutomationUpdateWithoutActionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    Trigger?: TriggerUpdateOneWithoutAutomationNestedInput
    SubAccount?: SubAccountUpdateOneRequiredWithoutAutomationNestedInput
    AutomationInstance?: AutomationInstanceUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateWithoutActionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
    AutomationInstance?: AutomationInstanceUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type SubAccountCreateWithoutContactInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutContactInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerUncheckedCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationUncheckedCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutContactInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutContactInput, SubAccountUncheckedCreateWithoutContactInput>
  }

  export type TicketsCreateWithoutCustomerInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    Lane: LaneCreateNestedOneWithoutTicketsInput
    Tags?: TagsCreateNestedManyWithoutTicketsInput
    Assigned?: UserCreateNestedOneWithoutTicketsInput
  }

  export type TicketsUncheckedCreateWithoutCustomerInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    laneId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    assignedUserId?: string | null
    Tags?: TagsUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketsCreateOrConnectWithoutCustomerInput = {
    where: TicketsWhereUniqueInput
    create: XOR<TicketsCreateWithoutCustomerInput, TicketsUncheckedCreateWithoutCustomerInput>
  }

  export type TicketsCreateManyCustomerInputEnvelope = {
    data: TicketsCreateManyCustomerInput | TicketsCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountUpsertWithoutContactInput = {
    update: XOR<SubAccountUpdateWithoutContactInput, SubAccountUncheckedUpdateWithoutContactInput>
    create: XOR<SubAccountCreateWithoutContactInput, SubAccountUncheckedCreateWithoutContactInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutContactInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutContactInput, SubAccountUncheckedUpdateWithoutContactInput>
  }

  export type SubAccountUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUncheckedUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUncheckedUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type TicketsUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TicketsWhereUniqueInput
    update: XOR<TicketsUpdateWithoutCustomerInput, TicketsUncheckedUpdateWithoutCustomerInput>
    create: XOR<TicketsCreateWithoutCustomerInput, TicketsUncheckedCreateWithoutCustomerInput>
  }

  export type TicketsUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TicketsWhereUniqueInput
    data: XOR<TicketsUpdateWithoutCustomerInput, TicketsUncheckedUpdateWithoutCustomerInput>
  }

  export type TicketsUpdateManyWithWhereWithoutCustomerInput = {
    where: TicketsScalarWhereInput
    data: XOR<TicketsUpdateManyMutationInput, TicketsUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SubAccountCreateWithoutMediaInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Contact?: ContactCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutMediaInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Contact?: ContactUncheckedCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerUncheckedCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationUncheckedCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutMediaInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutMediaInput, SubAccountUncheckedCreateWithoutMediaInput>
  }

  export type SubAccountUpsertWithoutMediaInput = {
    update: XOR<SubAccountUpdateWithoutMediaInput, SubAccountUncheckedUpdateWithoutMediaInput>
    create: XOR<SubAccountCreateWithoutMediaInput, SubAccountUncheckedCreateWithoutMediaInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutMediaInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutMediaInput, SubAccountUncheckedUpdateWithoutMediaInput>
  }

  export type SubAccountUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUncheckedUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUncheckedUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountCreateWithoutFunnelsInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountInput
    Contact?: ContactCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutFunnelsInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    Contact?: ContactUncheckedCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerUncheckedCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationUncheckedCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutFunnelsInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutFunnelsInput, SubAccountUncheckedCreateWithoutFunnelsInput>
  }

  export type FunnelPagesCreateWithoutFunnelsInput = {
    id?: string
    name: string
    pathName?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: number
    content?: string | null
    order: number
    previewImage?: string | null
  }

  export type FunnelPagesUncheckedCreateWithoutFunnelsInput = {
    id?: string
    name: string
    pathName?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: number
    content?: string | null
    order: number
    previewImage?: string | null
  }

  export type FunnelPagesCreateOrConnectWithoutFunnelsInput = {
    where: FunnelPagesWhereUniqueInput
    create: XOR<FunnelPagesCreateWithoutFunnelsInput, FunnelPagesUncheckedCreateWithoutFunnelsInput>
  }

  export type FunnelPagesCreateManyFunnelsInputEnvelope = {
    data: FunnelPagesCreateManyFunnelsInput | FunnelPagesCreateManyFunnelsInput[]
    skipDuplicates?: boolean
  }

  export type ClassNameCreateWithoutFunnelsInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customDate?: string | null
  }

  export type ClassNameUncheckedCreateWithoutFunnelsInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customDate?: string | null
  }

  export type ClassNameCreateOrConnectWithoutFunnelsInput = {
    where: ClassNameWhereUniqueInput
    create: XOR<ClassNameCreateWithoutFunnelsInput, ClassNameUncheckedCreateWithoutFunnelsInput>
  }

  export type ClassNameCreateManyFunnelsInputEnvelope = {
    data: ClassNameCreateManyFunnelsInput | ClassNameCreateManyFunnelsInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountUpsertWithoutFunnelsInput = {
    update: XOR<SubAccountUpdateWithoutFunnelsInput, SubAccountUncheckedUpdateWithoutFunnelsInput>
    create: XOR<SubAccountCreateWithoutFunnelsInput, SubAccountUncheckedCreateWithoutFunnelsInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutFunnelsInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutFunnelsInput, SubAccountUncheckedUpdateWithoutFunnelsInput>
  }

  export type SubAccountUpdateWithoutFunnelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutFunnelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUncheckedUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUncheckedUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type FunnelPagesUpsertWithWhereUniqueWithoutFunnelsInput = {
    where: FunnelPagesWhereUniqueInput
    update: XOR<FunnelPagesUpdateWithoutFunnelsInput, FunnelPagesUncheckedUpdateWithoutFunnelsInput>
    create: XOR<FunnelPagesCreateWithoutFunnelsInput, FunnelPagesUncheckedCreateWithoutFunnelsInput>
  }

  export type FunnelPagesUpdateWithWhereUniqueWithoutFunnelsInput = {
    where: FunnelPagesWhereUniqueInput
    data: XOR<FunnelPagesUpdateWithoutFunnelsInput, FunnelPagesUncheckedUpdateWithoutFunnelsInput>
  }

  export type FunnelPagesUpdateManyWithWhereWithoutFunnelsInput = {
    where: FunnelPagesScalarWhereInput
    data: XOR<FunnelPagesUpdateManyMutationInput, FunnelPagesUncheckedUpdateManyWithoutFunnelsInput>
  }

  export type FunnelPagesScalarWhereInput = {
    AND?: FunnelPagesScalarWhereInput | FunnelPagesScalarWhereInput[]
    OR?: FunnelPagesScalarWhereInput[]
    NOT?: FunnelPagesScalarWhereInput | FunnelPagesScalarWhereInput[]
    id?: StringFilter<"FunnelPages"> | string
    name?: StringFilter<"FunnelPages"> | string
    pathName?: StringFilter<"FunnelPages"> | string
    createdAt?: DateTimeFilter<"FunnelPages"> | Date | string
    updatedAt?: DateTimeFilter<"FunnelPages"> | Date | string
    visits?: IntFilter<"FunnelPages"> | number
    content?: StringNullableFilter<"FunnelPages"> | string | null
    order?: IntFilter<"FunnelPages"> | number
    previewImage?: StringNullableFilter<"FunnelPages"> | string | null
    funnelId?: StringFilter<"FunnelPages"> | string
  }

  export type ClassNameUpsertWithWhereUniqueWithoutFunnelsInput = {
    where: ClassNameWhereUniqueInput
    update: XOR<ClassNameUpdateWithoutFunnelsInput, ClassNameUncheckedUpdateWithoutFunnelsInput>
    create: XOR<ClassNameCreateWithoutFunnelsInput, ClassNameUncheckedCreateWithoutFunnelsInput>
  }

  export type ClassNameUpdateWithWhereUniqueWithoutFunnelsInput = {
    where: ClassNameWhereUniqueInput
    data: XOR<ClassNameUpdateWithoutFunnelsInput, ClassNameUncheckedUpdateWithoutFunnelsInput>
  }

  export type ClassNameUpdateManyWithWhereWithoutFunnelsInput = {
    where: ClassNameScalarWhereInput
    data: XOR<ClassNameUpdateManyMutationInput, ClassNameUncheckedUpdateManyWithoutFunnelsInput>
  }

  export type ClassNameScalarWhereInput = {
    AND?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
    OR?: ClassNameScalarWhereInput[]
    NOT?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
    id?: StringFilter<"ClassName"> | string
    name?: StringFilter<"ClassName"> | string
    color?: StringFilter<"ClassName"> | string
    createdAt?: DateTimeFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeFilter<"ClassName"> | Date | string
    funnelId?: StringFilter<"ClassName"> | string
    customDate?: StringNullableFilter<"ClassName"> | string | null
  }

  export type FunnelsCreateWithoutFunnelPagesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
    SubAccount: SubAccountCreateNestedOneWithoutFunnelsInput
    ClassName?: ClassNameCreateNestedManyWithoutFunnelsInput
  }

  export type FunnelsUncheckedCreateWithoutFunnelPagesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    subAccountId: string
    liveProducts?: string | null
    ClassName?: ClassNameUncheckedCreateNestedManyWithoutFunnelsInput
  }

  export type FunnelsCreateOrConnectWithoutFunnelPagesInput = {
    where: FunnelsWhereUniqueInput
    create: XOR<FunnelsCreateWithoutFunnelPagesInput, FunnelsUncheckedCreateWithoutFunnelPagesInput>
  }

  export type FunnelsUpsertWithoutFunnelPagesInput = {
    update: XOR<FunnelsUpdateWithoutFunnelPagesInput, FunnelsUncheckedUpdateWithoutFunnelPagesInput>
    create: XOR<FunnelsCreateWithoutFunnelPagesInput, FunnelsUncheckedCreateWithoutFunnelPagesInput>
    where?: FunnelsWhereInput
  }

  export type FunnelsUpdateToOneWithWhereWithoutFunnelPagesInput = {
    where?: FunnelsWhereInput
    data: XOR<FunnelsUpdateWithoutFunnelPagesInput, FunnelsUncheckedUpdateWithoutFunnelPagesInput>
  }

  export type FunnelsUpdateWithoutFunnelPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    SubAccount?: SubAccountUpdateOneRequiredWithoutFunnelsNestedInput
    ClassName?: ClassNameUpdateManyWithoutFunnelsNestedInput
  }

  export type FunnelsUncheckedUpdateWithoutFunnelPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    subAccountId?: StringFieldUpdateOperationsInput | string
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    ClassName?: ClassNameUncheckedUpdateManyWithoutFunnelsNestedInput
  }

  export type FunnelsCreateWithoutClassNameInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
    SubAccount: SubAccountCreateNestedOneWithoutFunnelsInput
    FunnelPages?: FunnelPagesCreateNestedManyWithoutFunnelsInput
  }

  export type FunnelsUncheckedCreateWithoutClassNameInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    subAccountId: string
    liveProducts?: string | null
    FunnelPages?: FunnelPagesUncheckedCreateNestedManyWithoutFunnelsInput
  }

  export type FunnelsCreateOrConnectWithoutClassNameInput = {
    where: FunnelsWhereUniqueInput
    create: XOR<FunnelsCreateWithoutClassNameInput, FunnelsUncheckedCreateWithoutClassNameInput>
  }

  export type FunnelsUpsertWithoutClassNameInput = {
    update: XOR<FunnelsUpdateWithoutClassNameInput, FunnelsUncheckedUpdateWithoutClassNameInput>
    create: XOR<FunnelsCreateWithoutClassNameInput, FunnelsUncheckedCreateWithoutClassNameInput>
    where?: FunnelsWhereInput
  }

  export type FunnelsUpdateToOneWithWhereWithoutClassNameInput = {
    where?: FunnelsWhereInput
    data: XOR<FunnelsUpdateWithoutClassNameInput, FunnelsUncheckedUpdateWithoutClassNameInput>
  }

  export type FunnelsUpdateWithoutClassNameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    SubAccount?: SubAccountUpdateOneRequiredWithoutFunnelsNestedInput
    FunnelPages?: FunnelPagesUpdateManyWithoutFunnelsNestedInput
  }

  export type FunnelsUncheckedUpdateWithoutClassNameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    subAccountId?: StringFieldUpdateOperationsInput | string
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    FunnelPages?: FunnelPagesUncheckedUpdateManyWithoutFunnelsNestedInput
  }

  export type AgencyCreateWithoutSidebarOptionInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationCreateNestedManyWithoutAgencyInput
    Notification?: NotificationCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutSidebarOptionInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountUncheckedCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationUncheckedCreateNestedManyWithoutAgencyInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionUncheckedCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutSidebarOptionInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutSidebarOptionInput, AgencyUncheckedCreateWithoutSidebarOptionInput>
  }

  export type AgencyUpsertWithoutSidebarOptionInput = {
    update: XOR<AgencyUpdateWithoutSidebarOptionInput, AgencyUncheckedUpdateWithoutSidebarOptionInput>
    create: XOR<AgencyCreateWithoutSidebarOptionInput, AgencyUncheckedCreateWithoutSidebarOptionInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutSidebarOptionInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutSidebarOptionInput, AgencyUncheckedUpdateWithoutSidebarOptionInput>
  }

  export type AgencyUpdateWithoutSidebarOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutSidebarOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountUncheckedUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationUncheckedUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type SubAccountCreateWithoutSidebarOptionInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountInput
    Contact?: ContactCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutSidebarOptionInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    Contact?: ContactUncheckedCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerUncheckedCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationUncheckedCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutSidebarOptionInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutSidebarOptionInput, SubAccountUncheckedCreateWithoutSidebarOptionInput>
  }

  export type SubAccountUpsertWithoutSidebarOptionInput = {
    update: XOR<SubAccountUpdateWithoutSidebarOptionInput, SubAccountUncheckedUpdateWithoutSidebarOptionInput>
    create: XOR<SubAccountCreateWithoutSidebarOptionInput, SubAccountUncheckedCreateWithoutSidebarOptionInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutSidebarOptionInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutSidebarOptionInput, SubAccountUncheckedUpdateWithoutSidebarOptionInput>
  }

  export type SubAccountUpdateWithoutSidebarOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutSidebarOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUncheckedUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUncheckedUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type AgencyCreateWithoutInvitationInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    Notification?: NotificationCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutInvitationInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountUncheckedCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionUncheckedCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutInvitationInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutInvitationInput, AgencyUncheckedCreateWithoutInvitationInput>
  }

  export type AgencyUpsertWithoutInvitationInput = {
    update: XOR<AgencyUpdateWithoutInvitationInput, AgencyUncheckedUpdateWithoutInvitationInput>
    create: XOR<AgencyCreateWithoutInvitationInput, AgencyUncheckedCreateWithoutInvitationInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutInvitationInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutInvitationInput, AgencyUncheckedUpdateWithoutInvitationInput>
  }

  export type AgencyUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountUncheckedUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type UserCreateWithoutNotificationInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    Agency?: AgencyCreateNestedOneWithoutUsersInput
    Permissions?: PermissionsCreateNestedManyWithoutUserInput
    Tickets?: TicketsCreateNestedManyWithoutAssignedInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    agencyId?: string | null
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutUserInput
    Tickets?: TicketsUncheckedCreateNestedManyWithoutAssignedInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type AgencyCreateWithoutNotificationInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutNotificationInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountUncheckedCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationUncheckedCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionUncheckedCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutNotificationInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutNotificationInput, AgencyUncheckedCreateWithoutNotificationInput>
  }

  export type SubAccountCreateWithoutNotificationInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountInput
    Contact?: ContactCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountUncheckedCreateWithoutNotificationInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAccountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountInput
    Contact?: ContactUncheckedCreateNestedManyWithoutSubAccountInput
    Trigger?: TriggerUncheckedCreateNestedManyWithoutSubAccountInput
    Automation?: AutomationUncheckedCreateNestedManyWithoutSubAccountInput
    Pipeline?: PipelineUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountCreateOrConnectWithoutNotificationInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutNotificationInput, SubAccountUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    Agency?: AgencyUpdateOneWithoutUsersNestedInput
    Permissions?: PermissionsUpdateManyWithoutUserNestedInput
    Tickets?: TicketsUpdateManyWithoutAssignedNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    Permissions?: PermissionsUncheckedUpdateManyWithoutUserNestedInput
    Tickets?: TicketsUncheckedUpdateManyWithoutAssignedNestedInput
  }

  export type AgencyUpsertWithoutNotificationInput = {
    update: XOR<AgencyUpdateWithoutNotificationInput, AgencyUncheckedUpdateWithoutNotificationInput>
    create: XOR<AgencyCreateWithoutNotificationInput, AgencyUncheckedCreateWithoutNotificationInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutNotificationInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutNotificationInput, AgencyUncheckedUpdateWithoutNotificationInput>
  }

  export type AgencyUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountUncheckedUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationUncheckedUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type SubAccountUpsertWithoutNotificationInput = {
    update: XOR<SubAccountUpdateWithoutNotificationInput, SubAccountUncheckedUpdateWithoutNotificationInput>
    create: XOR<SubAccountCreateWithoutNotificationInput, SubAccountUncheckedCreateWithoutNotificationInput>
    where?: SubAccountWhereInput
  }

  export type SubAccountUpdateToOneWithWhereWithoutNotificationInput = {
    where?: SubAccountWhereInput
    data: XOR<SubAccountUpdateWithoutNotificationInput, SubAccountUncheckedUpdateWithoutNotificationInput>
  }

  export type SubAccountUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUncheckedUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUncheckedUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type AgencyCreateWithoutSubscriptionInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationCreateNestedManyWithoutAgencyInput
    Notification?: NotificationCreateNestedManyWithoutAgencyInput
    AddOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountUncheckedCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationUncheckedCreateNestedManyWithoutAgencyInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    AddOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutSubscriptionInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutSubscriptionInput, AgencyUncheckedCreateWithoutSubscriptionInput>
  }

  export type AgencyUpsertWithoutSubscriptionInput = {
    update: XOR<AgencyUpdateWithoutSubscriptionInput, AgencyUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<AgencyCreateWithoutSubscriptionInput, AgencyUncheckedCreateWithoutSubscriptionInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutSubscriptionInput, AgencyUncheckedUpdateWithoutSubscriptionInput>
  }

  export type AgencyUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationUpdateManyWithoutAgencyNestedInput
    AddOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountUncheckedUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationUncheckedUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    AddOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyCreateWithoutAddOnsInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationCreateNestedManyWithoutAgencyInput
    Notification?: NotificationCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionCreateNestedOneWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAddOnsInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string | null
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountUncheckedCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationUncheckedCreateNestedManyWithoutAgencyInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionUncheckedCreateNestedOneWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAddOnsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAddOnsInput, AgencyUncheckedCreateWithoutAddOnsInput>
  }

  export type AgencyUpsertWithoutAddOnsInput = {
    update: XOR<AgencyUpdateWithoutAddOnsInput, AgencyUncheckedUpdateWithoutAddOnsInput>
    create: XOR<AgencyCreateWithoutAddOnsInput, AgencyUncheckedCreateWithoutAddOnsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAddOnsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAddOnsInput, AgencyUncheckedUpdateWithoutAddOnsInput>
  }

  export type AgencyUpdateWithoutAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionUpdateOneWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountUncheckedUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationUncheckedUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionUncheckedUpdateOneWithoutAgencyNestedInput
  }

  export type PermissionsCreateManyUserInput = {
    id?: string
    subAccountId: string
    access: boolean
  }

  export type TicketsCreateManyAssignedInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    laneId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    customerId?: string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    notification: string
    agencyId: string
    subAccountId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
    subAccount?: SubAccountUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type PermissionsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TicketsUpdateWithoutAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Lane?: LaneUpdateOneRequiredWithoutTicketsNestedInput
    Tags?: TagsUpdateManyWithoutTicketsNestedInput
    Customer?: ContactUpdateOneWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateWithoutAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laneId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    Tags?: TagsUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateManyWithoutAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laneId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Agency?: AgencyUpdateOneRequiredWithoutNotificationNestedInput
    SubAccount?: SubAccountUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyAgencyInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
  }

  export type SubAccountCreateManyAgencyInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAccountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
  }

  export type AgencySidebarOptionCreateManyAgencyInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationCreateManyAgencyInput = {
    id?: string
    email: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
  }

  export type NotificationCreateManyAgencyInput = {
    id?: string
    notification: string
    subAccountId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddOnsCreateManyAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
  }

  export type UserUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    Permissions?: PermissionsUpdateManyWithoutUserNestedInput
    Tickets?: TicketsUpdateManyWithoutAssignedNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    Permissions?: PermissionsUncheckedUpdateManyWithoutUserNestedInput
    Tickets?: TicketsUncheckedUpdateManyWithoutAssignedNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type SubAccountUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    SidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    SidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAccountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutSubAccountNestedInput
    Trigger?: TriggerUncheckedUpdateManyWithoutSubAccountNestedInput
    Automation?: AutomationUncheckedUpdateManyWithoutSubAccountNestedInput
    Pipeline?: PipelineUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAccountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
  }

  export type AgencySidebarOptionUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencySidebarOptionUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencySidebarOptionUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type InvitationUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type InvitationUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type NotificationUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutNotificationNestedInput
    SubAccount?: SubAccountUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddOnsUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
  }

  export type AddOnsUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
  }

  export type AddOnsUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
  }

  export type SubAccountSidebarOptionCreateManySubAccountInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionsCreateManySubAccountInput = {
    id?: string
    email: string
    access: boolean
  }

  export type FunnelsCreateManySubAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
  }

  export type MediaCreateManySubAccountInput = {
    id?: string
    type?: string | null
    name: string
    link: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManySubAccountInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TriggerCreateManySubAccountInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationCreateManySubAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerId?: string | null
    published?: boolean
  }

  export type PipelineCreateManySubAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagsCreateManySubAccountInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketsId?: string | null
  }

  export type NotificationCreateManySubAccountInput = {
    id?: string
    notification: string
    agencyId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubAccountSidebarOptionUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubAccountSidebarOptionUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionsUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type PermissionsUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionsUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FunnelsUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    FunnelPages?: FunnelPagesUpdateManyWithoutFunnelsNestedInput
    ClassName?: ClassNameUpdateManyWithoutFunnelsNestedInput
  }

  export type FunnelsUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    FunnelPages?: FunnelPagesUncheckedUpdateManyWithoutFunnelsNestedInput
    ClassName?: ClassNameUncheckedUpdateManyWithoutFunnelsNestedInput
  }

  export type FunnelsUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MediaUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Tickets?: TicketsUpdateManyWithoutCustomerNestedInput
  }

  export type ContactUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Tickets?: TicketsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriggerUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Automation?: AutomationUpdateManyWithoutTriggerNestedInput
  }

  export type TriggerUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Automation?: AutomationUncheckedUpdateManyWithoutTriggerNestedInput
  }

  export type TriggerUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    Trigger?: TriggerUpdateOneWithoutAutomationNestedInput
    Action?: ActionUpdateManyWithoutAutomationNestedInput
    AutomationInstance?: AutomationInstanceUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    Action?: ActionUncheckedUpdateManyWithoutAutomationNestedInput
    AutomationInstance?: AutomationInstanceUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PipelineUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lane?: LaneUpdateManyWithoutPipelineNestedInput
  }

  export type PipelineUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lane?: LaneUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type PipelineUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Tickets?: TicketsUpdateOneWithoutTagsNestedInput
  }

  export type TagsUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagsUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutNotificationNestedInput
    Agency?: AgencyUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaneCreateManyPipelineInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
  }

  export type LaneUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    Tickets?: TicketsUpdateManyWithoutLaneNestedInput
  }

  export type LaneUncheckedUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    Tickets?: TicketsUncheckedUpdateManyWithoutLaneNestedInput
  }

  export type LaneUncheckedUpdateManyWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TicketsCreateManyLaneInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    customerId?: string | null
    assignedUserId?: string | null
  }

  export type TicketsUpdateWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Tags?: TagsUpdateManyWithoutTicketsNestedInput
    Customer?: ContactUpdateOneWithoutTicketsNestedInput
    Assigned?: UserUpdateOneWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    Tags?: TagsUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateManyWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagsCreateManyTicketsInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type TagsUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccount?: SubAccountUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagsUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type TagsUncheckedUpdateManyWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type AutomationCreateManyTriggerInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    subAccountId: string
  }

  export type AutomationUpdateWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    SubAccount?: SubAccountUpdateOneRequiredWithoutAutomationNestedInput
    Action?: ActionUpdateManyWithoutAutomationNestedInput
    AutomationInstance?: AutomationInstanceUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
    Action?: ActionUncheckedUpdateManyWithoutAutomationNestedInput
    AutomationInstance?: AutomationInstanceUncheckedUpdateManyWithoutAutomationNestedInput
  }

  export type AutomationUncheckedUpdateManyWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type ActionCreateManyAutomationInput = {
    id?: string
    name: string
    type: $Enums.ActionType
    createdAt?: Date | string
    updatedAt?: Date | string
    order: number
    laneId?: string
  }

  export type AutomationInstanceCreateManyAutomationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
  }

  export type ActionUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
  }

  export type ActionUncheckedUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
  }

  export type ActionUncheckedUpdateManyWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
  }

  export type AutomationInstanceUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationInstanceUncheckedUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationInstanceUncheckedUpdateManyWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TicketsCreateManyCustomerInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    laneId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    assignedUserId?: string | null
  }

  export type TicketsUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Lane?: LaneUpdateOneRequiredWithoutTicketsNestedInput
    Tags?: TagsUpdateManyWithoutTicketsNestedInput
    Assigned?: UserUpdateOneWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laneId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    Tags?: TagsUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laneId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunnelPagesCreateManyFunnelsInput = {
    id?: string
    name: string
    pathName?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: number
    content?: string | null
    order: number
    previewImage?: string | null
  }

  export type ClassNameCreateManyFunnelsInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customDate?: string | null
  }

  export type FunnelPagesUpdateWithoutFunnelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunnelPagesUncheckedUpdateWithoutFunnelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunnelPagesUncheckedUpdateManyWithoutFunnelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameUpdateWithoutFunnelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameUncheckedUpdateWithoutFunnelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameUncheckedUpdateManyWithoutFunnelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customDate?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}